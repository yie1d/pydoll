{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pydoll","text":""},{"location":"#welcome-to-pydoll","title":"Welcome to Pydoll","text":"<p>Hey there! Thanks for checking out Pydoll, the next generation of browser automation for Python. If you're tired of wrestling with webdrivers and looking for a smoother, more reliable way to automate browsers, you're in the right place.</p>"},{"location":"#what-is-pydoll","title":"What is Pydoll?","text":"<p>Pydoll is revolutionizing browser automation by eliminating the need for webdrivers completely! Unlike other solutions that rely on external dependencies, Pydoll connects directly to browsers using their DevTools Protocol, providing a seamless and reliable automation experience with native asynchronous performance.</p> <p>Whether you're scraping data, testing web applications, or automating repetitive tasks, Pydoll makes it surprisingly easy with its intuitive API and powerful features.</p>"},{"location":"#installation","title":"Installation","text":"<p>Create and activate a virtual environment first, then install Pydoll:</p> <pre><code>$ pip install pydoll-python\n\n---&gt; 100%\n</code></pre> <p>For the latest development version, you can install directly from GitHub:</p> <pre><code>$ pip install git+https://github.com/autoscrape-labs/pydoll.git\n</code></pre>"},{"location":"#why-choose-pydoll","title":"Why Choose Pydoll?","text":"<ul> <li>Genuine Simplicity: We don't want you wasting time configuring drivers or dealing with compatibility issues. With Pydoll, you install and you're ready to automate.</li> <li>Truly Human Interactions: Our algorithms simulate real human behavior patterns - from timing between clicks to how the mouse moves across the screen.</li> <li>Native Async Performance: Built from the ground up with <code>asyncio</code>, Pydoll doesn't just support asynchronous operations - it was designed for them.</li> <li>Integrated Intelligence: Automatic bypass of Cloudflare Turnstile and reCAPTCHA v3 captchas, without external services or complex configurations.</li> <li>Powerful Network Monitoring: Intercept, modify, and analyze all network traffic with ease, giving you complete control over requests.</li> <li>Event-Driven Architecture: React to page events, network requests, and user interactions in real-time.</li> <li>Intuitive Element Finding: Modern <code>find()</code> and <code>query()</code> methods that make sense and work as you'd expect.</li> <li>Robust Type Safety: Comprehensive type system for better IDE support and error prevention.</li> </ul> <p>Ready to dive in? The following pages will guide you through installation, basic usage, and advanced features to help you get the most out of Pydoll.</p> <p>Let's start automating the web, the right way! \ud83d\ude80</p>"},{"location":"#quick-start-guide-a-simple-example","title":"Quick Start Guide: A simple example","text":"<p>Let's start with a practical example. The following script will open the Pydoll GitHub repository and star it:</p> <pre><code>import asyncio\nfrom pydoll.browser.chromium import Chrome\n\nasync def main():\n    async with Chrome() as browser:\n        tab = await browser.start()\n        await tab.go_to('https://github.com/autoscrape-labs/pydoll')\n\n        star_button = await tab.find(\n            tag_name='button',\n            timeout=5,\n            raise_exc=False\n        )\n        if not star_button:\n            print(\"Ops! The button was not found.\")\n            return\n\n        await star_button.click()\n        await asyncio.sleep(3)\n\nasyncio.run(main())\n</code></pre> <p>This example demonstrates how to navigate to a website, wait for an element to appear, and interact with it. You can adapt this pattern to automate many different web tasks.</p> Or use without context manager... <p>If you prefer not to use the context manager pattern, you can manually manage the browser instance:</p> <pre><code>import asyncio\nfrom pydoll.browser.chromium import Chrome\n\nasync def main():\n    browser = Chrome()\n    tab = await browser.start()\n    await tab.go_to('https://github.com/autoscrape-labs/pydoll')\n\n    star_button = await tab.find(\n        tag_name='button',\n        timeout=5,\n        raise_exc=False\n    )\n    if not star_button:\n        print(\"Ops! The button was not found.\")\n        return\n\n    await star_button.click()\n    await asyncio.sleep(3)\n    await browser.stop()\n\nasyncio.run(main())\n</code></pre> <p>Note that when not using the context manager, you'll need to explicitly call <code>browser.stop()</code> to release resources.</p>"},{"location":"#extended-example-custom-browser-configuration","title":"Extended Example: Custom Browser Configuration","text":"<p>For more advanced usage scenarios, Pydoll allows you to customize your browser configuration using the <code>ChromiumOptions</code> class. This is useful when you need to:</p> <ul> <li>Run in headless mode (no visible browser window)</li> <li>Specify a custom browser executable path</li> <li>Configure proxies, user agents, or other browser settings</li> <li>Set window dimensions or startup arguments</li> </ul> <p>Here's an example showing how to use custom options for Chrome:</p> <pre><code>import asyncio\nimport os\nfrom pydoll.browser.chromium import Chrome\nfrom pydoll.browser.options import ChromiumOptions\n\nasync def main():\n    options = ChromiumOptions()\n    options.binary_location = '/usr/bin/google-chrome-stable'\n    options.add_argument('--headless=new')\n    options.add_argument('--start-maximized')\n    options.add_argument('--disable-notifications')\n\n    async with Chrome(options=options) as browser:\n        tab = await browser.start()\n        await tab.go_to('https://github.com/autoscrape-labs/pydoll')\n\n        star_button = await tab.find(\n            tag_name='button',\n            timeout=5,\n            raise_exc=False\n        )\n        if not star_button:\n            print(\"Ops! The button was not found.\")\n            return\n\n        await star_button.click()\n        await asyncio.sleep(3)\n\n        screenshot_path = os.path.join(os.getcwd(), 'pydoll_repo.png')\n        await tab.take_screenshot(path=screenshot_path)\n        print(f\"Screenshot saved to: {screenshot_path}\")\n\n        base64_screenshot = await tab.take_screenshot(as_base64=True)\n\n        repo_description_element = await tab.find(\n            class_name='f4.my-3'\n        )\n        repo_description = await repo_description_element.text\n        print(f\"Repository description: {repo_description}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>This extended example demonstrates:</p> <ol> <li>Creating and configuring browser options</li> <li>Setting a custom Chrome binary path</li> <li>Enabling headless mode for invisible operation</li> <li>Setting additional browser flags</li> <li>Taking screenshots (especially useful in headless mode)</li> </ol> About Chromium Options <p>The <code>options.add_argument()</code> method allows you to pass any Chromium command-line argument to customize browser behavior. There are hundreds of available options to control everything from networking to rendering behavior.</p> <p>Common Chrome Options</p> <pre><code># Performance &amp; Behavior Options\noptions.add_argument('--headless=new')         # Run Chrome in headless mode\noptions.add_argument('--disable-gpu')          # Disable GPU hardware acceleration\noptions.add_argument('--no-sandbox')           # Disable sandbox (use with caution)\noptions.add_argument('--disable-dev-shm-usage') # Overcome limited resource issues\n\n# Appearance Options\noptions.add_argument('--start-maximized')      # Start with maximized window\noptions.add_argument('--window-size=1920,1080') # Set specific window size\noptions.add_argument('--hide-scrollbars')      # Hide scrollbars\n\n# Network Options\noptions.add_argument('--proxy-server=socks5://127.0.0.1:9050') # Use proxy\noptions.add_argument('--disable-extensions')   # Disable extensions\noptions.add_argument('--disable-notifications') # Disable notifications\n\n# Privacy &amp; Security\noptions.add_argument('--incognito')            # Run in incognito mode\noptions.add_argument('--disable-infobars')     # Disable infobars\n</code></pre> <p>Complete Reference Guides</p> <p>For a comprehensive list of all available Chrome command-line arguments, refer to these resources:</p> <ul> <li>Chromium Command Line Switches - Complete reference list</li> <li>Chrome Flags - Enter this in your Chrome browser address bar to see experimental features</li> <li>Chromium Source Code Flags - Direct source code reference</li> </ul> <p>Remember that some options may behave differently across Chrome versions, so it's a good practice to test your configuration when upgrading Chrome.</p> <p>With these configurations, you can run Pydoll in various environments, including CI/CD pipelines, servers without displays, or Docker containers.</p> <p>Continue reading the documentation to explore Pydoll's powerful features for handling captchas, working with multiple tabs, interacting with elements, and more.</p>"},{"location":"#minimal-dependencies","title":"Minimal Dependencies","text":"<p>One of Pydoll's advantages is its lightweight footprint. Unlike other browser automation tools that require numerous dependencies, Pydoll is intentionally designed to be minimalist while maintaining powerful capabilities.</p>"},{"location":"#core-dependencies","title":"Core Dependencies","text":"<p>Pydoll relies on just a few carefully selected packages:</p> <pre><code>python = \"^3.10\"\nwebsockets = \"^13.1\"\naiohttp = \"^3.9.5\"\naiofiles = \"^23.2.1\"\nbs4 = \"^0.0.2\"\n</code></pre> <p>That's it! This minimal dependency approach means:</p> <ul> <li>Faster installation - No complex dependency tree to resolve</li> <li>Fewer conflicts - Reduced chance of version conflicts with other packages</li> <li>Smaller footprint - Lower disk space usage</li> <li>Better security - Smaller attack surface and dependency-related vulnerabilities</li> <li>Easier updates - Simpler maintenance and fewer breaking changes</li> </ul> <p>The small number of dependencies also contributes to Pydoll's reliability and performance, as there are fewer external factors that could impact its operation.</p>"},{"location":"#license","title":"License","text":"<p>Pydoll is released under the MIT License, which gives you the freedom to use, modify, and distribute the code with minimal restrictions. This permissive license makes Pydoll suitable for both personal and commercial projects.</p> View Full MIT License Text <pre><code>MIT License\n\nCopyright (c) 2023 Pydoll Contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"features/","title":"Key Features","text":"<p>Pydoll brings groundbreaking capabilities to browser automation, making it significantly more powerful than traditional tools while being easier to use.</p>"},{"location":"features/#core-capabilities","title":"Core Capabilities","text":""},{"location":"features/#zero-webdrivers","title":"Zero WebDrivers","text":"<p>Unlike traditional browser automation tools like Selenium, Pydoll eliminates the need for WebDrivers entirely. By connecting directly to browsers through the Chrome DevTools Protocol, Pydoll:</p> <ul> <li>Eliminates version compatibility issues between browser and driver</li> <li>Reduces setup complexity and maintenance overhead</li> <li>Provides more reliable connections without driver-related issues</li> <li>Allows for automation of all Chromium-based browsers with a unified API</li> </ul> <p>No more \"chromedriver version doesn't match Chrome version\" errors or mysterious webdriver crashes.</p>"},{"location":"features/#async-first-architecture","title":"Async-First Architecture","text":"<p>Built from the ground up with Python's asyncio, Pydoll provides:</p> <ul> <li>True Concurrency: Run multiple operations in parallel without blocking</li> <li>Efficient Resource Usage: Manage many browser instances with minimal overhead</li> <li>Modern Python Patterns: Context managers, async iterators, and other asyncio-friendly interfaces</li> <li>Performance Optimizations: Reduced latency and increased throughput for automation tasks</li> </ul>"},{"location":"features/#human-like-interactions","title":"Human-Like Interactions","text":"<p>Avoid detection by mimicking real user behavior:</p> <ul> <li>Natural Typing: Type text with randomized timing between keystrokes</li> <li>Realistic clicking: Click with realistic timing and movement, including offset</li> </ul>"},{"location":"features/#event-driven-capabilities","title":"Event-Driven Capabilities","text":"<p>Respond to browser events in real-time:</p> <ul> <li>Network Monitoring: Track requests, responses, and failed loads</li> <li>DOM Observation: React to changes in the page structure</li> <li>Page Lifecycle Events: Capture navigation, loading, and rendering events</li> <li>Custom Event Handlers: Register callbacks for specific events of interest</li> </ul>"},{"location":"features/#multi-browser-support","title":"Multi-Browser Support","text":"<p>Pydoll works seamlessly with:</p> <ul> <li>Google Chrome: Primary support with all features available</li> <li>Microsoft Edge: Full support for Edge-specific features</li> <li>Chromium: Support for other Chromium-based browsers</li> </ul>"},{"location":"features/#screenshot-and-pdf-export","title":"Screenshot and PDF Export","text":"<p>Capture visual content from web pages:</p> <ul> <li>Full Page Screenshots: Capture entire page content, even beyond the viewport</li> <li>Element Screenshots: Target specific elements for capture</li> <li>High-Quality PDF Export: Generate PDF documents from web pages</li> <li>Custom Formatting: Coming soon!</li> </ul>"},{"location":"features/#intuitive-element-finding","title":"Intuitive Element Finding","text":"<p>Pydoll v2.0+ introduces a revolutionary approach to finding elements that's both more intuitive and more powerful than traditional selector-based methods.</p>"},{"location":"features/#modern-find-method","title":"Modern find() Method","text":"<p>The new <code>find()</code> method allows you to search for elements using natural attributes:</p> <pre><code>import asyncio\nfrom pydoll.browser.chromium import Chrome\n\nasync def element_finding_examples():\n    async with Chrome() as browser:\n        tab = await browser.start()\n        await tab.go_to('https://example.com')\n\n        # Find by tag name and class\n        submit_button = await tab.find(tag_name='button', class_name='btn-primary')\n\n        # Find by ID (most common)\n        username_field = await tab.find(id='username')\n\n        # Find by text content\n        login_link = await tab.find(tag_name='a', text='Login')\n\n        # Find by multiple attributes\n        search_input = await tab.find(\n            tag_name='input',\n            type='text',\n            placeholder='Search...'\n        )\n\n        # Find with custom data attributes\n        custom_element = await tab.find(\n            data_testid='submit-button',\n            aria_label='Submit form'\n        )\n\n        # Find multiple elements\n        all_links = await tab.find(tag_name='a', find_all=True)\n\n        # With timeout and error handling\n        delayed_element = await tab.find(\n            class_name='dynamic-content',\n            timeout=10,\n            raise_exc=False  # Returns None if not found\n        )\n\nasyncio.run(element_finding_examples())\n</code></pre>"},{"location":"features/#css-selectors-and-xpath-with-query","title":"CSS Selectors and XPath with query()","text":"<p>For developers who prefer traditional selectors, the <code>query()</code> method provides direct CSS selector and XPath support:</p> <pre><code>import asyncio\nfrom pydoll.browser.chromium import Chrome\n\nasync def query_examples():\n    async with Chrome() as browser:\n        tab = await browser.start()\n        await tab.go_to('https://example.com')\n\n        # CSS selectors\n        nav_menu = await tab.query('nav.main-menu')\n        first_article = await tab.query('article:first-child')\n        submit_button = await tab.query('button[type=\"submit\"]')\n\n        # XPath expressions\n        specific_item = await tab.query('//div[@data-testid=\"item-123\"]')\n        text_content = await tab.query('//span[contains(text(), \"Welcome\")]')\n\n        # Complex selectors\n        nested_element = await tab.query('div.container &gt; .content .item:nth-child(2)')\n\nasyncio.run(query_examples())\n</code></pre>"},{"location":"features/#native-cloudflare-captcha-bypass","title":"Native Cloudflare Captcha Bypass","text":"<p>Important Information About Captcha Bypass</p> <p>The effectiveness of Cloudflare Turnstile bypass depends on several factors:</p> <ul> <li>IP Reputation: Cloudflare assigns a \"trust score\" to each IP address. Clean residential IPs typically receive higher scores.</li> <li>Previous History: IPs with a history of suspicious activity may be permanently flagged.</li> </ul> <p>Pydoll can achieve scores comparable to a regular browser session, but cannot overcome IP-based blocks or extremely restrictive configurations. For best results, use residential IPs with good reputation.</p> <p>Remember that captcha bypass techniques operate in a gray area and should be used responsibly.</p> <p>One of Pydoll's most powerful features is its ability to automatically bypass Cloudflare Turnstile captchas that block most automation tools:</p>"},{"location":"features/#context-manager-approach-synchronous","title":"Context Manager Approach (Synchronous)","text":"<pre><code>import asyncio\nfrom pydoll.browser.chromium import Chrome\n\nasync def bypass_cloudflare_example():\n    async with Chrome() as browser:\n        tab = await browser.start()\n\n    # The context manager will wait for the captcha to be processed\n    # before continuing execution\n        async with tab.expect_and_bypass_cloudflare_captcha():\n            await tab.go_to('https://site-with-cloudflare.com')\n        print(\"Waiting for captcha to be handled...\")\n\n    # This code runs only after the captcha is successfully bypassed\n    print(\"Captcha bypassed! Continuing with automation...\")\n        protected_content = await tab.find(id='protected-content')\n        content_text = await protected_content.text\n        print(f\"Protected content: {content_text}\")\n\nasyncio.run(bypass_cloudflare_example())\n</code></pre>"},{"location":"features/#background-processing-approach","title":"Background Processing Approach","text":"<pre><code>import asyncio\nfrom pydoll.browser.chromium import Chrome\n\nasync def background_bypass_example():\n    async with Chrome() as browser:\n        tab = await browser.start()\n\n    # Enable automatic captcha solving before navigating\n        await tab.enable_auto_solve_cloudflare_captcha()\n\n    # Navigate to the protected site - captcha handled automatically in background\n        await tab.go_to('https://site-with-cloudflare.com')\n    print(\"Page loaded, captcha will be handled in the background...\")\n\n    # Add a small delay to allow captcha solving to complete\n    await asyncio.sleep(3)\n\n    # Continue with automation\n        protected_content = await tab.find(id='protected-content')\n        content_text = await protected_content.text\n        print(f\"Protected content: {content_text}\")\n\n    # Disable auto-solving when no longer needed\n        await tab.disable_auto_solve_cloudflare_captcha()\n\nasyncio.run(background_bypass_example())\n</code></pre> <p>Access websites that actively block automation tools without using third-party captcha solving services. This native captcha handling makes Pydoll suitable for automating previously inaccessible websites.</p>"},{"location":"features/#multi-tab-management","title":"Multi-Tab Management","text":"<p>Pydoll provides sophisticated tab management capabilities with a singleton pattern that ensures efficient resource usage and prevents duplicate Tab instances for the same browser tab.</p>"},{"location":"features/#tab-singleton-pattern","title":"Tab Singleton Pattern","text":"<p>Pydoll implements a singleton pattern for Tab instances based on the browser's target ID. This means:</p> <ul> <li>One Tab instance per browser tab: Multiple references to the same browser tab return the same Tab object</li> <li>Automatic resource management: No duplicate connections or handlers for the same tab</li> <li>Consistent state: All references to a tab share the same state and event handlers</li> </ul> <pre><code>import asyncio\nfrom pydoll.browser.chromium import Chrome\nfrom pydoll.browser.tab import Tab\n\nasync def singleton_demonstration():\n    async with Chrome() as browser:\n        tab = await browser.start()\n\n        # Get the same tab through different methods - they're identical objects\n        same_tab = Tab(browser, browser._connection_port, tab._target_id)\n        opened_tabs = await browser.get_opened_tabs()\n\n        # All references point to the same singleton instance\n        print(f\"Same object? {tab is same_tab}\")  # May be True if same target_id\n        print(f\"Tab instances are managed as singletons\")\n\nasyncio.run(singleton_demonstration())\n</code></pre>"},{"location":"features/#creating-new-tabs-programmatically","title":"Creating New Tabs Programmatically","text":"<p>Use <code>new_tab()</code> to create tabs programmatically with full control:</p> <pre><code>import asyncio\nfrom pydoll.browser.chromium import Chrome\n\nasync def programmatic_tab_creation():\n    async with Chrome() as browser:\n        # Start with the initial tab\n        main_tab = await browser.start()\n\n        # Create additional tabs with specific URLs\n        search_tab = await browser.new_tab('https://google.com')\n        news_tab = await browser.new_tab('https://news.ycombinator.com')\n        docs_tab = await browser.new_tab('https://docs.python.org')\n\n        # Work with multiple tabs simultaneously\n        await search_tab.find(name='q').type_text('Python automation')\n        await news_tab.find(class_name='storylink', find_all=True)\n        await docs_tab.find(id='search-field').type_text('asyncio')\n\n        # Get all opened tabs\n        all_tabs = await browser.get_opened_tabs()\n        print(f\"Total tabs open: {len(all_tabs)}\")\n\n        # Close specific tabs when done\n        await search_tab.close()\n        await news_tab.close()\n\nasyncio.run(programmatic_tab_creation())\n</code></pre>"},{"location":"features/#handling-user-opened-tabs","title":"Handling User-Opened Tabs","text":"<p>When users click links that open new tabs (target=\"_blank\"), use <code>get_opened_tabs()</code> to detect and manage them:</p> <pre><code>import asyncio\nfrom pydoll.browser.chromium import Chrome\n\nasync def handle_user_opened_tabs():\n    async with Chrome() as browser:\n        main_tab = await browser.start()\n        await main_tab.go_to('https://example.com')\n\n        # Get initial tab count\n        initial_tabs = await browser.get_opened_tabs()\n        initial_count = len(initial_tabs)\n        print(f\"Initial tabs: {initial_count}\")\n\n        # Click a link that opens a new tab (target=\"_blank\")\n        external_link = await main_tab.find(text='Open in New Tab')\n        await external_link.click()\n\n        # Wait for new tab to open\n        await asyncio.sleep(2)\n\n        # Detect new tabs\n        current_tabs = await browser.get_opened_tabs()\n        new_tab_count = len(current_tabs)\n\n        if new_tab_count &gt; initial_count:\n            print(f\"New tab detected! Total tabs: {new_tab_count}\")\n\n            # Get the newly opened tab (last in the list)\n            new_tab = current_tabs[-1]\n\n            # Work with the new tab\n            await new_tab.go_to('https://different-site.com')\n            title = await new_tab.execute_script('return document.title')\n            print(f\"New tab title: {title}\")\n\n            # Close the new tab when done\n            await new_tab.close()\n\nasyncio.run(handle_user_opened_tabs())\n</code></pre>"},{"location":"features/#key-benefits-of-pydolls-tab-management","title":"Key Benefits of Pydoll's Tab Management","text":"<ol> <li>Singleton Pattern: Prevents resource duplication and ensures consistent state</li> <li>Automatic Detection: <code>get_opened_tabs()</code> finds all tabs, including user-opened ones</li> <li>Concurrent Processing: Handle multiple tabs simultaneously with asyncio</li> <li>Resource Management: Proper cleanup prevents memory leaks</li> <li>Event Isolation: Each tab maintains its own event handlers and state</li> </ol> <p>This sophisticated tab management makes Pydoll ideal for: - Multi-page workflows that require coordination between tabs - Parallel data extraction from multiple sources - Testing applications that use popup windows or new tabs - Monitoring user behavior across multiple browser tabs</p>"},{"location":"features/#concurrent-scraping","title":"Concurrent Scraping","text":"<p>Pydoll's async architecture allows you to scrape multiple pages or websites simultaneously for maximum efficiency:</p> <pre><code>import asyncio\nfrom functools import partial\nfrom pydoll.browser.chromium import Chrome\n\nasync def scrape_page(browser, url):\n    \"\"\"Process a single page and extract data using a shared browser\"\"\"\n    # Create a new tab for this URL\n    tab = await browser.new_tab()\n\n    try:\n        await tab.go_to(url)\n\n        # Extract data\n        title = await tab.execute_script('return document.title')\n\n        # Find elements and extract content\n        elements = await tab.find(class_name='article-content', find_all=True)\n        content = []\n        for element in elements:\n            text = await element.text\n            content.append(text)\n\n        return {\n            \"url\": url,\n            \"title\": title,\n            \"content\": content\n        }\n    finally:\n        # Close the tab when done to free resources\n        await tab.close()\n\nasync def main():\n    # List of URLs to scrape in parallel\n    urls = [\n        'https://example.com/page1',\n        'https://example.com/page2',\n        'https://example.com/page3',\n        'https://example.com/page4',\n        'https://example.com/page5',\n    ]\n\n    async with Chrome() as browser:\n        # Start the browser once\n        await browser.start()\n\n        # Create partial function with browser parameter\n        scrape_with_browser = partial(scrape_page, browser)\n\n        # Process all URLs concurrently using the same browser\n        results = await asyncio.gather(*(scrape_with_browser(url) for url in urls))\n\n    # Print results\n    for result in results:\n        print(f\"Scraped {result['url']}: {result['title']}\")\n        print(f\"Found {len(result['content'])} content blocks\")\n\n    return results\n\n# Run the concurrent scraping\nall_data = asyncio.run(main())\n</code></pre> <p>This approach provides dramatic performance improvements over sequential scraping, especially for I/O-bound tasks like web scraping. Instead of waiting for each page to load one after another, Pydoll processes them all simultaneously, reducing total execution time significantly. For example, scraping 10 pages that each take 2 seconds to load would take just over 2 seconds total instead of 20+ seconds with sequential processing.</p>"},{"location":"features/#advanced-keyboard-control","title":"Advanced Keyboard Control","text":"<p>Pydoll provides human-like keyboard interaction with precise control over typing behavior:</p> <pre><code>import asyncio\nfrom pydoll.browser.chromium import Chrome\nfrom pydoll.common.keys import Keys\n\nasync def realistic_typing_example():\n    async with Chrome() as browser:\n        tab = await browser.start()\n        await tab.go_to('https://example.com/login')\n\n        # Find login form elements\n        username = await tab.find(id='username')\n        password = await tab.find(id='password')\n\n        # Type with realistic timing (interval between keystrokes)\n        await username.type_text(\"user@example.com\", interval=0.15)\n\n        # Use special key combinations\n        await password.click()\n        await password.key_down(Keys.SHIFT)\n        await password.type_text(\"PASSWORD\")\n        await password.key_up(Keys.SHIFT)\n\n        # Press Enter to submit\n        await password.press_keyboard_key(Keys.ENTER)\n\n        # Wait for navigation\n        await asyncio.sleep(2)\n        print(\"Logged in successfully!\")\n\nasyncio.run(realistic_typing_example())\n</code></pre> <p>This realistic typing helps avoid detection by websites that look for automation patterns. The natural timing and ability to use special key combinations makes Pydoll's interactions virtually indistinguishable from human users.</p>"},{"location":"features/#powerful-event-system","title":"Powerful Event System","text":"<p>Pydoll's event system allows you to react to browser events in real-time:</p> <pre><code>import asyncio\nfrom pydoll.browser.chromium import Chrome\nfrom pydoll.protocol.page.events import PageEvent\n\nasync def event_monitoring_example():\n    async with Chrome() as browser:\n        tab = await browser.start()\n\n        # Monitor page load events\n        async def on_page_loaded(event):\n            print(f\"\ud83c\udf10 Page loaded: {event['params'].get('url')}\")\n\n        await tab.enable_page_events()\n        await tab.on(PageEvent.LOAD_EVENT_FIRED, on_page_loaded)\n\n        # Monitor network requests\n        async def on_request(event):\n            url = event['params']['request']['url']\n            print(f\"\ud83d\udd04 Request to: {url}\")\n\n        await tab.enable_network_events()\n        await tab.on('Network.requestWillBeSent', on_request)\n\n        # Navigate and see events in action\n        await tab.go_to('https://example.com')\n        await asyncio.sleep(5)  # Allow time to see events\n\nasyncio.run(event_monitoring_example())\n</code></pre> <p>The event system makes Pydoll uniquely powerful for monitoring API requests and responses, creating reactive automations, debugging complex web applications, and building comprehensive web monitoring tools.</p>"},{"location":"features/#network-analysis-and-response-extraction","title":"Network Analysis and Response Extraction","text":"<p>Pydoll provides powerful methods for analyzing network traffic and extracting response data from web applications. These capabilities are essential for API monitoring, data extraction, and debugging network-related issues.</p>"},{"location":"features/#network-logs-analysis","title":"Network Logs Analysis","text":"<p>The <code>get_network_logs()</code> method allows you to retrieve and analyze all network requests made by a page:</p> <pre><code>import asyncio\nfrom pydoll.browser.chromium import Chrome\n\nasync def network_analysis_example():\n    async with Chrome() as browser:\n        tab = await browser.start()\n\n        # Enable network monitoring\n        await tab.enable_network_events()\n\n        # Navigate to a page with API calls\n        await tab.go_to('https://example.com/dashboard')\n\n        # Wait for page to load and make requests\n        await asyncio.sleep(3)\n\n        # Get all network logs\n        all_logs = await tab.get_network_logs()\n        print(f\"Total network requests: {len(all_logs)}\")\n\n        # Filter logs for API requests only\n        api_logs = await tab.get_network_logs(filter='api')\n        print(f\"API requests: {len(api_logs)}\")\n\n        # Filter logs for specific domain\n        domain_logs = await tab.get_network_logs(filter='example.com')\n        print(f\"Requests to example.com: {len(domain_logs)}\")\n\n        # Analyze request patterns\n        for log in api_logs:\n            request = log['params'].get('request', {})\n            url = request.get('url', 'Unknown')\n            method = request.get('method', 'Unknown')\n            print(f\"\ud83d\udce1 {method} {url}\")\n\nasyncio.run(network_analysis_example())\n</code></pre>"},{"location":"features/#response-body-extraction","title":"Response Body Extraction","text":"<p>The <code>get_network_response_body()</code> method enables you to extract the actual response content from network requests:</p> <pre><code>import asyncio\nimport json\nfrom functools import partial\nfrom pydoll.browser.chromium import Chrome\nfrom pydoll.protocol.network.events import NetworkEvent\n\nasync def response_extraction_example():\n    async with Chrome() as browser:\n        tab = await browser.start()\n\n        # Storage for API responses\n        api_responses = {}\n\n        async def capture_api_responses(tab, event):\n            \"\"\"Capture API response bodies\"\"\"\n            request_id = event['params']['requestId']\n            response = event['params']['response']\n            url = response['url']\n\n            # Only capture successful API responses\n            if '/api/' in url and response['status'] == 200:\n                try:\n                    # Extract the response body\n                    body = await tab.get_network_response_body(request_id)\n\n                    # Try to parse as JSON\n                    try:\n                        data = json.loads(body)\n                        api_responses[url] = data\n                        print(f\"\u2705 Captured API response from: {url}\")\n                        print(f\"Data keys: {list(data.keys()) if isinstance(data, dict) else 'Non-dict response'}\")\n                    except json.JSONDecodeError:\n                        # Handle non-JSON responses\n                        api_responses[url] = body\n                        print(f\"\ud83d\udcc4 Captured text response from: {url} ({len(body)} chars)\")\n\n                except Exception as e:\n                    print(f\"\u274c Failed to get response body for {url}: {e}\")\n\n        # Enable network monitoring and register callback\n        await tab.enable_network_events()\n        await tab.on(NetworkEvent.RESPONSE_RECEIVED, partial(capture_api_responses, tab))\n\n        # Navigate to a page with API calls\n        await tab.go_to('https://jsonplaceholder.typicode.com')\n\n        # Trigger some API calls by interacting with the page\n        await asyncio.sleep(5)\n\n        # Display captured responses\n        print(f\"\\n\ud83d\udcca Analysis Results:\")\n        print(f\"Captured {len(api_responses)} API responses\")\n\n        for url, data in api_responses.items():\n            if isinstance(data, dict):\n                print(f\"\ud83d\udd17 {url}: {len(data)} fields\")\n            else:\n                print(f\"\ud83d\udd17 {url}: {len(str(data))} characters\")\n\n        return api_responses\n\nasyncio.run(response_extraction_example())\n</code></pre>"},{"location":"features/#advanced-network-monitoring","title":"Advanced Network Monitoring","text":"<p>Combine both methods for comprehensive network analysis:</p> <pre><code>import asyncio\nfrom pydoll.browser.chromium import Chrome\n\nasync def comprehensive_network_monitoring():\n    async with Chrome() as browser:\n        tab = await browser.start()\n\n        # Enable network monitoring\n        await tab.enable_network_events()\n\n        # Navigate to a complex web application\n        await tab.go_to('https://example.com/app')\n\n        # Wait for initial page load and API calls\n        await asyncio.sleep(5)\n\n        # Get comprehensive network analysis\n        all_logs = await tab.get_network_logs()\n        api_logs = await tab.get_network_logs(filter='api')\n        static_logs = await tab.get_network_logs(filter='.js')\n\n        print(f\"\ud83d\udcc8 Network Traffic Summary:\")\n        print(f\"   Total requests: {len(all_logs)}\")\n        print(f\"   API calls: {len(api_logs)}\")\n        print(f\"   JavaScript files: {len(static_logs)}\")\n\n        # Analyze request types\n        request_types = {}\n        for log in all_logs:\n            request = log['params'].get('request', {})\n            url = request.get('url', '')\n\n            if '/api/' in url:\n                request_types['API'] = request_types.get('API', 0) + 1\n            elif any(ext in url for ext in ['.js', '.css', '.png', '.jpg']):\n                request_types['Static'] = request_types.get('Static', 0) + 1\n            else:\n                request_types['Other'] = request_types.get('Other', 0) + 1\n\n        print(f\"\ud83d\udcca Request breakdown: {request_types}\")\n\n        # Show API endpoints\n        print(f\"\\n\ud83d\udd17 API Endpoints Called:\")\n        for log in api_logs[:10]:  # Show first 10\n            request = log['params'].get('request', {})\n            method = request.get('method', 'GET')\n            url = request.get('url', 'Unknown')\n            print(f\"   {method} {url}\")\n\nasyncio.run(comprehensive_network_monitoring())\n</code></pre> <p>These network analysis capabilities make Pydoll ideal for:</p> <ul> <li>API Testing: Monitor and validate API responses</li> <li>Performance Analysis: Track request timing and sizes</li> <li>Data Extraction: Extract dynamic content loaded via AJAX</li> <li>Debugging: Identify failed requests and network issues</li> <li>Security Testing: Analyze request/response patterns</li> </ul>"},{"location":"features/#file-upload-support","title":"File Upload Support","text":"<p>Seamlessly handle file uploads in your automation:</p> <pre><code>import asyncio\nimport os\nfrom pydoll.browser.chromium import Chrome\n\nasync def file_upload_example():\n    async with Chrome() as browser:\n        tab = await browser.start()\n        await tab.go_to('https://example.com/upload')\n\n        # Method 1: Direct file input\n        file_input = await tab.find(tag_name='input', type='file')\n        await file_input.set_input_files('path/to/document.pdf')\n\n        # Method 2: Using file chooser with an upload button\n        sample_file = os.path.join(os.getcwd(), 'sample.jpg')\n        async with tab.expect_file_chooser(files=sample_file):\n            upload_button = await tab.find(id='upload-button')\n            await upload_button.click()\n\n        # Submit the form\n        submit = await tab.find(id='submit-button')\n        await submit.click()\n\n        print(\"Files uploaded successfully!\")\n\nasyncio.run(file_upload_example())\n</code></pre> <p>File uploads are notoriously difficult to automate in other frameworks, often requiring workarounds. Pydoll makes it straightforward with both direct file input and file chooser dialog support.</p>"},{"location":"features/#multi-browser-example","title":"Multi-Browser Example","text":"<p>Pydoll works with different browsers through a consistent API:</p> <pre><code>import asyncio\nfrom pydoll.browser.chromium import Chrome, Edge\n\nasync def multi_browser_example():\n    # Run the same automation in Chrome\n    async with Chrome() as chrome:\n        chrome_tab = await chrome.start()\n        await chrome_tab.go_to('https://example.com')\n        chrome_title = await chrome_tab.execute_script('return document.title')\n        print(f\"Chrome title: {chrome_title}\")\n\n    # Run the same automation in Edge\n    async with Edge() as edge:\n        edge_tab = await edge.start()\n        await edge_tab.go_to('https://example.com')\n        edge_title = await edge_tab.execute_script('return document.title')\n        print(f\"Edge title: {edge_title}\")\n\nasyncio.run(multi_browser_example())\n</code></pre> <p>Cross-browser compatibility without changing your code. Test your automations across different browsers to ensure they work everywhere.</p>"},{"location":"features/#proxy-integration","title":"Proxy Integration","text":"<p>Unlike many automation tools that struggle with proxy implementation, Pydoll offers native proxy support with full authentication capabilities. This makes it ideal for:</p> <ul> <li>Web scraping projects that need to rotate IPs</li> <li>Geo-targeted testing of applications across different regions</li> <li>Privacy-focused automation that requires anonymizing traffic</li> <li>Testing web applications through corporate proxies</li> </ul> <p>Configuring proxies in Pydoll is straightforward:</p> <pre><code>import asyncio\nfrom pydoll.browser.chromium import Chrome\nfrom pydoll.browser.options import ChromiumOptions\n\nasync def proxy_example():\n    # Create browser options\n    options = ChromiumOptions()\n\n    # Simple proxy without authentication\n    options.add_argument('--proxy-server=192.168.1.100:8080')\n    # Or proxy with authentication\n    # options.add_argument('--proxy-server=username:password@192.168.1.100:8080')\n\n    # Bypass proxy for specific domains\n    options.add_argument('--proxy-bypass-list=*.internal.company.com,localhost')\n\n    # Start browser with proxy configuration\n    async with Chrome(options=options) as browser:\n        tab = await browser.start()\n\n        # Test the proxy by visiting an IP echo service\n        await tab.go_to('https://api.ipify.org')\n        ip_address = await tab.execute_script('return document.body.textContent')\n        print(f\"Current IP address: {ip_address}\")\n\n        # Continue with your automation\n        await tab.go_to('https://example.com')\n        title = await tab.execute_script('return document.title')\n        print(f\"Page title: {title}\")\n\nasyncio.run(proxy_example())\n</code></pre>"},{"location":"features/#working-with-iframes","title":"Working with iFrames","text":"<p>Pydoll provides seamless iframe interaction through the <code>get_frame()</code> method:</p> <pre><code>import asyncio\nfrom pydoll.browser.chromium import Chrome\n\nasync def iframe_interaction():\n    async with Chrome() as browser:\n        tab = await browser.start()\n        await tab.go_to('https://example.com/page-with-iframe')\n\n        # Find the iframe element\n        iframe_element = await tab.query('.hcaptcha-iframe', timeout=10)\n\n        # Get a Tab instance for the iframe content\n        frame = await tab.get_frame(iframe_element)\n\n        # Now interact with elements inside the iframe\n        submit_button = await frame.find(tag_name='button', class_name='submit')\n        await submit_button.click()\n\n        # You can use all Tab methods on the frame\n        form_input = await frame.find(id='captcha-input')\n        await form_input.type_text('verification-code')\n\n        # Find elements by various methods\n        links = await frame.find(tag_name='a', find_all=True)\n        specific_element = await frame.query('#specific-id')\n\nasyncio.run(iframe_interaction())\n</code></pre>"},{"location":"features/#request-interception","title":"Request Interception","text":"<p>Intercept and modify network requests before they're sent:</p>"},{"location":"features/#basic-request-modification","title":"Basic Request Modification","text":"<pre><code>import asyncio\nfrom pydoll.browser.chromium import Chrome\n\nasync def request_interception_example():\n    async with Chrome() as browser:\n        tab = await browser.start()\n\n        # Define the request interceptor\n        async def intercept_request(event):\n            request_id = event['params']['requestId']\n            url = event['params']['request']['url']\n\n            if '/api/' in url:\n                # Get original headers\n                original_headers = event['params']['request'].get('headers', {})\n\n                # Add custom headers\n                custom_headers = {\n                    **original_headers,\n                    'Authorization': 'Bearer my-token-123',\n                    'X-Custom-Header': 'CustomValue'\n                }\n\n                print(f\"\ud83d\udd04 Modifying request to: {url}\")\n                await tab.continue_request(\n                        request_id=request_id,\n                        headers=custom_headers\n                )\n            else:\n                # Continue normally for non-API requests\n                await tab.continue_request(request_id=request_id)\n\n        # Enable interception and register handler\n        await tab.enable_request_interception()\n        await tab.on('Fetch.requestPaused', intercept_request)\n\n        # Navigate to trigger requests\n        await tab.go_to('https://example.com')\n        await asyncio.sleep(5)  # Allow time for requests to process\n\nasyncio.run(request_interception_example())\n</code></pre>"},{"location":"features/#blocking-unwanted-requests","title":"Blocking Unwanted Requests","text":"<p>Use <code>fail_request</code> to block specific requests like ads, trackers, or unwanted resources:</p> <pre><code>import asyncio\nfrom pydoll.browser.chromium import Chrome\n\nasync def block_requests_example():\n    async with Chrome() as browser:\n        tab = await browser.start()\n\n        # Define blocked domains and resource types\n        blocked_domains = ['doubleclick.net', 'googletagmanager.com', 'facebook.com']\n        blocked_resources = ['image', 'stylesheet', 'font']\n\n        async def block_unwanted_requests(event):\n            request_id = event['params']['requestId']\n            url = event['params']['request']['url']\n            resource_type = event['params'].get('resourceType', '').lower()\n\n            # Block requests from specific domains\n            if any(domain in url for domain in blocked_domains):\n                print(f\"\ud83d\udeab Blocking request to: {url}\")\n                await tab.fail_request(\n                    request_id=request_id,\n                    error_reason='BlockedByClient'\n                )\n                return\n\n            # Block specific resource types (images, CSS, fonts)\n            if resource_type in blocked_resources:\n                print(f\"\ud83d\udeab Blocking {resource_type}: {url}\")\n                await tab.fail_request(\n                    request_id=request_id,\n                    error_reason='BlockedByClient'\n                )\n                return\n\n            # Continue with allowed requests\n            await tab.continue_request(request_id=request_id)\n\n        # Enable interception and register handler\n        await tab.enable_request_interception()\n        await tab.on('Fetch.requestPaused', block_unwanted_requests)\n\n        # Navigate to a page with many external resources\n        await tab.go_to('https://example.com')\n        await asyncio.sleep(10)  # Allow time to see blocked requests\n\nasyncio.run(block_requests_example())\n</code></pre>"},{"location":"features/#mocking-api-responses","title":"Mocking API Responses","text":"<p>Use <code>fulfill_request</code> to return custom responses without making actual network requests:</p> <pre><code>import asyncio\nimport json\nfrom pydoll.browser.chromium import Chrome\n\nasync def mock_api_responses_example():\n    async with Chrome() as browser:\n        tab = await browser.start()\n\n        async def mock_api_requests(event):\n            request_id = event['params']['requestId']\n            url = event['params']['request']['url']\n\n            # Mock user API endpoint\n            if '/api/user' in url:\n                mock_user_data = {\n                    \"id\": 123,\n                    \"name\": \"John Doe\",\n                    \"email\": \"john@example.com\",\n                    \"role\": \"admin\"\n                }\n\n                print(f\"\ud83c\udfad Mocking API response for: {url}\")\n                await tab.fulfill_request(\n                    request_id=request_id,\n                    response_code=200,\n                    response_headers={\n                        'Content-Type': 'application/json',\n                        'Access-Control-Allow-Origin': '*'\n                    },\n                    body=json.dumps(mock_user_data)\n                )\n                return\n\n            # Mock products API endpoint\n            elif '/api/products' in url:\n                mock_products = [\n                    {\"id\": 1, \"name\": \"Product A\", \"price\": 29.99},\n                    {\"id\": 2, \"name\": \"Product B\", \"price\": 39.99},\n                    {\"id\": 3, \"name\": \"Product C\", \"price\": 19.99}\n                ]\n\n                print(f\"\ud83c\udfad Mocking products API response for: {url}\")\n                await tab.fulfill_request(\n                    request_id=request_id,\n                    response_code=200,\n                    response_headers={'Content-Type': 'application/json'},\n                    body=json.dumps(mock_products)\n                )\n                return\n\n            # Simulate API error for specific endpoints\n            elif '/api/error' in url:\n                error_response = {\"error\": \"Internal Server Error\", \"code\": 500}\n\n                print(f\"\ud83c\udfad Mocking error response for: {url}\")\n                await tab.fulfill_request(\n                    request_id=request_id,\n                    response_code=500,\n                    response_headers={'Content-Type': 'application/json'},\n                    body=json.dumps(error_response)\n                )\n                return\n\n            # Continue with real requests for everything else\n            await tab.continue_request(request_id=request_id)\n\n        # Enable interception and register handler\n        await tab.enable_request_interception()\n        await tab.on('Fetch.requestPaused', mock_api_requests)\n\n        # Navigate to a page that makes API calls\n        await tab.go_to('https://example.com/dashboard')\n        await asyncio.sleep(5)  # Allow time for API calls\n\nasyncio.run(mock_api_responses_example())\n</code></pre>"},{"location":"features/#advanced-request-manipulation","title":"Advanced Request Manipulation","text":"<p>Combine all interception methods for comprehensive request control:</p> <pre><code>import asyncio\nimport json\nfrom pydoll.browser.chromium import Chrome\n\nasync def advanced_request_control():\n    async with Chrome() as browser:\n        tab = await browser.start()\n\n        async def advanced_interceptor(event):\n            request_id = event['params']['requestId']\n            url = event['params']['request']['url']\n            method = event['params']['request']['method']\n            headers = event['params']['request'].get('headers', {})\n\n            print(f\"\ud83d\udce1 Intercepted {method} request to: {url}\")\n\n            # Block analytics and tracking\n            if any(tracker in url for tracker in ['analytics', 'tracking', 'ads']):\n                print(f\"\ud83d\udeab Blocked tracking request: {url}\")\n                await tab.fail_request(request_id=request_id, error_reason='BlockedByClient')\n                return\n\n            # Mock authentication endpoint\n            if '/auth/login' in url and method == 'POST':\n                mock_auth_response = {\n                    \"success\": True,\n                    \"token\": \"mock-jwt-token-12345\",\n                    \"user\": {\"id\": 1, \"username\": \"testuser\"}\n                }\n                print(f\"\ud83c\udfad Mocking login response\")\n                await tab.fulfill_request(\n                    request_id=request_id,\n                    response_code=200,\n                    response_headers={'Content-Type': 'application/json'},\n                    body=json.dumps(mock_auth_response)\n                )\n                return\n\n            # Add authentication to API requests\n            if '/api/' in url and 'Authorization' not in headers:\n                modified_headers = {\n                    **headers,\n                    'Authorization': 'Bearer mock-token-12345',\n                    'X-Test-Mode': 'true'\n                }\n                print(f\"\ud83d\udd27 Adding auth headers to: {url}\")\n                await tab.continue_request(\n                    request_id=request_id,\n                    headers=modified_headers\n                )\n                return\n\n            # Continue with unmodified request\n            await tab.continue_request(request_id=request_id)\n\n        # Enable interception\n        await tab.enable_request_interception()\n        await tab.on('Fetch.requestPaused', advanced_interceptor)\n\n        # Test the interception\n        await tab.go_to('https://example.com/app')\n        await asyncio.sleep(10)\n\nasyncio.run(advanced_request_control())\n</code></pre> <p>This powerful capability allows you to:</p> <ul> <li>Add authentication headers dynamically for API requests</li> <li>Block unwanted resources like ads, trackers, and heavy images for faster loading</li> <li>Mock API responses for testing without backend dependencies</li> <li>Simulate network errors to test error handling</li> <li>Modify request payloads before they're sent</li> <li>Analyze and debug network traffic in real-time</li> </ul> <p>Each of these features showcases what makes Pydoll a next-generation browser automation tool, combining the power of direct browser control with an intuitive, async-native API. </p>"},{"location":"api/","title":"API Reference","text":"<p>Welcome to the Pydoll API Reference! This section provides comprehensive documentation for all classes, methods, and functions available in the Pydoll library.</p>"},{"location":"api/#overview","title":"Overview","text":"<p>Pydoll is organized into several key modules, each serving a specific purpose in browser automation:</p>"},{"location":"api/#browser-module","title":"Browser Module","text":"<p>The browser module contains classes for managing browser instances and their lifecycle.</p> <ul> <li>Chrome - Chrome browser automation</li> <li>Edge - Microsoft Edge browser automation  </li> <li>Options - Browser configuration options</li> <li>Tab - Tab management and interaction</li> <li>Managers - Browser lifecycle managers</li> </ul>"},{"location":"api/#elements-module","title":"Elements Module","text":"<p>The elements module provides classes for interacting with web page elements.</p> <ul> <li>WebElement - Individual element interaction</li> <li>Mixins - Reusable element functionality</li> </ul>"},{"location":"api/#connection-module","title":"Connection Module","text":"<p>The connection module handles communication with the browser through the Chrome DevTools Protocol.</p> <ul> <li>Connection Handler - WebSocket connection management</li> <li>Managers - Connection lifecycle managers</li> </ul>"},{"location":"api/#commands-module","title":"Commands Module","text":"<p>The commands module provides low-level Chrome DevTools Protocol command implementations.</p> <ul> <li>Commands Overview - CDP command implementations by domain</li> </ul>"},{"location":"api/#protocol-module","title":"Protocol Module","text":"<p>The protocol module implements the Chrome DevTools Protocol commands and events.</p> <ul> <li>Commands - CDP command implementations</li> <li>Events - CDP event handling</li> </ul>"},{"location":"api/#core-module","title":"Core Module","text":"<p>The core module contains fundamental utilities, constants, and exceptions.</p> <ul> <li>Constants - Library constants and enums</li> <li>Exceptions - Custom exception classes</li> <li>Utils - Utility functions</li> </ul>"},{"location":"api/#quick-navigation","title":"Quick Navigation","text":""},{"location":"api/#most-common-classes","title":"Most Common Classes","text":"Class Purpose Module <code>Chrome</code> Chrome browser automation <code>pydoll.browser.chromium</code> <code>Edge</code> Edge browser automation <code>pydoll.browser.chromium</code> <code>Tab</code> Tab interaction and control <code>pydoll.browser.tab</code> <code>WebElement</code> Element interaction <code>pydoll.elements.web_element</code> <code>ChromiumOptions</code> Browser configuration <code>pydoll.browser.options</code>"},{"location":"api/#key-enums-and-constants","title":"Key Enums and Constants","text":"Name Purpose Module <code>By</code> Element selector strategies <code>pydoll.constants</code> <code>Key</code> Keyboard key constants <code>pydoll.constants</code> <code>PermissionType</code> Browser permission types <code>pydoll.constants</code>"},{"location":"api/#common-exceptions","title":"Common Exceptions","text":"Exception When Raised Module <code>ElementNotFound</code> Element not found in DOM <code>pydoll.exceptions</code> <code>WaitElementTimeout</code> Element wait timeout <code>pydoll.exceptions</code> <code>BrowserNotStarted</code> Browser not started <code>pydoll.exceptions</code>"},{"location":"api/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/#basic-browser-automation","title":"Basic Browser Automation","text":"<pre><code>from pydoll.browser.chromium import Chrome\n\nasync with Chrome() as browser:\n    tab = await browser.start()\n    await tab.go_to(\"https://example.com\")\n    element = await tab.find(id=\"my-element\")\n    await element.click()\n</code></pre>"},{"location":"api/#element-finding","title":"Element Finding","text":"<pre><code># Using the modern find() method\nelement = await tab.find(id=\"username\")\nelement = await tab.find(tag_name=\"button\", class_name=\"submit\")\n\n# Using CSS selectors or XPath\nelement = await tab.query(\"#username\")\nelement = await tab.query(\"//button[@class='submit']\")\n</code></pre>"},{"location":"api/#event-handling","title":"Event Handling","text":"<pre><code>await tab.enable_page_events()\nawait tab.on('Page.loadEventFired', handle_page_load)\n</code></pre>"},{"location":"api/#type-hints","title":"Type Hints","text":"<p>Pydoll is fully typed and provides comprehensive type hints for better IDE support and code safety. All public APIs include proper type annotations.</p> <pre><code>from typing import Optional, List\nfrom pydoll.elements.web_element import WebElement\n\n# Methods return properly typed objects\nelement: Optional[WebElement] = await tab.find(id=\"test\", raise_exc=False)\nelements: List[WebElement] = await tab.find(class_name=\"item\", find_all=True)\n</code></pre>"},{"location":"api/#asyncawait-support","title":"Async/Await Support","text":"<p>All Pydoll operations are asynchronous and must be used with <code>async</code>/<code>await</code>:</p> <pre><code>import asyncio\n\nasync def main():\n    # All Pydoll operations are async\n    async with Chrome() as browser:\n        tab = await browser.start()\n        await tab.go_to(\"https://example.com\")\n\nasyncio.run(main())\n</code></pre> <p>Browse the sections below to explore the complete API documentation for each module. </p>"},{"location":"api/browser/chrome/","title":"Chrome Browser","text":""},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome","title":"pydoll.browser.chromium.Chrome","text":"<pre><code>Chrome(options=None, connection_port=None)\n</code></pre> <p>               Bases: <code>Browser</code></p> <p>Chrome browser implementation for CDP automation.</p> <p>Initialize Chrome browser instance.</p> PARAMETER DESCRIPTION <code>options</code> <p>Chrome configuration options (default if None).</p> <p> TYPE: <code>Optional[ChromiumOptions]</code> DEFAULT: <code>None</code> </p> <code>connection_port</code> <p>CDP WebSocket port (random if None).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.options","title":"options  <code>instance-attribute</code>","text":"<pre><code>options = initialize_options()\n</code></pre>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.start","title":"start  <code>async</code>","text":"<pre><code>start(headless=False)\n</code></pre> <p>Start browser process and establish CDP connection.</p> PARAMETER DESCRIPTION <code>headless</code> <p>Run without UI.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Tab</code> <p>Initial tab for interaction.</p> RAISES DESCRIPTION <code>FailedToStartBrowser</code> <p>If the browser fails to start or connect.</p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.stop","title":"stop  <code>async</code>","text":"<pre><code>stop()\n</code></pre> <p>Stop browser process and cleanup resources.</p> <p>Sends Browser.close command, terminates process, removes temp directories, and closes WebSocket connections.</p> RAISES DESCRIPTION <code>BrowserNotRunning</code> <p>If the browser is not currently running.</p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.create_browser_context","title":"create_browser_context  <code>async</code>","text":"<pre><code>create_browser_context(proxy_server=None, proxy_bypass_list=None)\n</code></pre> <p>Create isolated browser context (like incognito).</p> <p>Browser contexts provide isolated storage and don't share session data. Multiple contexts can exist simultaneously.</p> PARAMETER DESCRIPTION <code>proxy_server</code> <p>Optional proxy for this context only (scheme://host:port).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>proxy_bypass_list</code> <p>Comma-separated hosts that bypass proxy.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Browser context ID for use with other methods.</p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.delete_browser_context","title":"delete_browser_context  <code>async</code>","text":"<pre><code>delete_browser_context(browser_context_id)\n</code></pre> <p>Delete browser context and all associated tabs/resources.</p> <p>Removes all storage (cookies, localStorage, etc.) and closes all tabs. The default browser context cannot be deleted.</p> Note <p>Closes all associated tabs immediately.</p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.get_browser_contexts","title":"get_browser_contexts  <code>async</code>","text":"<pre><code>get_browser_contexts()\n</code></pre> <p>Get all browser context IDs including the default context.</p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.new_tab","title":"new_tab  <code>async</code>","text":"<pre><code>new_tab(url='', browser_context_id=None)\n</code></pre> <p>Create new tab for page interaction.</p> PARAMETER DESCRIPTION <code>url</code> <p>Initial URL (about:blank if empty).</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>browser_context_id</code> <p>Context to create tab in (default if None).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tab</code> <p>Tab instance for page navigation and element interaction.</p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.get_targets","title":"get_targets  <code>async</code>","text":"<pre><code>get_targets()\n</code></pre> <p>Get all active targets/pages in browser.</p> <p>Targets include pages, service workers, shared workers, and browser process. Useful for debugging and managing multiple tabs.</p> RETURNS DESCRIPTION <code>list[TargetInfo]</code> <p>List of TargetInfo objects.</p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.get_opened_tabs","title":"get_opened_tabs  <code>async</code>","text":"<pre><code>get_opened_tabs()\n</code></pre> <p>Get all opened tabs that are not extensions and have the type 'page'</p> RETURNS DESCRIPTION <code>list[Tab]</code> <p>List of Tab instances. The last tab is the most recent one.</p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.set_download_path","title":"set_download_path  <code>async</code>","text":"<pre><code>set_download_path(path, browser_context_id=None)\n</code></pre> <p>Set download directory path (convenience method for set_download_behavior).</p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.set_download_behavior","title":"set_download_behavior  <code>async</code>","text":"<pre><code>set_download_behavior(behavior, download_path=None, browser_context_id=None, events_enabled=False)\n</code></pre> <p>Configure download handling.</p> PARAMETER DESCRIPTION <code>behavior</code> <p>ALLOW (save to path), DENY (cancel), or DEFAULT.</p> <p> TYPE: <code>DownloadBehavior</code> </p> <code>download_path</code> <p>Required if behavior is ALLOW.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>browser_context_id</code> <p>Context to apply to (default if None).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>events_enabled</code> <p>Generate download events for progress tracking.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.delete_all_cookies","title":"delete_all_cookies  <code>async</code>","text":"<pre><code>delete_all_cookies(browser_context_id=None)\n</code></pre> <p>Delete all cookies (session, persistent, third-party) from browser or context.</p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.set_cookies","title":"set_cookies  <code>async</code>","text":"<pre><code>set_cookies(cookies, browser_context_id=None)\n</code></pre> <p>Set multiple cookies in browser or context.</p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.get_cookies","title":"get_cookies  <code>async</code>","text":"<pre><code>get_cookies(browser_context_id=None)\n</code></pre> <p>Get all cookies from browser or context.</p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.get_version","title":"get_version  <code>async</code>","text":"<pre><code>get_version()\n</code></pre> <p>Get browser version and CDP protocol information.</p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.get_window_id_for_target","title":"get_window_id_for_target  <code>async</code>","text":"<pre><code>get_window_id_for_target(target_id)\n</code></pre> <p>Get window ID for target (used for window manipulation via CDP).</p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.get_window_id_for_tab","title":"get_window_id_for_tab  <code>async</code>","text":"<pre><code>get_window_id_for_tab(tab)\n</code></pre> <p>Get window ID for tab (convenience method).</p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.get_window_id","title":"get_window_id  <code>async</code>","text":"<pre><code>get_window_id()\n</code></pre> <p>Get window ID for any valid tab.</p> RAISES DESCRIPTION <code>NoValidTabFound</code> <p>If no valid attached tab can be found.</p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.set_window_maximized","title":"set_window_maximized  <code>async</code>","text":"<pre><code>set_window_maximized()\n</code></pre> <p>Maximize browser window (affects all tabs in window).</p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.set_window_minimized","title":"set_window_minimized  <code>async</code>","text":"<pre><code>set_window_minimized()\n</code></pre> <p>Minimize browser window to taskbar/dock.</p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.set_window_bounds","title":"set_window_bounds  <code>async</code>","text":"<pre><code>set_window_bounds(bounds)\n</code></pre> <p>Set window position and/or size.</p> PARAMETER DESCRIPTION <code>bounds</code> <p>Properties to modify (left, top, width, height, windowState). Only specified properties are changed.</p> <p> TYPE: <code>WindowBoundsDict</code> </p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.grant_permissions","title":"grant_permissions  <code>async</code>","text":"<pre><code>grant_permissions(permissions, origin=None, browser_context_id=None)\n</code></pre> <p>Grant browser permissions (geolocation, notifications, camera, etc.).</p> <p>Bypasses normal permission prompts for automated testing.</p> PARAMETER DESCRIPTION <code>permissions</code> <p>Permissions to grant.</p> <p> TYPE: <code>list[PermissionType]</code> </p> <code>origin</code> <p>Origin to grant to (all origins if None).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>browser_context_id</code> <p>Context to apply to (default if None).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.reset_permissions","title":"reset_permissions  <code>async</code>","text":"<pre><code>reset_permissions(browser_context_id=None)\n</code></pre> <p>Reset all permissions to defaults and restore prompting behavior.</p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.on","title":"on  <code>async</code>","text":"<pre><code>on(event_name, callback, temporary=False)\n</code></pre> <p>Register CDP event listener at browser level.</p> <p>Callback runs in background task to prevent blocking. Affects all pages/targets.</p> PARAMETER DESCRIPTION <code>event_name</code> <p>CDP event name (e.g., \"Network.responseReceived\").</p> <p> TYPE: <code>str</code> </p> <code>callback</code> <p>Function called on event (sync or async).</p> <p> TYPE: <code>Callable[[Any], Any]</code> </p> <code>temporary</code> <p>Remove after first invocation.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Callback ID for removal.</p> Note <p>For page-specific events, use Tab.on() instead.</p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.enable_fetch_events","title":"enable_fetch_events  <code>async</code>","text":"<pre><code>enable_fetch_events(handle_auth_requests=False, resource_type=None)\n</code></pre> <p>Enable network request interception via Fetch domain.</p> <p>Allows monitoring, modifying, or blocking requests before they're sent. All matching requests are paused until explicitly continued.</p> PARAMETER DESCRIPTION <code>handle_auth_requests</code> <p>Intercept authentication challenges.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>resource_type</code> <p>Filter by type (XHR, Fetch, Document, etc.). Empty = all.</p> <p> TYPE: <code>Optional[ResourceType]</code> DEFAULT: <code>None</code> </p> Note <p>Paused requests must be continued or they will timeout.</p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.disable_fetch_events","title":"disable_fetch_events  <code>async</code>","text":"<pre><code>disable_fetch_events()\n</code></pre> <p>Disable request interception and release any paused requests.</p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.enable_runtime_events","title":"enable_runtime_events  <code>async</code>","text":"<pre><code>enable_runtime_events()\n</code></pre> <p>Enable runtime events.</p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.disable_runtime_events","title":"disable_runtime_events  <code>async</code>","text":"<pre><code>disable_runtime_events()\n</code></pre> <p>Disable runtime events.</p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.continue_request","title":"continue_request  <code>async</code>","text":"<pre><code>continue_request(request_id)\n</code></pre> <p>Continue paused request without modifications.</p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.fail_request","title":"fail_request  <code>async</code>","text":"<pre><code>fail_request(request_id, error_reason)\n</code></pre> <p>Fail request with error code.</p>"},{"location":"api/browser/chrome/#pydoll.browser.chromium.Chrome.fulfill_request","title":"fulfill_request  <code>async</code>","text":"<pre><code>fulfill_request(request_id, response_code, response_headers, response_body)\n</code></pre> <p>Fulfill request with response data.</p>"},{"location":"api/browser/edge/","title":"Edge Browser","text":""},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge","title":"pydoll.browser.chromium.Edge","text":"<pre><code>Edge(options=None, connection_port=None)\n</code></pre> <p>               Bases: <code>Browser</code></p> <p>Edge browser implementation for CDP automation.</p> <p>Initialize Edge browser instance.</p> PARAMETER DESCRIPTION <code>options</code> <p>Edge configuration options (default if None).</p> <p> TYPE: <code>Optional[Options]</code> DEFAULT: <code>None</code> </p> <code>connection_port</code> <p>CDP WebSocket port (random if None).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.options","title":"options  <code>instance-attribute</code>","text":"<pre><code>options = initialize_options()\n</code></pre>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.start","title":"start  <code>async</code>","text":"<pre><code>start(headless=False)\n</code></pre> <p>Start browser process and establish CDP connection.</p> PARAMETER DESCRIPTION <code>headless</code> <p>Run without UI.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Tab</code> <p>Initial tab for interaction.</p> RAISES DESCRIPTION <code>FailedToStartBrowser</code> <p>If the browser fails to start or connect.</p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.stop","title":"stop  <code>async</code>","text":"<pre><code>stop()\n</code></pre> <p>Stop browser process and cleanup resources.</p> <p>Sends Browser.close command, terminates process, removes temp directories, and closes WebSocket connections.</p> RAISES DESCRIPTION <code>BrowserNotRunning</code> <p>If the browser is not currently running.</p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.create_browser_context","title":"create_browser_context  <code>async</code>","text":"<pre><code>create_browser_context(proxy_server=None, proxy_bypass_list=None)\n</code></pre> <p>Create isolated browser context (like incognito).</p> <p>Browser contexts provide isolated storage and don't share session data. Multiple contexts can exist simultaneously.</p> PARAMETER DESCRIPTION <code>proxy_server</code> <p>Optional proxy for this context only (scheme://host:port).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>proxy_bypass_list</code> <p>Comma-separated hosts that bypass proxy.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Browser context ID for use with other methods.</p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.delete_browser_context","title":"delete_browser_context  <code>async</code>","text":"<pre><code>delete_browser_context(browser_context_id)\n</code></pre> <p>Delete browser context and all associated tabs/resources.</p> <p>Removes all storage (cookies, localStorage, etc.) and closes all tabs. The default browser context cannot be deleted.</p> Note <p>Closes all associated tabs immediately.</p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.get_browser_contexts","title":"get_browser_contexts  <code>async</code>","text":"<pre><code>get_browser_contexts()\n</code></pre> <p>Get all browser context IDs including the default context.</p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.new_tab","title":"new_tab  <code>async</code>","text":"<pre><code>new_tab(url='', browser_context_id=None)\n</code></pre> <p>Create new tab for page interaction.</p> PARAMETER DESCRIPTION <code>url</code> <p>Initial URL (about:blank if empty).</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>browser_context_id</code> <p>Context to create tab in (default if None).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tab</code> <p>Tab instance for page navigation and element interaction.</p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.get_targets","title":"get_targets  <code>async</code>","text":"<pre><code>get_targets()\n</code></pre> <p>Get all active targets/pages in browser.</p> <p>Targets include pages, service workers, shared workers, and browser process. Useful for debugging and managing multiple tabs.</p> RETURNS DESCRIPTION <code>list[TargetInfo]</code> <p>List of TargetInfo objects.</p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.get_opened_tabs","title":"get_opened_tabs  <code>async</code>","text":"<pre><code>get_opened_tabs()\n</code></pre> <p>Get all opened tabs that are not extensions and have the type 'page'</p> RETURNS DESCRIPTION <code>list[Tab]</code> <p>List of Tab instances. The last tab is the most recent one.</p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.set_download_path","title":"set_download_path  <code>async</code>","text":"<pre><code>set_download_path(path, browser_context_id=None)\n</code></pre> <p>Set download directory path (convenience method for set_download_behavior).</p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.set_download_behavior","title":"set_download_behavior  <code>async</code>","text":"<pre><code>set_download_behavior(behavior, download_path=None, browser_context_id=None, events_enabled=False)\n</code></pre> <p>Configure download handling.</p> PARAMETER DESCRIPTION <code>behavior</code> <p>ALLOW (save to path), DENY (cancel), or DEFAULT.</p> <p> TYPE: <code>DownloadBehavior</code> </p> <code>download_path</code> <p>Required if behavior is ALLOW.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>browser_context_id</code> <p>Context to apply to (default if None).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>events_enabled</code> <p>Generate download events for progress tracking.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.delete_all_cookies","title":"delete_all_cookies  <code>async</code>","text":"<pre><code>delete_all_cookies(browser_context_id=None)\n</code></pre> <p>Delete all cookies (session, persistent, third-party) from browser or context.</p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.set_cookies","title":"set_cookies  <code>async</code>","text":"<pre><code>set_cookies(cookies, browser_context_id=None)\n</code></pre> <p>Set multiple cookies in browser or context.</p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.get_cookies","title":"get_cookies  <code>async</code>","text":"<pre><code>get_cookies(browser_context_id=None)\n</code></pre> <p>Get all cookies from browser or context.</p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.get_version","title":"get_version  <code>async</code>","text":"<pre><code>get_version()\n</code></pre> <p>Get browser version and CDP protocol information.</p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.get_window_id_for_target","title":"get_window_id_for_target  <code>async</code>","text":"<pre><code>get_window_id_for_target(target_id)\n</code></pre> <p>Get window ID for target (used for window manipulation via CDP).</p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.get_window_id_for_tab","title":"get_window_id_for_tab  <code>async</code>","text":"<pre><code>get_window_id_for_tab(tab)\n</code></pre> <p>Get window ID for tab (convenience method).</p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.get_window_id","title":"get_window_id  <code>async</code>","text":"<pre><code>get_window_id()\n</code></pre> <p>Get window ID for any valid tab.</p> RAISES DESCRIPTION <code>NoValidTabFound</code> <p>If no valid attached tab can be found.</p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.set_window_maximized","title":"set_window_maximized  <code>async</code>","text":"<pre><code>set_window_maximized()\n</code></pre> <p>Maximize browser window (affects all tabs in window).</p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.set_window_minimized","title":"set_window_minimized  <code>async</code>","text":"<pre><code>set_window_minimized()\n</code></pre> <p>Minimize browser window to taskbar/dock.</p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.set_window_bounds","title":"set_window_bounds  <code>async</code>","text":"<pre><code>set_window_bounds(bounds)\n</code></pre> <p>Set window position and/or size.</p> PARAMETER DESCRIPTION <code>bounds</code> <p>Properties to modify (left, top, width, height, windowState). Only specified properties are changed.</p> <p> TYPE: <code>WindowBoundsDict</code> </p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.grant_permissions","title":"grant_permissions  <code>async</code>","text":"<pre><code>grant_permissions(permissions, origin=None, browser_context_id=None)\n</code></pre> <p>Grant browser permissions (geolocation, notifications, camera, etc.).</p> <p>Bypasses normal permission prompts for automated testing.</p> PARAMETER DESCRIPTION <code>permissions</code> <p>Permissions to grant.</p> <p> TYPE: <code>list[PermissionType]</code> </p> <code>origin</code> <p>Origin to grant to (all origins if None).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>browser_context_id</code> <p>Context to apply to (default if None).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.reset_permissions","title":"reset_permissions  <code>async</code>","text":"<pre><code>reset_permissions(browser_context_id=None)\n</code></pre> <p>Reset all permissions to defaults and restore prompting behavior.</p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.on","title":"on  <code>async</code>","text":"<pre><code>on(event_name, callback, temporary=False)\n</code></pre> <p>Register CDP event listener at browser level.</p> <p>Callback runs in background task to prevent blocking. Affects all pages/targets.</p> PARAMETER DESCRIPTION <code>event_name</code> <p>CDP event name (e.g., \"Network.responseReceived\").</p> <p> TYPE: <code>str</code> </p> <code>callback</code> <p>Function called on event (sync or async).</p> <p> TYPE: <code>Callable[[Any], Any]</code> </p> <code>temporary</code> <p>Remove after first invocation.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Callback ID for removal.</p> Note <p>For page-specific events, use Tab.on() instead.</p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.enable_fetch_events","title":"enable_fetch_events  <code>async</code>","text":"<pre><code>enable_fetch_events(handle_auth_requests=False, resource_type=None)\n</code></pre> <p>Enable network request interception via Fetch domain.</p> <p>Allows monitoring, modifying, or blocking requests before they're sent. All matching requests are paused until explicitly continued.</p> PARAMETER DESCRIPTION <code>handle_auth_requests</code> <p>Intercept authentication challenges.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>resource_type</code> <p>Filter by type (XHR, Fetch, Document, etc.). Empty = all.</p> <p> TYPE: <code>Optional[ResourceType]</code> DEFAULT: <code>None</code> </p> Note <p>Paused requests must be continued or they will timeout.</p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.disable_fetch_events","title":"disable_fetch_events  <code>async</code>","text":"<pre><code>disable_fetch_events()\n</code></pre> <p>Disable request interception and release any paused requests.</p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.enable_runtime_events","title":"enable_runtime_events  <code>async</code>","text":"<pre><code>enable_runtime_events()\n</code></pre> <p>Enable runtime events.</p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.disable_runtime_events","title":"disable_runtime_events  <code>async</code>","text":"<pre><code>disable_runtime_events()\n</code></pre> <p>Disable runtime events.</p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.continue_request","title":"continue_request  <code>async</code>","text":"<pre><code>continue_request(request_id)\n</code></pre> <p>Continue paused request without modifications.</p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.fail_request","title":"fail_request  <code>async</code>","text":"<pre><code>fail_request(request_id, error_reason)\n</code></pre> <p>Fail request with error code.</p>"},{"location":"api/browser/edge/#pydoll.browser.chromium.Edge.fulfill_request","title":"fulfill_request  <code>async</code>","text":"<pre><code>fulfill_request(request_id, response_code, response_headers, response_body)\n</code></pre> <p>Fulfill request with response data.</p>"},{"location":"api/browser/managers/","title":"Browser Managers","text":"<p>The managers module provides specialized classes for managing different aspects of browser lifecycle and configuration.</p>"},{"location":"api/browser/managers/#overview","title":"Overview","text":"<p>Browser managers handle specific responsibilities in browser automation:</p>"},{"location":"api/browser/managers/#pydoll.browser.managers","title":"pydoll.browser.managers","text":""},{"location":"api/browser/managers/#pydoll.browser.managers.ChromiumOptionsManager","title":"ChromiumOptionsManager","text":"<pre><code>ChromiumOptionsManager(options=None)\n</code></pre> <p>               Bases: <code>BrowserOptionsManager</code></p> <p>Manages browser options configuration for Chromium-based browsers.</p> <p>Handles options creation, validation, and applies default CDP arguments for Chrome and Edge browsers.</p>"},{"location":"api/browser/managers/#pydoll.browser.managers.ChromiumOptionsManager.options","title":"options  <code>instance-attribute</code>","text":"<pre><code>options = options\n</code></pre>"},{"location":"api/browser/managers/#pydoll.browser.managers.ChromiumOptionsManager.initialize_options","title":"initialize_options","text":"<pre><code>initialize_options()\n</code></pre> <p>Initialize and validate browser options.</p> <p>Creates ChromiumOptions if none provided, validates existing options, and applies default CDP arguments.</p> RETURNS DESCRIPTION <code>ChromiumOptions</code> <p>Properly configured ChromiumOptions instance.</p> RAISES DESCRIPTION <code>InvalidOptionsObject</code> <p>If provided options is not ChromiumOptions.</p>"},{"location":"api/browser/managers/#pydoll.browser.managers.ChromiumOptionsManager.add_default_arguments","title":"add_default_arguments","text":"<pre><code>add_default_arguments()\n</code></pre> <p>Add default arguments required for CDP integration.</p>"},{"location":"api/browser/managers/#pydoll.browser.managers.BrowserProcessManager","title":"BrowserProcessManager","text":"<pre><code>BrowserProcessManager(process_creator=None)\n</code></pre> <p>Manages browser process lifecycle for CDP automation.</p> <p>Handles process creation, monitoring, and termination with proper resource cleanup and graceful shutdown.</p> <p>Initialize browser process manager.</p> PARAMETER DESCRIPTION <code>process_creator</code> <p>Custom function to create browser processes. Must accept command list and return subprocess.Popen object. Uses default subprocess implementation if None.</p> <p> TYPE: <code>Optional[Callable[[list[str]], Popen]]</code> DEFAULT: <code>None</code> </p>"},{"location":"api/browser/managers/#pydoll.browser.managers.BrowserProcessManager.start_browser_process","title":"start_browser_process","text":"<pre><code>start_browser_process(binary_location, port, arguments)\n</code></pre> <p>Launch browser process with CDP debugging enabled.</p> PARAMETER DESCRIPTION <code>binary_location</code> <p>Path to browser executable.</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>TCP port for CDP WebSocket connections.</p> <p> TYPE: <code>int</code> </p> <code>arguments</code> <p>Additional command-line arguments.</p> <p> TYPE: <code>list[str]</code> </p> RETURNS DESCRIPTION <code>Popen</code> <p>Started browser process instance.</p> Note <p>Automatically adds --remote-debugging-port argument.</p>"},{"location":"api/browser/managers/#pydoll.browser.managers.BrowserProcessManager.stop_process","title":"stop_process","text":"<pre><code>stop_process()\n</code></pre> <p>Terminate browser process with graceful shutdown.</p> <p>Attempts SIGTERM first, then SIGKILL after 15-second timeout. Safe to call even if no process is running.</p>"},{"location":"api/browser/managers/#pydoll.browser.managers.ProxyManager","title":"ProxyManager","text":"<pre><code>ProxyManager(options)\n</code></pre> <p>Manages proxy configuration and credentials for CDP automation.</p> <p>Extracts embedded credentials from proxy URLs, secures authentication information, and sanitizes command-line arguments.</p> <p>Initialize proxy manager with browser options.</p> PARAMETER DESCRIPTION <code>options</code> <p>Browser options potentially containing proxy configuration. Will be modified if credentials are found.</p> <p> TYPE: <code>Options</code> </p>"},{"location":"api/browser/managers/#pydoll.browser.managers.ProxyManager.options","title":"options  <code>instance-attribute</code>","text":"<pre><code>options = options\n</code></pre>"},{"location":"api/browser/managers/#pydoll.browser.managers.ProxyManager.get_proxy_credentials","title":"get_proxy_credentials","text":"<pre><code>get_proxy_credentials()\n</code></pre> <p>Extract and secure proxy authentication credentials.</p> <p>Searches for proxy settings, extracts embedded credentials, and sanitizes options to remove credential exposure.</p> RETURNS DESCRIPTION <code>tuple[bool, tuple[Optional[str], Optional[str]]]</code> <p>Tuple of (has_private_proxy, (username, password)).</p>"},{"location":"api/browser/managers/#pydoll.browser.managers.TempDirectoryManager","title":"TempDirectoryManager","text":"<pre><code>TempDirectoryManager(temp_dir_factory=TemporaryDirectory)\n</code></pre> <p>Manages temporary directory lifecycle for CDP browser automation.</p> <p>Creates isolated temporary directories for browser profiles and handles secure cleanup with retry mechanisms for locked files.</p> <p>Initialize temporary directory manager.</p> PARAMETER DESCRIPTION <code>temp_dir_factory</code> <p>Function to create temporary directories. Must return TemporaryDirectory-compatible object.</p> <p> TYPE: <code>Callable[[], TemporaryDirectory]</code> DEFAULT: <code>TemporaryDirectory</code> </p>"},{"location":"api/browser/managers/#pydoll.browser.managers.TempDirectoryManager.create_temp_dir","title":"create_temp_dir","text":"<pre><code>create_temp_dir()\n</code></pre> <p>Create and track new temporary directory for browser use.</p> RETURNS DESCRIPTION <code>TemporaryDirectory</code> <p>TemporaryDirectory object for browser --user-data-dir argument.</p>"},{"location":"api/browser/managers/#pydoll.browser.managers.TempDirectoryManager.retry_process_file","title":"retry_process_file  <code>staticmethod</code>","text":"<pre><code>retry_process_file(func, path, retry_times=10)\n</code></pre> <p>Execute file operation with retry logic for locked files.</p> PARAMETER DESCRIPTION <code>func</code> <p>Function to execute on path.</p> <p> TYPE: <code>Callable[[str], None]</code> </p> <code>path</code> <p>File or directory path to operate on.</p> <p> TYPE: <code>str</code> </p> <code>retry_times</code> <p>Maximum retry attempts (negative = unlimited).</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> RAISES DESCRIPTION <code>PermissionError</code> <p>If operation fails after all retries.</p>"},{"location":"api/browser/managers/#pydoll.browser.managers.TempDirectoryManager.handle_cleanup_error","title":"handle_cleanup_error","text":"<pre><code>handle_cleanup_error(func, path, exc_info)\n</code></pre> <p>Handle errors during directory cleanup with browser-specific workarounds.</p> PARAMETER DESCRIPTION <code>func</code> <p>Original function that failed.</p> <p> TYPE: <code>Callable[[str], None]</code> </p> <code>path</code> <p>Path that could not be processed.</p> <p> TYPE: <code>str</code> </p> <code>exc_info</code> <p>Exception information tuple.</p> <p> TYPE: <code>tuple</code> </p> Note <p>Handles Chromium-specific locked files like CrashpadMetrics.</p>"},{"location":"api/browser/managers/#pydoll.browser.managers.TempDirectoryManager.cleanup","title":"cleanup","text":"<pre><code>cleanup()\n</code></pre> <p>Remove all tracked temporary directories with error handling.</p> <p>Uses custom error handler for browser-specific file lock issues. Continues cleanup even if some files resist deletion.</p>"},{"location":"api/browser/managers/#manager-classes","title":"Manager Classes","text":""},{"location":"api/browser/managers/#browser-process-manager","title":"Browser Process Manager","text":"<p>Manages the browser process lifecycle, including starting, stopping, and monitoring browser processes.</p>"},{"location":"api/browser/managers/#pydoll.browser.managers.browser_process_manager","title":"pydoll.browser.managers.browser_process_manager","text":""},{"location":"api/browser/managers/#pydoll.browser.managers.browser_process_manager.BrowserProcessManager","title":"BrowserProcessManager","text":"<pre><code>BrowserProcessManager(process_creator=None)\n</code></pre> <p>Manages browser process lifecycle for CDP automation.</p> <p>Handles process creation, monitoring, and termination with proper resource cleanup and graceful shutdown.</p> <p>Initialize browser process manager.</p> PARAMETER DESCRIPTION <code>process_creator</code> <p>Custom function to create browser processes. Must accept command list and return subprocess.Popen object. Uses default subprocess implementation if None.</p> <p> TYPE: <code>Optional[Callable[[list[str]], Popen]]</code> DEFAULT: <code>None</code> </p>"},{"location":"api/browser/managers/#pydoll.browser.managers.browser_process_manager.BrowserProcessManager.start_browser_process","title":"start_browser_process","text":"<pre><code>start_browser_process(binary_location, port, arguments)\n</code></pre> <p>Launch browser process with CDP debugging enabled.</p> PARAMETER DESCRIPTION <code>binary_location</code> <p>Path to browser executable.</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>TCP port for CDP WebSocket connections.</p> <p> TYPE: <code>int</code> </p> <code>arguments</code> <p>Additional command-line arguments.</p> <p> TYPE: <code>list[str]</code> </p> RETURNS DESCRIPTION <code>Popen</code> <p>Started browser process instance.</p> Note <p>Automatically adds --remote-debugging-port argument.</p>"},{"location":"api/browser/managers/#pydoll.browser.managers.browser_process_manager.BrowserProcessManager.stop_process","title":"stop_process","text":"<pre><code>stop_process()\n</code></pre> <p>Terminate browser process with graceful shutdown.</p> <p>Attempts SIGTERM first, then SIGKILL after 15-second timeout. Safe to call even if no process is running.</p>"},{"location":"api/browser/managers/#browser-options-manager","title":"Browser Options Manager","text":"<p>Handles browser configuration options and command-line arguments.</p>"},{"location":"api/browser/managers/#pydoll.browser.managers.browser_options_manager","title":"pydoll.browser.managers.browser_options_manager","text":""},{"location":"api/browser/managers/#pydoll.browser.managers.browser_options_manager.ChromiumOptionsManager","title":"ChromiumOptionsManager","text":"<pre><code>ChromiumOptionsManager(options=None)\n</code></pre> <p>               Bases: <code>BrowserOptionsManager</code></p> <p>Manages browser options configuration for Chromium-based browsers.</p> <p>Handles options creation, validation, and applies default CDP arguments for Chrome and Edge browsers.</p>"},{"location":"api/browser/managers/#pydoll.browser.managers.browser_options_manager.ChromiumOptionsManager.options","title":"options  <code>instance-attribute</code>","text":"<pre><code>options = options\n</code></pre>"},{"location":"api/browser/managers/#pydoll.browser.managers.browser_options_manager.ChromiumOptionsManager.initialize_options","title":"initialize_options","text":"<pre><code>initialize_options()\n</code></pre> <p>Initialize and validate browser options.</p> <p>Creates ChromiumOptions if none provided, validates existing options, and applies default CDP arguments.</p> RETURNS DESCRIPTION <code>ChromiumOptions</code> <p>Properly configured ChromiumOptions instance.</p> RAISES DESCRIPTION <code>InvalidOptionsObject</code> <p>If provided options is not ChromiumOptions.</p>"},{"location":"api/browser/managers/#pydoll.browser.managers.browser_options_manager.ChromiumOptionsManager.add_default_arguments","title":"add_default_arguments","text":"<pre><code>add_default_arguments()\n</code></pre> <p>Add default arguments required for CDP integration.</p>"},{"location":"api/browser/managers/#proxy-manager","title":"Proxy Manager","text":"<p>Manages proxy configuration and authentication for browser instances.</p>"},{"location":"api/browser/managers/#pydoll.browser.managers.proxy_manager","title":"pydoll.browser.managers.proxy_manager","text":""},{"location":"api/browser/managers/#pydoll.browser.managers.proxy_manager.ProxyManager","title":"ProxyManager","text":"<pre><code>ProxyManager(options)\n</code></pre> <p>Manages proxy configuration and credentials for CDP automation.</p> <p>Extracts embedded credentials from proxy URLs, secures authentication information, and sanitizes command-line arguments.</p> <p>Initialize proxy manager with browser options.</p> PARAMETER DESCRIPTION <code>options</code> <p>Browser options potentially containing proxy configuration. Will be modified if credentials are found.</p> <p> TYPE: <code>Options</code> </p>"},{"location":"api/browser/managers/#pydoll.browser.managers.proxy_manager.ProxyManager.options","title":"options  <code>instance-attribute</code>","text":"<pre><code>options = options\n</code></pre>"},{"location":"api/browser/managers/#pydoll.browser.managers.proxy_manager.ProxyManager.get_proxy_credentials","title":"get_proxy_credentials","text":"<pre><code>get_proxy_credentials()\n</code></pre> <p>Extract and secure proxy authentication credentials.</p> <p>Searches for proxy settings, extracts embedded credentials, and sanitizes options to remove credential exposure.</p> RETURNS DESCRIPTION <code>tuple[bool, tuple[Optional[str], Optional[str]]]</code> <p>Tuple of (has_private_proxy, (username, password)).</p>"},{"location":"api/browser/managers/#temporary-directory-manager","title":"Temporary Directory Manager","text":"<p>Handles creation and cleanup of temporary directories used by browser instances.</p>"},{"location":"api/browser/managers/#pydoll.browser.managers.temp_dir_manager","title":"pydoll.browser.managers.temp_dir_manager","text":""},{"location":"api/browser/managers/#pydoll.browser.managers.temp_dir_manager.TempDirectoryManager","title":"TempDirectoryManager","text":"<pre><code>TempDirectoryManager(temp_dir_factory=TemporaryDirectory)\n</code></pre> <p>Manages temporary directory lifecycle for CDP browser automation.</p> <p>Creates isolated temporary directories for browser profiles and handles secure cleanup with retry mechanisms for locked files.</p> <p>Initialize temporary directory manager.</p> PARAMETER DESCRIPTION <code>temp_dir_factory</code> <p>Function to create temporary directories. Must return TemporaryDirectory-compatible object.</p> <p> TYPE: <code>Callable[[], TemporaryDirectory]</code> DEFAULT: <code>TemporaryDirectory</code> </p>"},{"location":"api/browser/managers/#pydoll.browser.managers.temp_dir_manager.TempDirectoryManager.create_temp_dir","title":"create_temp_dir","text":"<pre><code>create_temp_dir()\n</code></pre> <p>Create and track new temporary directory for browser use.</p> RETURNS DESCRIPTION <code>TemporaryDirectory</code> <p>TemporaryDirectory object for browser --user-data-dir argument.</p>"},{"location":"api/browser/managers/#pydoll.browser.managers.temp_dir_manager.TempDirectoryManager.retry_process_file","title":"retry_process_file  <code>staticmethod</code>","text":"<pre><code>retry_process_file(func, path, retry_times=10)\n</code></pre> <p>Execute file operation with retry logic for locked files.</p> PARAMETER DESCRIPTION <code>func</code> <p>Function to execute on path.</p> <p> TYPE: <code>Callable[[str], None]</code> </p> <code>path</code> <p>File or directory path to operate on.</p> <p> TYPE: <code>str</code> </p> <code>retry_times</code> <p>Maximum retry attempts (negative = unlimited).</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> RAISES DESCRIPTION <code>PermissionError</code> <p>If operation fails after all retries.</p>"},{"location":"api/browser/managers/#pydoll.browser.managers.temp_dir_manager.TempDirectoryManager.handle_cleanup_error","title":"handle_cleanup_error","text":"<pre><code>handle_cleanup_error(func, path, exc_info)\n</code></pre> <p>Handle errors during directory cleanup with browser-specific workarounds.</p> PARAMETER DESCRIPTION <code>func</code> <p>Original function that failed.</p> <p> TYPE: <code>Callable[[str], None]</code> </p> <code>path</code> <p>Path that could not be processed.</p> <p> TYPE: <code>str</code> </p> <code>exc_info</code> <p>Exception information tuple.</p> <p> TYPE: <code>tuple</code> </p> Note <p>Handles Chromium-specific locked files like CrashpadMetrics.</p>"},{"location":"api/browser/managers/#pydoll.browser.managers.temp_dir_manager.TempDirectoryManager.cleanup","title":"cleanup","text":"<pre><code>cleanup()\n</code></pre> <p>Remove all tracked temporary directories with error handling.</p> <p>Uses custom error handler for browser-specific file lock issues. Continues cleanup even if some files resist deletion.</p>"},{"location":"api/browser/managers/#usage","title":"Usage","text":"<p>Managers are typically used internally by browser classes like <code>Chrome</code> and <code>Edge</code>. They provide modular functionality that can be composed together:</p> <pre><code>from pydoll.browser.managers.proxy_manager import ProxyManager\nfrom pydoll.browser.managers.temp_dir_manager import TempDirManager\n\n# Managers are used internally by browser classes\n# Direct usage is for advanced scenarios only\nproxy_manager = ProxyManager()\ntemp_manager = TempDirManager()\n</code></pre> <p>Internal Usage</p> <p>These managers are primarily used internally by the browser classes. Direct usage is recommended only for advanced scenarios or when extending the library. </p>"},{"location":"api/browser/options/","title":"Browser Options","text":""},{"location":"api/browser/options/#chromiumoptions","title":"ChromiumOptions","text":""},{"location":"api/browser/options/#pydoll.browser.options.ChromiumOptions","title":"pydoll.browser.options.ChromiumOptions","text":"<pre><code>ChromiumOptions()\n</code></pre> <p>               Bases: <code>Options</code></p> <p>A class to manage command-line options for a browser instance.</p> <p>This class allows the user to specify command-line arguments and the binary location of the browser executable.</p> <p>Initializes the Options instance.</p> <p>Sets up an empty list for command-line arguments and a string for the binary location of the browser.</p>"},{"location":"api/browser/options/#pydoll.browser.options.ChromiumOptions.arguments","title":"arguments  <code>property</code> <code>writable</code>","text":"<pre><code>arguments\n</code></pre> <p>Gets the list of command-line arguments.</p> RETURNS DESCRIPTION <code>list</code> <p>A list of command-line arguments added to the options.</p> <p> TYPE: <code>list[str]</code> </p>"},{"location":"api/browser/options/#pydoll.browser.options.ChromiumOptions.binary_location","title":"binary_location  <code>property</code> <code>writable</code>","text":"<pre><code>binary_location\n</code></pre> <p>Gets the location of the browser binary.</p> RETURNS DESCRIPTION <code>str</code> <p>The file path to the browser executable.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/browser/options/#pydoll.browser.options.ChromiumOptions.add_argument","title":"add_argument","text":"<pre><code>add_argument(argument)\n</code></pre> <p>Adds a command-line argument to the options.</p> PARAMETER DESCRIPTION <code>argument</code> <p>The command-line argument to be added.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>ArgumentAlreadyExistsInOptions</code> <p>If the argument is already in the list of arguments.</p>"},{"location":"api/browser/options/#options-interface","title":"Options Interface","text":""},{"location":"api/browser/options/#pydoll.browser.interfaces.Options","title":"pydoll.browser.interfaces.Options","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"api/browser/options/#pydoll.browser.interfaces.Options.arguments","title":"arguments  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>arguments\n</code></pre>"},{"location":"api/browser/options/#pydoll.browser.interfaces.Options.binary_location","title":"binary_location  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>binary_location\n</code></pre>"},{"location":"api/browser/options/#pydoll.browser.interfaces.Options.add_argument","title":"add_argument  <code>abstractmethod</code>","text":"<pre><code>add_argument(argument)\n</code></pre>"},{"location":"api/browser/options/#browseroptionsmanager-interface","title":"BrowserOptionsManager Interface","text":""},{"location":"api/browser/options/#pydoll.browser.interfaces.BrowserOptionsManager","title":"pydoll.browser.interfaces.BrowserOptionsManager","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"api/browser/options/#pydoll.browser.interfaces.BrowserOptionsManager.initialize_options","title":"initialize_options  <code>abstractmethod</code>","text":"<pre><code>initialize_options()\n</code></pre>"},{"location":"api/browser/options/#pydoll.browser.interfaces.BrowserOptionsManager.add_default_arguments","title":"add_default_arguments  <code>abstractmethod</code>","text":"<pre><code>add_default_arguments()\n</code></pre>"},{"location":"api/browser/tab/","title":"Tab","text":""},{"location":"api/browser/tab/#pydoll.browser.tab.Tab","title":"pydoll.browser.tab.Tab","text":"<pre><code>Tab(browser, connection_port, target_id, browser_context_id=None)\n</code></pre> <p>               Bases: <code>FindElementsMixin</code></p> <p>Controls a browser tab via Chrome DevTools Protocol.</p> <p>Primary interface for web page automation including navigation, DOM manipulation, JavaScript execution, event handling, network monitoring, and specialized tasks like Cloudflare bypass.</p> <p>This class implements a singleton pattern based on target_id to ensure only one Tab instance exists per browser tab.</p> <p>Initialize tab controller for existing browser tab.</p> PARAMETER DESCRIPTION <code>browser</code> <p>Browser instance that created this tab.</p> <p> TYPE: <code>Browser</code> </p> <code>connection_port</code> <p>CDP WebSocket port.</p> <p> TYPE: <code>int</code> </p> <code>target_id</code> <p>CDP target identifier for this tab.</p> <p> TYPE: <code>str</code> </p> <code>browser_context_id</code> <p>Optional browser context ID.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.page_events_enabled","title":"page_events_enabled  <code>property</code>","text":"<pre><code>page_events_enabled\n</code></pre> <p>Whether CDP Page domain events are enabled.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.network_events_enabled","title":"network_events_enabled  <code>property</code>","text":"<pre><code>network_events_enabled\n</code></pre> <p>Whether CDP Network domain events are enabled.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.fetch_events_enabled","title":"fetch_events_enabled  <code>property</code>","text":"<pre><code>fetch_events_enabled\n</code></pre> <p>Whether CDP Fetch domain events (request interception) are enabled.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.dom_events_enabled","title":"dom_events_enabled  <code>property</code>","text":"<pre><code>dom_events_enabled\n</code></pre> <p>Whether CDP DOM domain events are enabled.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.runtime_events_enabled","title":"runtime_events_enabled  <code>property</code>","text":"<pre><code>runtime_events_enabled\n</code></pre> <p>Whether CDP Runtime domain events are enabled.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.intercept_file_chooser_dialog_enabled","title":"intercept_file_chooser_dialog_enabled  <code>property</code>","text":"<pre><code>intercept_file_chooser_dialog_enabled\n</code></pre> <p>Whether file chooser dialog interception is active.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.current_url","title":"current_url  <code>async</code> <code>property</code>","text":"<pre><code>current_url\n</code></pre> <p>Get current page URL (reflects redirects and client-side navigation).</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.page_source","title":"page_source  <code>async</code> <code>property</code>","text":"<pre><code>page_source\n</code></pre> <p>Get complete HTML source of current page (live DOM state).</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.get_instance","title":"get_instance  <code>classmethod</code>","text":"<pre><code>get_instance(target_id)\n</code></pre> <p>Get existing Tab instance for target_id if it exists.</p> PARAMETER DESCRIPTION <code>target_id</code> <p>Target ID to look up.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Optional[Tab]</code> <p>Existing Tab instance or None if not found.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.get_all_instances","title":"get_all_instances  <code>classmethod</code>","text":"<pre><code>get_all_instances()\n</code></pre> <p>Get all active Tab instances.</p> RETURNS DESCRIPTION <code>dict[str, Tab]</code> <p>Dictionary mapping target_id to Tab instances.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.enable_page_events","title":"enable_page_events  <code>async</code>","text":"<pre><code>enable_page_events()\n</code></pre> <p>Enable CDP Page domain events (load, navigation, dialogs, etc.).</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.enable_network_events","title":"enable_network_events  <code>async</code>","text":"<pre><code>enable_network_events()\n</code></pre> <p>Enable CDP Network domain events (requests, responses, etc.).</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.enable_fetch_events","title":"enable_fetch_events  <code>async</code>","text":"<pre><code>enable_fetch_events(handle_auth=False, resource_type=None, request_stage=None)\n</code></pre> <p>Enable CDP Fetch domain for request interception.</p> PARAMETER DESCRIPTION <code>handle_auth</code> <p>Intercept authentication challenges.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>resource_type</code> <p>Filter by resource type (all if None).</p> <p> TYPE: <code>Optional[ResourceType]</code> DEFAULT: <code>None</code> </p> <code>request_stage</code> <p>When to intercept (Request/Response).</p> <p> TYPE: <code>Optional[RequestStage]</code> DEFAULT: <code>None</code> </p> Note <p>Intercepted requests must be explicitly continued or timeout.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.enable_dom_events","title":"enable_dom_events  <code>async</code>","text":"<pre><code>enable_dom_events()\n</code></pre> <p>Enable CDP DOM domain events (document structure changes).</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.enable_runtime_events","title":"enable_runtime_events  <code>async</code>","text":"<pre><code>enable_runtime_events()\n</code></pre> <p>Enable CDP Runtime domain events.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.enable_intercept_file_chooser_dialog","title":"enable_intercept_file_chooser_dialog  <code>async</code>","text":"<pre><code>enable_intercept_file_chooser_dialog()\n</code></pre> <p>Enable file chooser dialog interception for automated uploads.</p> Note <p>Use expect_file_chooser context manager for convenience.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.enable_auto_solve_cloudflare_captcha","title":"enable_auto_solve_cloudflare_captcha  <code>async</code>","text":"<pre><code>enable_auto_solve_cloudflare_captcha(custom_selector=None, time_before_click=2, time_to_wait_captcha=5)\n</code></pre> <p>Enable automatic Cloudflare Turnstile captcha bypass.</p> PARAMETER DESCRIPTION <code>custom_selector</code> <p>Custom captcha selector (default: cf-turnstile class).</p> <p> TYPE: <code>Optional[tuple[By, str]]</code> DEFAULT: <code>None</code> </p> <code>time_before_click</code> <p>Delay before clicking captcha (default 2s).</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>time_to_wait_captcha</code> <p>Timeout for captcha detection (default 5s).</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.disable_fetch_events","title":"disable_fetch_events  <code>async</code>","text":"<pre><code>disable_fetch_events()\n</code></pre> <p>Disable CDP Fetch domain and release paused requests.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.disable_page_events","title":"disable_page_events  <code>async</code>","text":"<pre><code>disable_page_events()\n</code></pre> <p>Disable CDP Page domain events.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.disable_network_events","title":"disable_network_events  <code>async</code>","text":"<pre><code>disable_network_events()\n</code></pre> <p>Disable CDP Network domain events.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.disable_dom_events","title":"disable_dom_events  <code>async</code>","text":"<pre><code>disable_dom_events()\n</code></pre> <p>Disable CDP DOM domain events.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.disable_runtime_events","title":"disable_runtime_events  <code>async</code>","text":"<pre><code>disable_runtime_events()\n</code></pre> <p>Disable CDP Runtime domain events.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.disable_intercept_file_chooser_dialog","title":"disable_intercept_file_chooser_dialog  <code>async</code>","text":"<pre><code>disable_intercept_file_chooser_dialog()\n</code></pre> <p>Disable file chooser dialog interception.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.disable_auto_solve_cloudflare_captcha","title":"disable_auto_solve_cloudflare_captcha  <code>async</code>","text":"<pre><code>disable_auto_solve_cloudflare_captcha()\n</code></pre> <p>Disable automatic Cloudflare Turnstile captcha bypass.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close this browser tab.</p> Note <p>Tab instance becomes invalid after calling this method.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.get_frame","title":"get_frame  <code>async</code>","text":"<pre><code>get_frame(frame)\n</code></pre> <p>Get Tab object for interacting with iframe content.</p> PARAMETER DESCRIPTION <code>frame</code> <p>Tab representing the iframe tag.</p> <p> TYPE: <code>WebElement</code> </p> RETURNS DESCRIPTION <code>IFrame</code> <p>Tab instance configured for iframe interaction.</p> RAISES DESCRIPTION <code>NotAnIFrame</code> <p>If element is not an iframe.</p> <code>InvalidIFrame</code> <p>If iframe lacks valid src attribute.</p> <code>IFrameNotFound</code> <p>If iframe target not found in browser.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.get_cookies","title":"get_cookies  <code>async</code>","text":"<pre><code>get_cookies()\n</code></pre> <p>Get all cookies accessible from current page.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.get_network_response_body","title":"get_network_response_body  <code>async</code>","text":"<pre><code>get_network_response_body(request_id)\n</code></pre> <p>Get the response body for a given request ID.</p> PARAMETER DESCRIPTION <code>request_id</code> <p>Request ID to get the response body for.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The response body for the given request ID.</p> RAISES DESCRIPTION <code>NetworkEventsNotEnabled</code> <p>If network events are not enabled.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.get_network_logs","title":"get_network_logs  <code>async</code>","text":"<pre><code>get_network_logs(filter=None)\n</code></pre> <p>Get network logs.</p> PARAMETER DESCRIPTION <code>filter</code> <p>Filter to apply to the network logs.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[NetworkLog]</code> <p>The network logs.</p> RAISES DESCRIPTION <code>NetworkEventsNotEnabled</code> <p>If network events are not enabled.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.set_cookies","title":"set_cookies  <code>async</code>","text":"<pre><code>set_cookies(cookies)\n</code></pre> <p>Set multiple cookies for current page.</p> PARAMETER DESCRIPTION <code>cookies</code> <p>Cookie parameters (name/value required, others optional).</p> <p> TYPE: <code>list[CookieParam]</code> </p> Note <p>Defaults to current page's domain if not specified.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.delete_all_cookies","title":"delete_all_cookies  <code>async</code>","text":"<pre><code>delete_all_cookies()\n</code></pre> <p>Delete all cookies from current browser context.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.go_to","title":"go_to  <code>async</code>","text":"<pre><code>go_to(url, timeout=300)\n</code></pre> <p>Navigate to URL and wait for loading to complete.</p> <p>Refreshes if URL matches current page.</p> PARAMETER DESCRIPTION <code>url</code> <p>Target URL to navigate to.</p> <p> TYPE: <code>str</code> </p> <code>timeout</code> <p>Maximum seconds to wait for page load (default 300).</p> <p> TYPE: <code>int</code> DEFAULT: <code>300</code> </p> RAISES DESCRIPTION <code>PageLoadTimeout</code> <p>If page doesn't finish loading within timeout.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.refresh","title":"refresh  <code>async</code>","text":"<pre><code>refresh(ignore_cache=False, script_to_evaluate_on_load=None)\n</code></pre> <p>Reload current page and wait for completion.</p> PARAMETER DESCRIPTION <code>ignore_cache</code> <p>Bypass browser cache if True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>script_to_evaluate_on_load</code> <p>JavaScript to execute after load.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>PageLoadTimeout</code> <p>If page doesn't finish loading within timeout.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.take_screenshot","title":"take_screenshot  <code>async</code>","text":"<pre><code>take_screenshot(path=None, quality=100, as_base64=False)\n</code></pre> <p>Capture screenshot of current page.</p> PARAMETER DESCRIPTION <code>path</code> <p>File path for screenshot (extension determines format).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>quality</code> <p>Image quality 0-100 (default 100).</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>as_base64</code> <p>Return as base64 string instead of saving file.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Base64 screenshot data if as_base64=True, None otherwise.</p> RAISES DESCRIPTION <code>InvalidFileExtension</code> <p>If file extension not supported.</p> <code>ValueError</code> <p>If path is None and as_base64 is False.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.print_to_pdf","title":"print_to_pdf  <code>async</code>","text":"<pre><code>print_to_pdf(path, landscape=False, display_header_footer=False, print_background=True, scale=1.0, as_base64=False)\n</code></pre> <p>Generate PDF of current page.</p> PARAMETER DESCRIPTION <code>path</code> <p>File path for PDF output.</p> <p> TYPE: <code>str</code> </p> <code>landscape</code> <p>Use landscape orientation.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>display_header_footer</code> <p>Include header/footer.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>print_background</code> <p>Include background graphics.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>scale</code> <p>Scale factor (0.1-2.0).</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <code>as_base64</code> <p>Return as base64 string instead of saving.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Base64 PDF data if as_base64=True, None otherwise.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.has_dialog","title":"has_dialog  <code>async</code>","text":"<pre><code>has_dialog()\n</code></pre> <p>Check if JavaScript dialog is currently displayed.</p> Note <p>Page events must be enabled to detect dialogs.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.get_dialog_message","title":"get_dialog_message  <code>async</code>","text":"<pre><code>get_dialog_message()\n</code></pre> <p>Get message text from current JavaScript dialog.</p> RAISES DESCRIPTION <code>NoDialogPresent</code> <p>If no dialog is currently displayed.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.handle_dialog","title":"handle_dialog  <code>async</code>","text":"<pre><code>handle_dialog(accept, prompt_text=None)\n</code></pre> <p>Respond to JavaScript dialog.</p> PARAMETER DESCRIPTION <code>accept</code> <p>Accept/confirm dialog if True, dismiss/cancel if False.</p> <p> TYPE: <code>bool</code> </p> <code>prompt_text</code> <p>Text for prompt dialogs (ignored for alert/confirm).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>NoDialogPresent</code> <p>If no dialog is currently displayed.</p> Note <p>Page events must be enabled to handle dialogs.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.execute_script","title":"execute_script  <code>async</code>","text":"<pre><code>execute_script(script: str) -&gt; EvaluateResponse\n</code></pre><pre><code>execute_script(script: str, element: WebElement) -&gt; CallFunctionOnResponse\n</code></pre> <pre><code>execute_script(script, element=None)\n</code></pre> <p>Execute JavaScript in page context.</p> PARAMETER DESCRIPTION <code>script</code> <p>JavaScript code to execute.</p> <p> TYPE: <code>str</code> </p> <code>element</code> <p>Element context (use 'argument' in script to reference).</p> <p> TYPE: <code>Optional[WebElement]</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <p>await page.execute_script('argument.click()', element) await page.execute_script('argument.value = \"Hello\"', element)</p> RAISES DESCRIPTION <code>InvalidScriptWithElement</code> <p>If script contains 'argument' but no element is provided.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.expect_file_chooser","title":"expect_file_chooser  <code>async</code>","text":"<pre><code>expect_file_chooser(files)\n</code></pre> <p>Context manager for automatic file upload handling.</p> PARAMETER DESCRIPTION <code>files</code> <p>File path(s) for upload.</p> <p> TYPE: <code>Union[str, Path, list[Union[str, Path]]]</code> </p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.expect_and_bypass_cloudflare_captcha","title":"expect_and_bypass_cloudflare_captcha  <code>async</code>","text":"<pre><code>expect_and_bypass_cloudflare_captcha(custom_selector=None, time_before_click=2, time_to_wait_captcha=5)\n</code></pre> <p>Context manager for automatic Cloudflare captcha bypass.</p> PARAMETER DESCRIPTION <code>custom_selector</code> <p>Custom captcha selector (default: cf-turnstile class).</p> <p> TYPE: <code>Optional[tuple[By, str]]</code> DEFAULT: <code>None</code> </p> <code>time_before_click</code> <p>Delay before clicking (default 2s).</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>time_to_wait_captcha</code> <p>Timeout for captcha detection (default 5s).</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.on","title":"on  <code>async</code>","text":"<pre><code>on(event_name, callback, temporary=False)\n</code></pre> <p>Register CDP event listener.</p> <p>Callback runs in background task to prevent blocking.</p> PARAMETER DESCRIPTION <code>event_name</code> <p>CDP event name (e.g., 'Page.loadEventFired').</p> <p> TYPE: <code>str</code> </p> <code>callback</code> <p>Function called on event (sync or async).</p> <p> TYPE: <code>Callable[[dict], Any]</code> </p> <code>temporary</code> <p>Remove after first invocation.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Callback ID for removal.</p> Note <p>Corresponding domain must be enabled before events fire.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.find","title":"find  <code>async</code>","text":"<pre><code>find(id=None, class_name=None, name=None, tag_name=None, text=None, timeout=0, find_all=False, raise_exc=True, **attributes)\n</code></pre> <p>Find element(s) using combination of common HTML attributes.</p> <p>Flexible element location using standard attributes. Multiple attributes can be combined for specific selectors (builds XPath when multiple specified).</p> PARAMETER DESCRIPTION <code>id</code> <p>Element ID attribute value.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>class_name</code> <p>CSS class name to match.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>name</code> <p>Element name attribute value.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>tag_name</code> <p>HTML tag name (e.g., \"div\", \"input\").</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>text</code> <p>Text content to match within element.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>Maximum seconds to wait for elements to appear.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>find_all</code> <p>If True, returns all matches; if False, first match only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>raise_exc</code> <p>Whether to raise exception if no elements found.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>**attributes</code> <p>Additional HTML attributes to match.</p> <p> TYPE: <code>dict[str, str]</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Union[WebElement, list[WebElement], None]</code> <p>WebElement, list[WebElement], or None based on find_all and raise_exc.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If no search criteria provided.</p> <code>ElementNotFound</code> <p>If no elements found and raise_exc=True.</p> <code>WaitElementTimeout</code> <p>If timeout specified and no elements appear in time.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.query","title":"query  <code>async</code>","text":"<pre><code>query(expression, timeout=0, find_all=False, raise_exc=True)\n</code></pre> <p>Find element(s) using raw CSS selector or XPath expression.</p> <p>Direct access using CSS or XPath syntax. Selector type automatically determined based on expression pattern.</p> PARAMETER DESCRIPTION <code>expression</code> <p>Selector expression (CSS, XPath, ID with #, class with .).</p> <p> TYPE: <code>str</code> </p> <code>timeout</code> <p>Maximum seconds to wait for elements to appear.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>find_all</code> <p>If True, returns all matches; if False, first match only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>raise_exc</code> <p>Whether to raise exception if no elements found.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Union[WebElement, list[WebElement], None]</code> <p>WebElement, list[WebElement], or None based on find_all and raise_exc.</p> RAISES DESCRIPTION <code>ElementNotFound</code> <p>If no elements found and raise_exc=True.</p> <code>WaitElementTimeout</code> <p>If timeout specified and no elements appear in time.</p>"},{"location":"api/browser/tab/#pydoll.browser.tab.Tab.find_or_wait_element","title":"find_or_wait_element  <code>async</code>","text":"<pre><code>find_or_wait_element(by, value, timeout=0, find_all=False, raise_exc=True)\n</code></pre> <p>Core element finding method with optional waiting capability.</p> <p>Searches for elements with flexible waiting. If timeout specified, repeatedly attempts to find elements with 0.5s delays until success or timeout. Used by higher-level find() and query() methods.</p> PARAMETER DESCRIPTION <code>by</code> <p>Selector strategy (CSS_SELECTOR, XPATH, ID, etc.).</p> <p> TYPE: <code>By</code> </p> <code>value</code> <p>Selector value to locate element(s).</p> <p> TYPE: <code>str</code> </p> <code>timeout</code> <p>Maximum seconds to wait (0 = no waiting).</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>find_all</code> <p>If True, returns all matches; if False, first match only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>raise_exc</code> <p>Whether to raise exception if no elements found.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Union[WebElement, list[WebElement], None]</code> <p>WebElement, list[WebElement], or None based on find_all and raise_exc.</p> RAISES DESCRIPTION <code>ElementNotFound</code> <p>If no elements found with timeout=0 and raise_exc=True.</p> <code>WaitElementTimeout</code> <p>If elements not found within timeout and raise_exc=True.</p>"},{"location":"api/commands/browser/","title":"Browser Commands","text":"<p>Browser commands provide low-level control over browser instances and their configuration.</p>"},{"location":"api/commands/browser/#overview","title":"Overview","text":"<p>The browser commands module handles browser-level operations such as version information, target management, and browser-wide settings.</p>"},{"location":"api/commands/browser/#pydoll.commands.browser_commands","title":"pydoll.commands.browser_commands","text":""},{"location":"api/commands/browser/#pydoll.commands.browser_commands.BrowserCommands","title":"BrowserCommands","text":"<p>BrowserCommands class provides a set of commands to interact with the browser's main functionality based on CDP. These commands allow for managing browser windows, such as closing windows, retrieving window IDs, and adjusting window bounds (size and state).</p> <p>The commands defined in this class provide functionality for: - Managing browser windows and targets. - Setting permissions and download behavior. - Controlling browser windows (size, state). - Retrieving browser information and versioning.</p>"},{"location":"api/commands/browser/#pydoll.commands.browser_commands.BrowserCommands.get_version","title":"get_version  <code>staticmethod</code>","text":"<pre><code>get_version()\n</code></pre> <p>Generates a command to get browser version information.</p> RETURNS DESCRIPTION <code>Command[GetVersionResponse]</code> <p>Command[GetVersionResponse]: The CDP command that returns browser version details including protocol version, product name, revision, and user agent.</p>"},{"location":"api/commands/browser/#pydoll.commands.browser_commands.BrowserCommands.reset_permissions","title":"reset_permissions  <code>staticmethod</code>","text":"<pre><code>reset_permissions(browser_context_id=None)\n</code></pre> <p>Generates a command to reset all permissions.</p> PARAMETER DESCRIPTION <code>browser_context_id</code> <p>The browser context to reset permissions for. If not specified, resets permissions for the default context.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: The CDP command that returns a basic success response.</p>"},{"location":"api/commands/browser/#pydoll.commands.browser_commands.BrowserCommands.cancel_download","title":"cancel_download  <code>staticmethod</code>","text":"<pre><code>cancel_download(guid, browser_context_id=None)\n</code></pre> <p>Generates a command to cancel a download.</p> PARAMETER DESCRIPTION <code>guid</code> <p>Global unique identifier of the download.</p> <p> TYPE: <code>str</code> </p> <code>browser_context_id</code> <p>The browser context the download belongs to. If not specified, uses the default context.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: The CDP command that returns a basic success response.</p>"},{"location":"api/commands/browser/#pydoll.commands.browser_commands.BrowserCommands.crash","title":"crash  <code>staticmethod</code>","text":"<pre><code>crash()\n</code></pre> <p>Generates a command to crash the browser main process.</p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: The CDP command that returns a basic success response before crashing the browser.</p>"},{"location":"api/commands/browser/#pydoll.commands.browser_commands.BrowserCommands.crash_gpu_process","title":"crash_gpu_process  <code>staticmethod</code>","text":"<pre><code>crash_gpu_process()\n</code></pre> <p>Generates a command to crash the browser GPU process.</p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: The CDP command that returns a basic success response before crashing the GPU process.</p>"},{"location":"api/commands/browser/#pydoll.commands.browser_commands.BrowserCommands.set_download_behavior","title":"set_download_behavior  <code>staticmethod</code>","text":"<pre><code>set_download_behavior(behavior, download_path=None, browser_context_id=None, events_enabled=True)\n</code></pre> <p>Generates a command to set the download behavior for the browser.</p> PARAMETER DESCRIPTION <code>behavior</code> <p>The behavior to set for downloads.</p> <p> TYPE: <code>DownloadBehavior</code> </p> <code>download_path</code> <p>The path to set for downloads.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: The CDP command that returns a basic success response after setting the download path.</p>"},{"location":"api/commands/browser/#pydoll.commands.browser_commands.BrowserCommands.close","title":"close  <code>staticmethod</code>","text":"<pre><code>close()\n</code></pre> <p>Generates a command to close the browser.</p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: The CDP command that returns a basic success response before closing the browser.</p>"},{"location":"api/commands/browser/#pydoll.commands.browser_commands.BrowserCommands.get_window_for_target","title":"get_window_for_target  <code>staticmethod</code>","text":"<pre><code>get_window_for_target(target_id)\n</code></pre> <p>Generates a command to get the window for a given target ID.</p> PARAMETER DESCRIPTION <code>target_id</code> <p>The target_id to get the window for.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command[GetWindowForTargetResponse]</code> <p>Command[GetWindowForTargetResponse]: The CDP command that returns window information including windowId and bounds.</p>"},{"location":"api/commands/browser/#pydoll.commands.browser_commands.BrowserCommands.set_window_bounds","title":"set_window_bounds  <code>staticmethod</code>","text":"<pre><code>set_window_bounds(window_id, bounds)\n</code></pre> <p>Generates a command to set the bounds of a window.</p> PARAMETER DESCRIPTION <code>window_id</code> <p>The ID of the window to set the bounds for.</p> <p> TYPE: <code>int</code> </p> <code>bounds</code> <p>The bounds to set for the window, which should include windowState and optionally width, height, x, and y coordinates.</p> <p> TYPE: <code>WindowBoundsDict</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: The CDP command that returns a basic success response after setting the window bounds.</p>"},{"location":"api/commands/browser/#pydoll.commands.browser_commands.BrowserCommands.set_window_maximized","title":"set_window_maximized  <code>staticmethod</code>","text":"<pre><code>set_window_maximized(window_id)\n</code></pre> <p>Generates a command to maximize a window.</p> PARAMETER DESCRIPTION <code>window_id</code> <p>The ID of the window to maximize.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: The CDP command that returns a basic success response after maximizing the window.</p>"},{"location":"api/commands/browser/#pydoll.commands.browser_commands.BrowserCommands.set_window_minimized","title":"set_window_minimized  <code>staticmethod</code>","text":"<pre><code>set_window_minimized(window_id)\n</code></pre> <p>Generates a command to minimize a window.</p> PARAMETER DESCRIPTION <code>window_id</code> <p>The ID of the window to minimize.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: The CDP command that returns a basic success response after minimizing the window.</p>"},{"location":"api/commands/browser/#pydoll.commands.browser_commands.BrowserCommands.grant_permissions","title":"grant_permissions  <code>staticmethod</code>","text":"<pre><code>grant_permissions(permissions, origin=None, browser_context_id=None)\n</code></pre> <p>Generates a command to grant specific permissions to the given origin.</p> PARAMETER DESCRIPTION <code>permissions</code> <p>list of permissions to grant. See PermissionType enum for available permissions.</p> <p> TYPE: <code>list[PermissionType]</code> </p> <code>origin</code> <p>The origin to grant permissions to. If not specified, grants for all origins.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>browser_context_id</code> <p>The browser context to grant permissions in. If not specified, uses the default context.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: The CDP command that returns a basic success response after granting the specified permissions.</p>"},{"location":"api/commands/browser/#usage","title":"Usage","text":"<p>Browser commands are typically used internally by browser classes to manage browser instances:</p> <pre><code>from pydoll.commands.browser_commands import get_version\nfrom pydoll.connection.connection_handler import ConnectionHandler\n\n# Get browser version information\nconnection = ConnectionHandler()\nversion_info = await get_version(connection)\n</code></pre>"},{"location":"api/commands/browser/#available-commands","title":"Available Commands","text":"<p>The browser commands module provides functions for:</p> <ul> <li>Getting browser version and user agent information</li> <li>Managing browser targets (tabs, windows)</li> <li>Controlling browser-wide settings and permissions</li> <li>Handling browser lifecycle events</li> </ul> <p>Internal Usage</p> <p>These commands are primarily used internally by the <code>Chrome</code> and <code>Edge</code> browser classes. Direct usage is recommended only for advanced scenarios. </p>"},{"location":"api/commands/dom/","title":"DOM Commands","text":"<p>DOM commands provide comprehensive functionality for interacting with the Document Object Model of web pages.</p>"},{"location":"api/commands/dom/#overview","title":"Overview","text":"<p>The DOM commands module is one of the most important modules in Pydoll, providing all the functionality needed to find, interact with, and manipulate HTML elements on web pages.</p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands","title":"pydoll.commands.dom_commands","text":""},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands","title":"DomCommands","text":"<p>Implementation of Chrome DevTools Protocol for the DOM domain.</p> <p>This class provides commands for interacting with the Document Object Model (DOM) in the browser, enabling access and manipulation of the element structure in a web page. The DOM domain in Chrome DevTools Protocol exposes operations for reading and writing to the DOM, which is fundamental for browser automation, testing, and debugging.</p> <p>Each DOM element is represented by a mirror object with a unique ID. This ID can be used to gather additional information about the node, resolve it into JavaScript object wrappers, manipulate attributes, and perform various other operations on the DOM structure.</p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.describe_node","title":"describe_node  <code>staticmethod</code>","text":"<pre><code>describe_node(node_id=None, backend_node_id=None, object_id=None, depth=None, pierce=None)\n</code></pre> <p>Describes a DOM node identified by its ID without requiring domain to be enabled.</p> <p>The describe_node command is particularly useful in scenarios where you need to quickly gather information about a specific element without subscribing to DOM change events, making it more lightweight for isolated element inspection operations.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Identifier of the node known to the client.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>backend_node_id</code> <p>Identifier of the backend node used internally by the browser.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>object_id</code> <p>JavaScript object id of the node wrapper.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>depth</code> <p>Maximum depth at which children should be retrieved (default is 1).   Use -1 for the entire subtree or provide an integer greater than 0.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>pierce</code> <p>Whether iframes and shadow roots should be traversed when returning    the subtree (default is false).</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns detailed information about the requested node.</p> <p> TYPE: <code>Command[DescribeNodeResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.disable","title":"disable  <code>staticmethod</code>","text":"<pre><code>disable()\n</code></pre> <p>Disables DOM agent for the current page.</p> <p>Disabling the DOM domain stops the CDP from sending DOM-related events and prevents further DOM manipulation operations until the domain is enabled again. This can be important for optimizing performance when you're done with DOM operations and want to minimize background processing.</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to disable the DOM domain.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.enable","title":"enable  <code>staticmethod</code>","text":"<pre><code>enable(include_whitespace=None)\n</code></pre> <p>Enables DOM agent for the current page.</p> <p>Enabling the DOM domain is a prerequisite for receiving DOM events and using most DOM manipulation methods. The DOM events include changes to the DOM tree structure, attribute modifications, and many others. Without enabling this domain first, many DOM operations would fail or provide incomplete information.</p> PARAMETER DESCRIPTION <code>include_whitespace</code> <p>Whether to include whitespace-only text nodes in the                children array of returned Nodes. Allowed values: \"none\", \"all\".</p> <p> TYPE: <code>Optional[IncludeWhitespace]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to enable the DOM domain.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.focus","title":"focus  <code>staticmethod</code>","text":"<pre><code>focus(node_id=None, backend_node_id=None, object_id=None)\n</code></pre> <p>Focuses the given element.</p> <p>The focus command is crucial for simulating realistic user interactions, as many events (like keyboard input) require that an element has focus first. It's also important for testing proper tab order and keyboard accessibility of web pages.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Identifier of the node to focus.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>backend_node_id</code> <p>Identifier of the backend node to focus.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>object_id</code> <p>JavaScript object id of the node wrapper.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to focus on the specified element.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.get_attributes","title":"get_attributes  <code>staticmethod</code>","text":"<pre><code>get_attributes(node_id)\n</code></pre> <p>Returns attributes for the specified node.</p> <p>Attribute information is essential in web testing and automation because attributes often contain crucial information about element state, behavior, and metadata. This command provides an efficient way to access all attributes of an element without parsing HTML or using JavaScript evaluation.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to retrieve attributes for.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns an interleaved array of node attribute     names and values [name1, value1, name2, value2, ...].</p> <p> TYPE: <code>Command[GetAttributesResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.get_box_model","title":"get_box_model  <code>staticmethod</code>","text":"<pre><code>get_box_model(node_id=None, backend_node_id=None, object_id=None)\n</code></pre> <p>Returns box model information for the specified node.</p> <p>The box model is a fundamental concept in CSS that describes how elements are rendered with content, padding, borders, and margins. This command provides detailed information about these dimensions and coordinates, which is invaluable for spatial analysis and precision interactions with elements on the page.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Identifier of the node.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>backend_node_id</code> <p>Identifier of the backend node.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>object_id</code> <p>JavaScript object id of the node wrapper.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the box model for the node, including     coordinates for content, padding, border, and margin boxes.</p> <p> TYPE: <code>Command[GetBoxModelResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.get_document","title":"get_document  <code>staticmethod</code>","text":"<pre><code>get_document(depth=None, pierce=None)\n</code></pre> <p>Returns the root DOM node (and optionally the subtree) to the caller.</p> <p>This is typically the first command called when interacting with the DOM, as it provides access to the document's root node. From this root, you can traverse to any other element on the page. This command implicitly enables DOM domain events for the current target, making it a good starting point for DOM interaction.</p> PARAMETER DESCRIPTION <code>depth</code> <p>Maximum depth at which children should be retrieved (default is 1).   Use -1 for the entire subtree or provide an integer greater than 0.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>pierce</code> <p>Whether iframes and shadow roots should be traversed when returning   the subtree (default is false).</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the root DOM node.</p> <p> TYPE: <code>Command[GetDocumentResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.get_node_for_location","title":"get_node_for_location  <code>staticmethod</code>","text":"<pre><code>get_node_for_location(x, y, include_user_agent_shadow_dom=None, ignore_pointer_events_none=None)\n</code></pre> <p>Returns node id at given location on the page.</p> <p>This command is particularly useful for bridging the gap between visual/pixel-based information and the DOM structure. It allows you to convert screen coordinates to actual DOM elements, which is essential for creating inspection tools or for testing spatially-oriented interactions.</p> PARAMETER DESCRIPTION <code>x</code> <p>X coordinate relative to the main frame's viewport.</p> <p> TYPE: <code>int</code> </p> <code>y</code> <p>Y coordinate relative to the main frame's viewport.</p> <p> TYPE: <code>int</code> </p> <code>include_user_agent_shadow_dom</code> <p>Whether to include nodes in user agent shadow roots.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>ignore_pointer_events_none</code> <p>Whether to ignore pointer-events:none and test elements                        underneath them.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the node at the given location, including    frame information when available.</p> <p> TYPE: <code>Command[GetNodeForLocationResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.get_outer_html","title":"get_outer_html  <code>staticmethod</code>","text":"<pre><code>get_outer_html(node_id=None, backend_node_id=None, object_id=None)\n</code></pre> <p>Returns node's HTML markup, including the node itself and all its children.</p> <p>This command provides a way to access the complete HTML representation of an element, making it valuable for when you need to extract, analyze, or verify HTML content. It's more comprehensive than just getting text content as it preserves the full markup structure including tags, attributes, and child elements.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Identifier of the node.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>backend_node_id</code> <p>Identifier of the backend node.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>object_id</code> <p>JavaScript object id of the node wrapper.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the outer HTML markup of the node.</p> <p> TYPE: <code>Command[GetOuterHTMLResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.hide_highlight","title":"hide_highlight  <code>staticmethod</code>","text":"<pre><code>hide_highlight()\n</code></pre> <p>Hides any DOM element highlight.</p> <p>This command is particularly useful in automation workflows where multiple elements are highlighted in sequence, and you need to clear previous highlights before proceeding to the next element to avoid visual clutter or interference.</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to hide DOM element highlights.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.highlight_node","title":"highlight_node  <code>staticmethod</code>","text":"<pre><code>highlight_node()\n</code></pre> <p>Highlights DOM node.</p> <p>Highlighting nodes is especially valuable during development and debugging sessions to visually confirm which elements are being selected by selectors or coordinates.</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to highlight a DOM node.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.highlight_rect","title":"highlight_rect  <code>staticmethod</code>","text":"<pre><code>highlight_rect()\n</code></pre> <p>Highlights given rectangle.</p> <p>Unlike node highlighting, rectangle highlighting allows highlighting arbitrary regions of the page, which is useful for highlighting computed areas or regions that don't correspond directly to DOM elements.</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to highlight a rectangular area.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.move_to","title":"move_to  <code>staticmethod</code>","text":"<pre><code>move_to(node_id, target_node_id, insert_before_node_id=None)\n</code></pre> <p>Moves node into the new container, placing it before the given anchor.</p> <p>This command allows for more complex DOM restructuring than simple attribute or content changes. It's particularly useful when testing applications that involve rearranging elements, such as sortable lists, kanban boards, or drag-and-drop interfaces.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to move.</p> <p> TYPE: <code>int</code> </p> <code>target_node_id</code> <p>Id of the element to drop the moved node into.</p> <p> TYPE: <code>int</code> </p> <code>insert_before_node_id</code> <p>Drop node before this one (if absent, the moved node                  becomes the last child of target_node_id).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to move a node, returning the new id of the moved node.</p> <p> TYPE: <code>Command[MoveToResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.query_selector","title":"query_selector  <code>staticmethod</code>","text":"<pre><code>query_selector(node_id, selector)\n</code></pre> <p>Executes querySelector on a given node.</p> <p>This method is one of the most fundamental tools for element location, allowing the use of standard CSS selectors to find elements in the DOM. Unlike JavaScript's querySelector, this can be executed on any node (not just document), enabling scoped searches within specific sections of the page.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to query upon.</p> <p> TYPE: <code>int</code> </p> <code>selector</code> <p>CSS selector string.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the first element matching the selector.</p> <p> TYPE: <code>Command[QuerySelectorResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.query_selector_all","title":"query_selector_all  <code>staticmethod</code>","text":"<pre><code>query_selector_all(node_id, selector)\n</code></pre> <p>Executes querySelectorAll on a given node.</p> <p>This method extends querySelector by returning all matching elements rather than just the first one. This is essential for operations that need to process multiple elements, such as extracting data from tables, lists, or grids, or verifying that the correct number of elements are present.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to query upon.</p> <p> TYPE: <code>int</code> </p> <code>selector</code> <p>CSS selector string.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns all elements matching the selector.</p> <p> TYPE: <code>Command[QuerySelectorAllResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.remove_attribute","title":"remove_attribute  <code>staticmethod</code>","text":"<pre><code>remove_attribute(node_id, name)\n</code></pre> <p>Removes attribute with given name from an element with given id.</p> <p>This command allows direct manipulation of element attributes without using JavaScript in the page context. It's useful for testing how elements behave when specific attributes are removed or for preparing elements for specific test conditions.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the element to remove attribute from.</p> <p> TYPE: <code>int</code> </p> <code>name</code> <p>Name of the attribute to remove.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to remove the specified attribute.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.remove_node","title":"remove_node  <code>staticmethod</code>","text":"<pre><code>remove_node(node_id)\n</code></pre> <p>Removes node with given id.</p> <p>This command allows direct removal of DOM elements, which can be useful when testing how an application responds to missing elements or when simplifying a page for focused testing scenarios.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to remove.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to remove the specified node.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.request_child_nodes","title":"request_child_nodes  <code>staticmethod</code>","text":"<pre><code>request_child_nodes(node_id, depth=None, pierce=None)\n</code></pre> <p>Requests that children of the node with given id are returned to the caller.</p> <p>This method is particularly useful when dealing with large DOM trees, as it allows for more efficient exploration by loading children on demand rather than loading the entire tree at once. Child nodes are returned as setChildNodes events.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to get children for.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>The maximum depth at which children should be retrieved,   defaults to 1. Use -1 for the entire subtree.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>pierce</code> <p>Whether or not iframes and shadow roots should be traversed.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to request child nodes.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.request_node","title":"request_node  <code>staticmethod</code>","text":"<pre><code>request_node(object_id)\n</code></pre> <p>Requests that the node is sent to the caller given the JavaScript node object reference.</p> <p>This method bridges the gap between JavaScript objects in the page context and the CDP's node representation system, allowing automation to work with elements that might only be available as JavaScript references (e.g., from event handlers).</p> PARAMETER DESCRIPTION <code>object_id</code> <p>JavaScript object id to convert into a Node.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the Node id for the given object.</p> <p> TYPE: <code>Command[RequestNodeResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.resolve_node","title":"resolve_node  <code>staticmethod</code>","text":"<pre><code>resolve_node(node_id=None, backend_node_id=None, object_group=None, execution_context_id=None)\n</code></pre> <p>Resolves the JavaScript node object for a given NodeId or BackendNodeId.</p> <p>This method provides the opposite functionality of requestNode - instead of getting a CDP node from a JavaScript object, it gets a JavaScript object from a CDP node. This enables executing JavaScript operations on nodes identified through CDP.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to resolve.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>backend_node_id</code> <p>Backend id of the node to resolve.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>object_group</code> <p>Symbolic group name that can be used to release multiple objects.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>execution_context_id</code> <p>Execution context in which to resolve the node.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns a JavaScript object wrapper for the node.</p> <p> TYPE: <code>Command[ResolveNodeResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.scroll_into_view_if_needed","title":"scroll_into_view_if_needed  <code>staticmethod</code>","text":"<pre><code>scroll_into_view_if_needed(node_id=None, backend_node_id=None, object_id=None, rect=None)\n</code></pre> <p>Scrolls the specified node into view if not already visible.</p> <p>This command is crucial for reliable web automation, as it ensures elements are actually visible in the viewport before attempting interactions. Modern websites often use lazy loading and have long scrollable areas, making this command essential for working with elements that may not be initially visible.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Identifier of the node.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>backend_node_id</code> <p>Identifier of the backend node.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>object_id</code> <p>JavaScript object id of the node wrapper.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>rect</code> <p>Optional rect to scroll into view, relative to the node bounds.</p> <p> TYPE: <code>Optional[Rect]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to scroll the element into view.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.set_attributes_as_text","title":"set_attributes_as_text  <code>staticmethod</code>","text":"<pre><code>set_attributes_as_text(node_id, text, name=None)\n</code></pre> <p>Sets attribute for an element with given id, using text representation.</p> <p>This command allows for more complex attribute manipulation than set_attribute_value, as it accepts a text representation that can potentially define multiple attributes or include special formatting. It's particularly useful when trying to replicate exactly how attributes would be defined in HTML source code.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the element to set attribute for.</p> <p> TYPE: <code>int</code> </p> <code>text</code> <p>Text with a new attribute value.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Attribute name to replace with new text value.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to set an attribute as text.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.set_attribute_value","title":"set_attribute_value  <code>staticmethod</code>","text":"<pre><code>set_attribute_value(node_id, name, value)\n</code></pre> <p>Sets attribute for element with given id.</p> <p>This command provides direct control over element attributes without using JavaScript, which is essential for testing how applications respond to attribute changes or for setting up specific test conditions by controlling element attributes directly.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the element to set attribute for.</p> <p> TYPE: <code>int</code> </p> <code>name</code> <p>Attribute name.</p> <p> TYPE: <code>str</code> </p> <code>value</code> <p>Attribute value.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to set an attribute value.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.set_file_input_files","title":"set_file_input_files  <code>staticmethod</code>","text":"<pre><code>set_file_input_files(files, node_id=None, backend_node_id=None, object_id=None)\n</code></pre> <p>Sets files for the given file input element.</p> <p>This command solves one of the most challenging automation problems: working with file inputs. It bypasses the OS-level file dialog that normally appears when clicking a file input, allowing automated tests to provide files programmatically.</p> PARAMETER DESCRIPTION <code>files</code> <p>list of file paths to set.</p> <p> TYPE: <code>list[str]</code> </p> <code>node_id</code> <p>Identifier of the node.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>backend_node_id</code> <p>Identifier of the backend node.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>object_id</code> <p>JavaScript object id of the node wrapper.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to set files for a file input element.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.set_node_name","title":"set_node_name  <code>staticmethod</code>","text":"<pre><code>set_node_name(node_id, name)\n</code></pre> <p>Sets node name for a node with given id.</p> <p>This command allows changing the actual tag name of an element, which can be useful for testing how applications handle different types of elements or for testing the impact of semantic HTML choices on accessibility and behavior.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to set name for.</p> <p> TYPE: <code>int</code> </p> <code>name</code> <p>New node name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the new node id after the name change.</p> <p> TYPE: <code>Command[SetNodeNameResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.set_node_value","title":"set_node_value  <code>staticmethod</code>","text":"<pre><code>set_node_value(node_id, value)\n</code></pre> <p>Sets node value for a node with given id.</p> <p>This command is particularly useful for updating the content of text nodes and comments, allowing direct manipulation of text content without changing the surrounding HTML structure.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to set value for.</p> <p> TYPE: <code>int</code> </p> <code>value</code> <p>New node value.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to set a node's value.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.set_outer_html","title":"set_outer_html  <code>staticmethod</code>","text":"<pre><code>set_outer_html(node_id, outer_html)\n</code></pre> <p>Sets node HTML markup, replacing existing one.</p> <p>This is one of the most powerful DOM manipulation commands, as it allows completely replacing an element and all its children with new HTML. This is useful for making major structural changes to the page or for testing how applications handle dynamically inserted content.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to set outer HTML for.</p> <p> TYPE: <code>int</code> </p> <code>outer_html</code> <p>HTML markup to set.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to set the outer HTML of a node.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.collect_class_names_from_subtree","title":"collect_class_names_from_subtree  <code>staticmethod</code>","text":"<pre><code>collect_class_names_from_subtree(node_id)\n</code></pre> <p>Collects class names for the node with given id and all of its children.</p> <p>This method is valuable for understanding the styling landscape of a page, especially in complex applications where multiple CSS frameworks might be in use or where classes are dynamically applied.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to collect class names for.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns a list of all unique class names in the subtree.</p> <p> TYPE: <code>Command[CollectClassNamesFromSubtreeResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.copy_to","title":"copy_to  <code>staticmethod</code>","text":"<pre><code>copy_to(node_id, target_node_id, insert_before_node_id=None)\n</code></pre> <p>Creates a deep copy of the specified node and places it into the target container.</p> <p>Unlike move_to, this command creates a copy of the node, leaving the original intact. This is useful when you want to duplicate content rather than move it, such as when testing how multiple instances of the same component behave.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to copy.</p> <p> TYPE: <code>int</code> </p> <code>target_node_id</code> <p>Id of the element to drop the copy into.</p> <p> TYPE: <code>int</code> </p> <code>insert_before_node_id</code> <p>Drop the copy before this node (if absent, the copy becomes                  the last child of target_node_id).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the id of the new copy.</p> <p> TYPE: <code>Command[CopyToResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.discard_search_results","title":"discard_search_results  <code>staticmethod</code>","text":"<pre><code>discard_search_results(search_id)\n</code></pre> <p>Discards search results from the session with the given id.</p> <p>This method helps manage resources when performing multiple searches during a session, allowing explicit cleanup of search results that are no longer needed.</p> PARAMETER DESCRIPTION <code>search_id</code> <p>Unique search session identifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to discard search results.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.get_anchor_element","title":"get_anchor_element  <code>staticmethod</code>","text":"<pre><code>get_anchor_element(node_id, anchor_specifier=None)\n</code></pre> <p>Finds the closest ancestor node that is an anchor element for the given node.</p> <p>This method is useful when working with content inside links or when you need to find the enclosing link element for text or other elements. This helps in cases where you might locate text but need to find the actual link around it.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to search for an anchor around.</p> <p> TYPE: <code>int</code> </p> <code>anchor_specifier</code> <p>Optional specifier for anchor tag properties.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the anchor element node information.</p> <p> TYPE: <code>Command[GetAnchorElementResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.get_container_for_node","title":"get_container_for_node  <code>staticmethod</code>","text":"<pre><code>get_container_for_node(node_id, container_name=None, physical_axes=None, logical_axes=None, queries_scroll_state=None)\n</code></pre> <p>Finds a containing element for the given node based on specified parameters.</p> <p>This method helps in understanding the structural and layout context of elements, particularly in complex layouts using CSS features like flexbox, grid, or when dealing with scrollable containers.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to find the container for.</p> <p> TYPE: <code>int</code> </p> <code>container_name</code> <p>Name of the container to look for (e.g., 'scrollable', 'flex').</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>physical_axes</code> <p>Physical axes to consider (Horizontal, Vertical, Both).</p> <p> TYPE: <code>Optional[PhysicalAxes]</code> DEFAULT: <code>None</code> </p> <code>logical_axes</code> <p>Logical axes to consider (Inline, Block, Both).</p> <p> TYPE: <code>Optional[LogicalAxes]</code> DEFAULT: <code>None</code> </p> <code>queries_scroll_state</code> <p>Whether to query scroll state or not.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns information about the containing element.</p> <p> TYPE: <code>Command[GetContainerForNodeResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.get_content_quads","title":"get_content_quads  <code>staticmethod</code>","text":"<pre><code>get_content_quads(node_id=None, backend_node_id=None, object_id=None)\n</code></pre> <p>Returns quads that describe node position on the page.</p> <p>This method provides detailed geometric information about an element's position on the page, accounting for any transformations, rotations, or other CSS effects. This is more precise than getBoxModel for complex layouts.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Identifier of the node.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>backend_node_id</code> <p>Identifier of the backend node.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>object_id</code> <p>JavaScript object id of the node wrapper.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the quads describing the node position.</p> <p> TYPE: <code>Command[GetContentQuadsResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.get_detached_dom_nodes","title":"get_detached_dom_nodes  <code>staticmethod</code>","text":"<pre><code>get_detached_dom_nodes()\n</code></pre> <p>Returns information about detached DOM tree elements.</p> <p>This method is primarily useful for debugging memory issues related to the DOM, as detached DOM nodes (nodes no longer in the document but still referenced in JavaScript) are a common cause of memory leaks in web applications.</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns information about detached DOM nodes.</p> <p> TYPE: <code>Command[GetDetachedDomNodesResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.get_element_by_relation","title":"get_element_by_relation  <code>staticmethod</code>","text":"<pre><code>get_element_by_relation(node_id, relation)\n</code></pre> <p>Retrieves an element related to the given one in a specified way.</p> <p>This method provides a way to find elements based on their relationships to other elements, such as finding the next focusable element after a given one. This is useful for simulating keyboard navigation or for analyzing element relationships.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the reference node.</p> <p> TYPE: <code>int</code> </p> <code>relation</code> <p>Type of relationship (e.g., nextSibling, previousSibling, firstChild).</p> <p> TYPE: <code>ElementRelation</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the related element node.</p> <p> TYPE: <code>Command[GetElementByRelationResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.get_file_info","title":"get_file_info  <code>staticmethod</code>","text":"<pre><code>get_file_info(object_id)\n</code></pre> <p>Returns file information for the given File object.</p> <p>This method is useful when working with file inputs and the File API, providing access to file metadata like name, size, and MIME type for files selected in file input elements or created programmatically.</p> PARAMETER DESCRIPTION <code>object_id</code> <p>JavaScript object id of the File object to get info for.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns file information.</p> <p> TYPE: <code>Command[GetFileInfoResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.get_frame_owner","title":"get_frame_owner  <code>staticmethod</code>","text":"<pre><code>get_frame_owner(frame_id)\n</code></pre> <p>Returns iframe element that owns the given frame.</p> <p>This method is essential when working with pages that contain iframes, as it allows mapping between frame IDs (used in CDP) and the actual iframe elements in the parent document.</p> PARAMETER DESCRIPTION <code>frame_id</code> <p>Id of the frame to get the owner element for.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the frame owner element.</p> <p> TYPE: <code>Command[GetFrameOwnerResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.get_nodes_for_subtree_by_style","title":"get_nodes_for_subtree_by_style  <code>staticmethod</code>","text":"<pre><code>get_nodes_for_subtree_by_style(node_id, computed_styles, pierce=None)\n</code></pre> <p>Finds nodes with a given computed style in a subtree.</p> <p>This method allows finding elements based on their computed styles rather than just structure or attributes. This is powerful for testing visual aspects of a page or for finding elements that match specific visual criteria.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Node to start the search from.</p> <p> TYPE: <code>int</code> </p> <code>computed_styles</code> <p>list of computed style properties to match against.</p> <p> TYPE: <code>list[CSSComputedStyleProperty]</code> </p> <code>pierce</code> <p>Whether or not iframes and shadow roots should be traversed.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns nodes matching the specified styles.</p> <p> TYPE: <code>Command[GetNodesForSubtreeByStyleResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.get_node_stack_traces","title":"get_node_stack_traces  <code>staticmethod</code>","text":"<pre><code>get_node_stack_traces(node_id)\n</code></pre> <p>Gets stack traces associated with a specific node.</p> <p>This method is powerful for debugging, as it reveals the JavaScript execution paths that led to the creation of specific DOM elements, helping developers understand the relationship between their code and the resulting DOM structure.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to get stack traces for.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns stack traces related to the node.</p> <p> TYPE: <code>Command[GetNodeStackTracesResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.get_querying_descendants_for_container","title":"get_querying_descendants_for_container  <code>staticmethod</code>","text":"<pre><code>get_querying_descendants_for_container(node_id)\n</code></pre> <p>Returns the querying descendants for container.</p> <p>This method is particularly useful for working with CSS Container Queries, helping to identify which descendant elements are affected by or querying a particular container element.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the container node to find querying descendants for.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns querying descendant information.</p> <p> TYPE: <code>Command[GetQueryingDescendantForContainerResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.get_relayout_boundary","title":"get_relayout_boundary  <code>staticmethod</code>","text":"<pre><code>get_relayout_boundary(node_id)\n</code></pre> <p>Returns the root of the relayout boundary for the given node.</p> <p>This method helps in understanding layout performance by identifying the boundary of layout recalculations when a particular element changes. This is valuable for optimizing rendering performance.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to find relayout boundary for.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the relayout boundary node.</p> <p> TYPE: <code>Command[GetRelayoutBoundaryResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.get_search_results","title":"get_search_results  <code>staticmethod</code>","text":"<pre><code>get_search_results(search_id, from_index, to_index)\n</code></pre> <p>Returns search results from given <code>fromIndex</code> to given <code>toIndex</code> from a search.</p> <p>This method is used in conjunction with performSearch to retrieve search results in batches, which is essential when dealing with large result sets that might be inefficient to transfer all at once.</p> PARAMETER DESCRIPTION <code>search_id</code> <p>Unique search session identifier from performSearch.</p> <p> TYPE: <code>str</code> </p> <code>from_index</code> <p>Start index to retrieve results from.</p> <p> TYPE: <code>int</code> </p> <code>to_index</code> <p>End index to retrieve results to (exclusive).</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the requested search results.</p> <p> TYPE: <code>Command[GetSearchResultsResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.get_top_layer_elements","title":"get_top_layer_elements  <code>staticmethod</code>","text":"<pre><code>get_top_layer_elements()\n</code></pre> <p>Returns all top layer elements in the document.</p> <p>This method is valuable for working with modern web UIs that make extensive use of overlays, modals, dropdowns, and other elements that need to appear above the normal document flow.</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the top layer element information.</p> <p> TYPE: <code>Command[GetTopLayerElementsResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.mark_undoable_state","title":"mark_undoable_state  <code>staticmethod</code>","text":"<pre><code>mark_undoable_state()\n</code></pre> <p>Marks last undoable state.</p> <p>This method helps in managing DOM manipulation state, allowing the creation of savepoints that can be reverted to with the undo command. This is useful for complex sequences of DOM operations that should be treated as a unit.</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to mark the current state as undoable.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.perform_search","title":"perform_search  <code>staticmethod</code>","text":"<pre><code>perform_search(query, include_user_agent_shadow_dom=None)\n</code></pre> <p>Searches for a given string in the DOM tree.</p> <p>This method initiates a search across the DOM tree, supporting plain text, CSS selectors, or XPath expressions. It's a powerful way to find elements or content across the entire document without knowing the exact structure.</p> PARAMETER DESCRIPTION <code>query</code> <p>Plain text or query selector or XPath search query.</p> <p> TYPE: <code>str</code> </p> <code>include_user_agent_shadow_dom</code> <p>True to include user agent shadow DOM in the search.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns search results identifier and count.</p> <p> TYPE: <code>Command[PerformSearchResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.push_node_by_path_to_frontend","title":"push_node_by_path_to_frontend  <code>staticmethod</code>","text":"<pre><code>push_node_by_path_to_frontend(path)\n</code></pre> <p>Requests that the node is sent to the caller given its path.</p> <p>This method provides an alternative way to reference nodes when node IDs aren't available, using path expressions instead. This can be useful when integrating with systems that identify elements by path rather than by ID.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to node in the proprietary format.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the node id for the node.</p> <p> TYPE: <code>Command[PushNodeByPathToFrontendResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.push_nodes_by_backend_ids_to_frontend","title":"push_nodes_by_backend_ids_to_frontend  <code>staticmethod</code>","text":"<pre><code>push_nodes_by_backend_ids_to_frontend(backend_node_ids)\n</code></pre> <p>Requests that a batch of nodes is sent to the caller given their backend node ids.</p> <p>This method allows for efficient batch processing when you have multiple backend node IDs and need to convert them to frontend node IDs for further operations.</p> PARAMETER DESCRIPTION <code>backend_node_ids</code> <p>The array of backend node ids.</p> <p> TYPE: <code>list[int]</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns an array of node ids.</p> <p> TYPE: <code>Command[PushNodesByBackendIdsToFrontendResponse]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.redo","title":"redo  <code>staticmethod</code>","text":"<pre><code>redo()\n</code></pre> <p>Re-does the last undone action.</p> <p>This method works in conjunction with undo and markUndoableState to provide a transactional approach to DOM manipulations, allowing for stepping back and forth through a sequence of changes.</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to redo the last undone action.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.set_inspected_node","title":"set_inspected_node  <code>staticmethod</code>","text":"<pre><code>set_inspected_node(node_id)\n</code></pre> <p>Enables console to refer to the node with given id via $x command line API.</p> <p>This method creates a bridge between automated testing/scripting and manual console interaction, making it easy to reference specific nodes in the console for debugging or experimentation.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>DOM node id to be accessible by means of $x command line API.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to set the inspected node.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.set_node_stack_traces_enabled","title":"set_node_stack_traces_enabled  <code>staticmethod</code>","text":"<pre><code>set_node_stack_traces_enabled(enable)\n</code></pre> <p>Sets if stack traces should be captured for Nodes.</p> <p>This method enables or disables the collection of stack traces when DOM nodes are created, which can be extremely valuable for debugging complex applications to understand where and why specific DOM elements are being created.</p> PARAMETER DESCRIPTION <code>enable</code> <p>Enable or disable stack trace collection.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to enable or disable node stack traces.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/dom/#pydoll.commands.dom_commands.DomCommands.undo","title":"undo  <code>staticmethod</code>","text":"<pre><code>undo()\n</code></pre> <p>Undoes the last performed action.</p> <p>This method works in conjunction with redo and markUndoableState to provide transactional control over DOM manipulations, allowing for reverting changes when needed.</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to undo the last performed action.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/dom/#usage","title":"Usage","text":"<p>DOM commands are used extensively by the <code>WebElement</code> class and element finding methods:</p> <pre><code>from pydoll.commands.dom_commands import query_selector, get_attributes\nfrom pydoll.connection.connection_handler import ConnectionHandler\n\n# Find element and get its attributes\nconnection = ConnectionHandler()\nnode_id = await query_selector(connection, selector=\"#username\")\nattributes = await get_attributes(connection, node_id=node_id)\n</code></pre>"},{"location":"api/commands/dom/#key-functionality","title":"Key Functionality","text":"<p>The DOM commands module provides functions for:</p>"},{"location":"api/commands/dom/#element-finding","title":"Element Finding","text":"<ul> <li><code>query_selector()</code> - Find single element by CSS selector</li> <li><code>query_selector_all()</code> - Find multiple elements by CSS selector</li> <li><code>get_document()</code> - Get the document root node</li> </ul>"},{"location":"api/commands/dom/#element-interaction","title":"Element Interaction","text":"<ul> <li><code>click_element()</code> - Click on elements</li> <li><code>focus_element()</code> - Focus elements</li> <li><code>set_attribute_value()</code> - Set element attributes</li> <li><code>get_attributes()</code> - Get element attributes</li> </ul>"},{"location":"api/commands/dom/#element-information","title":"Element Information","text":"<ul> <li><code>get_box_model()</code> - Get element positioning and dimensions</li> <li><code>describe_node()</code> - Get detailed element information</li> <li><code>get_outer_html()</code> - Get element HTML content</li> </ul>"},{"location":"api/commands/dom/#dom-manipulation","title":"DOM Manipulation","text":"<ul> <li><code>remove_node()</code> - Remove elements from DOM</li> <li><code>set_node_value()</code> - Set element values</li> <li><code>request_child_nodes()</code> - Get child elements</li> </ul> <p>High-Level APIs</p> <p>While these commands provide powerful low-level access, most users should use the higher-level <code>WebElement</code> class methods like <code>click()</code>, <code>type_text()</code>, and <code>get_attribute()</code> which use these commands internally. </p>"},{"location":"api/commands/fetch/","title":"Fetch Commands","text":"<p>Fetch commands provide advanced network request handling and interception capabilities using the Fetch API domain.</p>"},{"location":"api/commands/fetch/#overview","title":"Overview","text":"<p>The fetch commands module enables sophisticated network request management, including request modification, response interception, and authentication handling.</p>"},{"location":"api/commands/fetch/#pydoll.commands.fetch_commands","title":"pydoll.commands.fetch_commands","text":""},{"location":"api/commands/fetch/#pydoll.commands.fetch_commands.FetchCommands","title":"FetchCommands","text":"<p>This class encapsulates the fetch commands of the Chrome DevTools Protocol (CDP).</p> <p>CDP's Fetch domain allows interception and modification of network requests at the application layer. This enables developers to examine, modify, and control network traffic, which is particularly useful for testing, debugging, and advanced automation scenarios.</p> <p>The commands defined in this class provide functionality for: - Enabling and disabling fetch request interception - Continuing, fulfilling, or failing intercepted requests - Handling authentication challenges - Retrieving and modifying response bodies - Processing response data as streams</p>"},{"location":"api/commands/fetch/#pydoll.commands.fetch_commands.FetchCommands.continue_request","title":"continue_request  <code>staticmethod</code>","text":"<pre><code>continue_request(request_id, url=None, method=None, post_data=None, headers=None, intercept_response=None)\n</code></pre> <p>Creates a command to continue a paused fetch request.</p> <p>This command allows the browser to resume a fetch operation that has been intercepted. You can modify the fetch request URL, method, headers, and body before continuing.</p> PARAMETER DESCRIPTION <code>request_id</code> <p>The ID of the fetch request to continue.</p> <p> TYPE: <code>str</code> </p> <code>url</code> <p>The new URL for the fetch request. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>method</code> <p>The HTTP method to use (e.g., 'GET', 'POST'). Defaults to None.</p> <p> TYPE: <code>Optional[RequestMethod]</code> DEFAULT: <code>None</code> </p> <code>post_data</code> <p>The body data to send with the fetch request. Defaults to None.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>A list of HTTP headers to include in the fetch request. Defaults to None.</p> <p> TYPE: <code>Optional[list[HeaderEntry]]</code> DEFAULT: <code>None</code> </p> <code>intercept_response</code> <p>Indicates if the response should be intercepted. Defaults to None.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: A command for continuing the fetch request.</p>"},{"location":"api/commands/fetch/#pydoll.commands.fetch_commands.FetchCommands.continue_request_with_auth","title":"continue_request_with_auth  <code>staticmethod</code>","text":"<pre><code>continue_request_with_auth(request_id, auth_challenge_response, proxy_username=None, proxy_password=None)\n</code></pre> <p>Creates a command to continue a paused fetch request with authentication.</p> <p>This command is used when the fetch operation requires authentication. It provides the necessary credentials to continue the request.</p> PARAMETER DESCRIPTION <code>request_id</code> <p>The ID of the fetch request to continue.</p> <p> TYPE: <code>str</code> </p> <code>auth_challenge_response</code> <p>The authentication challenge response type.</p> <p> TYPE: <code>AuthChallengeResponseValues</code> </p> <code>proxy_username</code> <p>The username for proxy authentication. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>proxy_password</code> <p>The password for proxy authentication. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: A command for continuing the fetch request with authentication.</p>"},{"location":"api/commands/fetch/#pydoll.commands.fetch_commands.FetchCommands.disable","title":"disable  <code>staticmethod</code>","text":"<pre><code>disable()\n</code></pre> <p>Creates a command to disable fetch interception.</p> <p>This command stops the browser from intercepting fetch requests.</p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: A command for disabling fetch interception.</p>"},{"location":"api/commands/fetch/#pydoll.commands.fetch_commands.FetchCommands.enable","title":"enable  <code>staticmethod</code>","text":"<pre><code>enable(handle_auth_requests, url_pattern='*', resource_type=None, request_stage=None)\n</code></pre> <p>Creates a command to enable fetch interception.</p> <p>This command allows the browser to start intercepting fetch requests. You can specify whether to handle authentication challenges and the types of resources to intercept.</p> PARAMETER DESCRIPTION <code>handle_auth_requests</code> <p>Indicates if authentication requests should be handled.</p> <p> TYPE: <code>bool</code> </p> <code>url_pattern</code> <p>Pattern to match URLs for interception. Defaults to '*'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'*'</code> </p> <code>resource_type</code> <p>The type of resource to intercept. Defaults to None.</p> <p> TYPE: <code>Optional[ResourceType]</code> DEFAULT: <code>None</code> </p> <code>request_stage</code> <p>The stage of the request to intercept. Defaults to None.</p> <p> TYPE: <code>Optional[RequestStage]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: A command for enabling fetch interception.</p>"},{"location":"api/commands/fetch/#pydoll.commands.fetch_commands.FetchCommands.fail_request","title":"fail_request  <code>staticmethod</code>","text":"<pre><code>fail_request(request_id, error_reason)\n</code></pre> <p>Creates a command to simulate a failure in a fetch request.</p> <p>This command allows you to simulate a failure for a specific fetch operation, providing a reason for the failure.</p> PARAMETER DESCRIPTION <code>request_id</code> <p>The ID of the fetch request to fail.</p> <p> TYPE: <code>str</code> </p> <code>error_reason</code> <p>The reason for the failure.</p> <p> TYPE: <code>NetworkErrorReason</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: A command for failing the fetch request.</p>"},{"location":"api/commands/fetch/#pydoll.commands.fetch_commands.FetchCommands.fulfill_request","title":"fulfill_request  <code>staticmethod</code>","text":"<pre><code>fulfill_request(request_id, response_code, response_headers=None, body=None, response_phrase=None)\n</code></pre> <p>Creates a command to fulfill a fetch request with a custom response.</p> <p>This command allows you to provide a custom response for a fetch operation, including the HTTP status code, headers, and body content.</p> PARAMETER DESCRIPTION <code>request_id</code> <p>The ID of the fetch request to fulfill.</p> <p> TYPE: <code>str</code> </p> <code>response_code</code> <p>The HTTP status code to return.</p> <p> TYPE: <code>int</code> </p> <code>response_headers</code> <p>A list of response headers. Defaults to None.</p> <p> TYPE: <code>Optional[list[HeaderEntry]]</code> DEFAULT: <code>None</code> </p> <code>body</code> <p>The body content of the response. Defaults to None.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>response_phrase</code> <p>The response phrase (e.g., 'OK', 'Not Found'). Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: A command for fulfilling the fetch request.</p>"},{"location":"api/commands/fetch/#pydoll.commands.fetch_commands.FetchCommands.get_response_body","title":"get_response_body  <code>staticmethod</code>","text":"<pre><code>get_response_body(request_id)\n</code></pre> <p>Creates a command to retrieve the response body of a fetch request.</p> <p>This command allows you to access the body of a completed fetch operation, which can be useful for analyzing the response data.</p> PARAMETER DESCRIPTION <code>request_id</code> <p>The ID of the fetch request to retrieve the body from.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command[GetResponseBodyResponse]</code> <p>Command[GetResponseBodyResponse]: A command for getting the response body.</p>"},{"location":"api/commands/fetch/#pydoll.commands.fetch_commands.FetchCommands.continue_response","title":"continue_response  <code>staticmethod</code>","text":"<pre><code>continue_response(request_id, response_code=None, response_headers=None, response_phrase=None)\n</code></pre> <p>Creates a command to continue a fetch response for an intercepted request.</p> <p>This command allows the browser to continue the response flow for a specific fetch request, including customizing the HTTP status code, headers, and response phrase.</p> PARAMETER DESCRIPTION <code>request_id</code> <p>The ID of the fetch request to continue the response for.</p> <p> TYPE: <code>str</code> </p> <code>response_code</code> <p>The HTTP status code to send. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>response_headers</code> <p>A list of response headers. Defaults to None.</p> <p> TYPE: <code>Optional[list[HeaderEntry]]</code> DEFAULT: <code>None</code> </p> <code>response_phrase</code> <p>The response phrase (e.g., 'OK'). Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: A command for continuing the fetch response.</p>"},{"location":"api/commands/fetch/#pydoll.commands.fetch_commands.FetchCommands.take_response_body_as_stream","title":"take_response_body_as_stream  <code>staticmethod</code>","text":"<pre><code>take_response_body_as_stream(request_id)\n</code></pre> <p>Creates a command to take the response body as a stream.</p> <p>This command allows you to receive the response body as a stream which can be useful for handling large responses.</p> PARAMETER DESCRIPTION <code>request_id</code> <p>The ID of the fetch request to take the response body stream from.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command[TakeResponseBodyAsStreamResponse]</code> <p>Command[TakeResponseBodyAsStreamResponse]: A command for taking the response body as a stream.</p>"},{"location":"api/commands/fetch/#usage","title":"Usage","text":"<p>Fetch commands are used for advanced network interception and request handling:</p> <pre><code>from pydoll.commands.fetch_commands import enable, request_paused, continue_request\nfrom pydoll.connection.connection_handler import ConnectionHandler\n\n# Enable fetch domain\nconnection = ConnectionHandler()\nawait enable(connection, patterns=[{\n    \"urlPattern\": \"*\",\n    \"requestStage\": \"Request\"\n}])\n\n# Handle paused requests\nasync def handle_paused_request(request_id, request):\n    # Modify request or continue as-is\n    await continue_request(connection, request_id=request_id)\n</code></pre>"},{"location":"api/commands/fetch/#key-functionality","title":"Key Functionality","text":"<p>The fetch commands module provides functions for:</p>"},{"location":"api/commands/fetch/#request-interception","title":"Request Interception","text":"<ul> <li><code>enable()</code> - Enable fetch domain with patterns</li> <li><code>disable()</code> - Disable fetch domain</li> <li><code>continue_request()</code> - Continue intercepted requests</li> <li><code>fail_request()</code> - Fail requests with specific errors</li> </ul>"},{"location":"api/commands/fetch/#request-modification","title":"Request Modification","text":"<ul> <li>Modify request headers</li> <li>Change request URLs</li> <li>Alter request methods (GET, POST, etc.)</li> <li>Modify request bodies</li> </ul>"},{"location":"api/commands/fetch/#response-handling","title":"Response Handling","text":"<ul> <li><code>fulfill_request()</code> - Provide custom responses</li> <li><code>get_response_body()</code> - Get response content</li> <li>Response header modification</li> <li>Response status code control</li> </ul>"},{"location":"api/commands/fetch/#authentication","title":"Authentication","text":"<ul> <li><code>continue_with_auth()</code> - Handle authentication challenges</li> <li>Basic authentication support</li> <li>Custom authentication flows</li> </ul>"},{"location":"api/commands/fetch/#advanced-features","title":"Advanced Features","text":""},{"location":"api/commands/fetch/#pattern-based-interception","title":"Pattern-Based Interception","text":"<pre><code># Intercept specific URL patterns\npatterns = [\n    {\"urlPattern\": \"*/api/*\", \"requestStage\": \"Request\"},\n    {\"urlPattern\": \"*.js\", \"requestStage\": \"Response\"},\n    {\"urlPattern\": \"https://example.com/*\", \"requestStage\": \"Request\"}\n]\n\nawait enable(connection, patterns=patterns)\n</code></pre>"},{"location":"api/commands/fetch/#request-modification_1","title":"Request Modification","text":"<pre><code># Modify intercepted requests\nasync def modify_request(request_id, request):\n    # Add authentication header\n    headers = request.headers.copy()\n    headers[\"Authorization\"] = \"Bearer token123\"\n\n    # Continue with modified headers\n    await continue_request(\n        connection,\n        request_id=request_id,\n        headers=headers\n    )\n</code></pre>"},{"location":"api/commands/fetch/#response-mocking","title":"Response Mocking","text":"<pre><code># Mock API responses\nawait fulfill_request(\n    connection,\n    request_id=request_id,\n    response_code=200,\n    response_headers=[\n        {\"name\": \"Content-Type\", \"value\": \"application/json\"},\n        {\"name\": \"Access-Control-Allow-Origin\", \"value\": \"*\"}\n    ],\n    body='{\"status\": \"success\", \"data\": {\"mocked\": true}}'\n)\n</code></pre>"},{"location":"api/commands/fetch/#authentication-handling","title":"Authentication Handling","text":"<pre><code># Handle authentication challenges\nawait continue_with_auth(\n    connection,\n    request_id=request_id,\n    auth_challenge_response={\n        \"response\": \"ProvideCredentials\",\n        \"username\": \"user\",\n        \"password\": \"pass\"\n    }\n)\n</code></pre>"},{"location":"api/commands/fetch/#request-stages","title":"Request Stages","text":"<p>Fetch commands can intercept requests at different stages:</p> Stage Description Use Cases Request Before request is sent Modify headers, URL, method Response After response received Mock responses, modify content"},{"location":"api/commands/fetch/#error-handling","title":"Error Handling","text":"<pre><code># Fail requests with specific errors\nawait fail_request(\n    connection,\n    request_id=request_id,\n    error_reason=\"ConnectionRefused\"  # or \"AccessDenied\", \"TimedOut\", etc.\n)\n</code></pre>"},{"location":"api/commands/fetch/#integration-with-network-commands","title":"Integration with Network Commands","text":"<p>Fetch commands work alongside network commands but provide more granular control:</p> <ul> <li>Network Commands: Broader network monitoring and control</li> <li>Fetch Commands: Specific request/response interception and modification</li> </ul> <p>Performance Considerations</p> <p>Fetch interception can impact page loading performance. Use specific URL patterns and disable when not needed to minimize overhead. </p>"},{"location":"api/commands/input/","title":"Input Commands","text":"<p>Input commands handle mouse and keyboard interactions, providing human-like input simulation.</p>"},{"location":"api/commands/input/#overview","title":"Overview","text":"<p>The input commands module provides functionality for simulating user input including mouse movements, clicks, keyboard typing, and key presses.</p>"},{"location":"api/commands/input/#pydoll.commands.input_commands","title":"pydoll.commands.input_commands","text":""},{"location":"api/commands/input/#pydoll.commands.input_commands.InputCommands","title":"InputCommands","text":"<p>A class for simulating user input events using Chrome DevTools Protocol.</p> <p>The Input domain provides methods for simulating user input, including: - Keyboard events (key presses, releases) - Mouse events (clicks, movements, wheel) - Touch events (taps, multi-touch gestures) - Drag and drop events - Synthetic gestures (pinch, scroll, tap)</p> <p>These methods allow for programmatic control of input events without requiring actual user interaction, making it useful for testing and automation.</p>"},{"location":"api/commands/input/#pydoll.commands.input_commands.InputCommands.cancel_dragging","title":"cancel_dragging  <code>staticmethod</code>","text":"<pre><code>cancel_dragging()\n</code></pre> <p>Generates a command to cancel any active dragging in the page.</p> <p>This is useful when you need to interrupt an ongoing drag operation that might have been started with dispatchDragEvent or by other means.</p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to cancel dragging.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/input/#pydoll.commands.input_commands.InputCommands.dispatch_key_event","title":"dispatch_key_event  <code>staticmethod</code>","text":"<pre><code>dispatch_key_event(type, modifiers=None, timestamp=None, text=None, unmodified_text=None, key_identifier=None, code=None, key=None, windows_virtual_key_code=None, native_virtual_key_code=None, auto_repeat=None, is_keypad=None, is_system_key=None, location=None, commands=None)\n</code></pre> <p>Generates a command to dispatch a key event to the page.</p> <p>This method can simulate various types of keyboard events such as key presses, key releases, and character inputs.</p> PARAMETER DESCRIPTION <code>type</code> <p>Type of the key event. Allowed values: keyDown, keyUp, rawKeyDown, char.  - keyDown: Corresponds to a user pressing a key  - keyUp: Corresponds to a user releasing a key  - rawKeyDown: A physical key press, without the text processing  - char: Generates a character without explicit key events</p> <p> TYPE: <code>KeyEventType</code> </p> <code>modifiers</code> <p>Bit field representing pressed modifier keys. Values:       Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).       For example, to simulate Ctrl+Shift, use 10.</p> <p> TYPE: <code>Optional[KeyModifier]</code> DEFAULT: <code>None</code> </p> <code>timestamp</code> <p>Time at which the event occurred, in seconds since epoch.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>text</code> <p>Text as generated by processing a virtual key code with a keyboard layout.  Not needed for 'keyUp' and 'rawKeyDown' events (default: \"\").</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>unmodified_text</code> <p>Text that would have been generated by the keyboard without modifiers            (except for shift). Useful for shortcut key handling (default: \"\").</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>key_identifier</code> <p>Unique key identifier (e.g., 'U+0041') (default: \"\").</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>code</code> <p>Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: \"\").</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>key</code> <p>Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc. (e.g., 'AltGr') (default: \"\").</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>windows_virtual_key_code</code> <p>Windows virtual key code (default: 0).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>native_virtual_key_code</code> <p>Native virtual key code (default: 0).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>auto_repeat</code> <p>Whether the event was generated from auto repeat (default: false).</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>is_keypad</code> <p>Whether the event was generated from the keypad (default: false).</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>is_system_key</code> <p>Whether the event was a system key event (default: false).</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>location</code> <p>Whether the event was from the left or right side of the keyboard:      0=Default, 1=Left, 2=Right (default: 0).</p> <p> TYPE: <code>Optional[KeyLocation]</code> DEFAULT: <code>None</code> </p> <code>commands</code> <p>Editing commands to send with the key event (e.g., 'selectAll')      (default: []). These are related to but not equal to the command names      used in <code>document.execCommand</code> and NSStandardKeyBindingResponding.</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to dispatch the key event.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/input/#pydoll.commands.input_commands.InputCommands.dispatch_mouse_event","title":"dispatch_mouse_event  <code>staticmethod</code>","text":"<pre><code>dispatch_mouse_event(type, x, y, modifiers=None, timestamp=None, button=None, click_count=None, force=None, tangential_pressure=None, tilt_x=None, tilt_y=None, twist=None, delta_x=None, delta_y=None, pointer_type=None)\n</code></pre> <p>Generates a command to dispatch a mouse event to the page.</p> <p>This method allows simulating various mouse interactions such as clicks, movements, and wheel scrolling.</p> PARAMETER DESCRIPTION <code>type</code> <p>Type of the mouse event. Allowed values:  - mousePressed: Mouse button pressed  - mouseReleased: Mouse button released  - mouseMoved: Mouse moved  - mouseWheel: Mouse wheel rotated</p> <p> TYPE: <code>MouseEventType</code> </p> <code>x</code> <p>X coordinate of the event relative to the main frame's viewport in CSS pixels.</p> <p> TYPE: <code>int</code> </p> <code>y</code> <p>Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport, and Y increases going down.</p> <p> TYPE: <code>int</code> </p> <code>modifiers</code> <p>Bit field representing pressed modifier keys. Values: Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).</p> <p> TYPE: <code>Optional[KeyModifier]</code> DEFAULT: <code>None</code> </p> <code>timestamp</code> <p>Time at which the event occurred, in seconds since epoch.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>button</code> <p>Mouse button being pressed/released. Default is \"none\". Allowed values: \"none\", \"left\", \"middle\", \"right\", \"back\", \"forward\".</p> <p> TYPE: <code>Optional[MouseButton]</code> DEFAULT: <code>None</code> </p> <code>click_count</code> <p>Number of times the mouse button was clicked (default: 0). For example, 2 for a double-click.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>force</code> <p>The normalized pressure, which has a range of [0,1] (default: 0). Used primarily for pressure-sensitive inputs.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>tangential_pressure</code> <p>The normalized tangential pressure, which has a range of [-1,1] (default: 0). Used for stylus input.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>tilt_x</code> <p>The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90]. A positive tiltX is to the right (default: 0).</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>tilt_y</code> <p>The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90]. A positive tiltY is towards the user (default: 0).</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>twist</code> <p>The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>delta_x</code> <p>X delta in CSS pixels for mouse wheel event (default: 0). Positive values scroll right.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>delta_y</code> <p>Y delta in CSS pixels for mouse wheel event (default: 0). Positive values scroll up.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>pointer_type</code> <p>Pointer type (default: \"mouse\"). Allowed values: \"mouse\", \"pen\".</p> <p> TYPE: <code>Optional[PointerType]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to dispatch the mouse event.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/input/#pydoll.commands.input_commands.InputCommands.dispatch_touch_event","title":"dispatch_touch_event  <code>staticmethod</code>","text":"<pre><code>dispatch_touch_event(type, touch_points=None, modifiers=None, timestamp=None)\n</code></pre> <p>Generates a command to dispatch a touch event to the page.</p> <p>This method allows simulating touch interactions on touch-enabled devices or emulated touch environments.</p> PARAMETER DESCRIPTION <code>type</code> <p>Type of the touch event. Allowed values:  - touchStart: Touch started - at least one point must be specified  - touchEnd: Touch ended - points that are no longer pressed should be removed  - touchMove: Touch moved - active points should be updated  - touchCancel: Touch canceled - clears all touch points  Touch end and cancel events must not contain any touch points,  while touch start and move must contain at least one.</p> <p> TYPE: <code>TouchEventType</code> </p> <code>touch_points</code> <p>list of active touch points. One event per any changed point         (compared to previous event) is generated, emulating         pressing/moving/releasing points one by one.         Each point includes coordinates and other properties.</p> <p> TYPE: <code>Optional[list[TouchPoint]]</code> DEFAULT: <code>None</code> </p> <code>modifiers</code> <p>Bit field representing pressed modifier keys. Values:       Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).</p> <p> TYPE: <code>Optional[KeyModifier]</code> DEFAULT: <code>None</code> </p> <code>timestamp</code> <p>Time at which the event occurred, in seconds since epoch.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to dispatch the touch event.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/input/#pydoll.commands.input_commands.InputCommands.set_ignore_input_events","title":"set_ignore_input_events  <code>staticmethod</code>","text":"<pre><code>set_ignore_input_events(enabled)\n</code></pre> <p>Generates a command to ignore input events (useful while auditing page).</p> <p>When enabled, all input events will be ignored, which can be useful during automated tests or when you want to prevent user interaction while performing certain operations.</p> PARAMETER DESCRIPTION <code>enabled</code> <p>If true, input events processing will be ignored.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set ignore input events.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/input/#pydoll.commands.input_commands.InputCommands.dispatch_drag_event","title":"dispatch_drag_event  <code>staticmethod</code>","text":"<pre><code>dispatch_drag_event(type, x, y, data=None, modifiers=None)\n</code></pre> <p>Generates a command to dispatch a drag event into the page.</p> <p>This experimental method allows simulating drag and drop operations by dispatching drag events at specific coordinates.</p> PARAMETER DESCRIPTION <code>type</code> <p>Type of the drag event. Allowed values:  - dragEnter: Fired when a dragged item enters a valid drop target  - dragOver: Fired when a dragged item is being dragged over a valid drop target  - drop: Fired when an item is dropped on a valid drop target  - dragCancel: Fired when a drag operation is being canceled</p> <p> TYPE: <code>DragEventType</code> </p> <code>x</code> <p>X coordinate of the event relative to the main frame's viewport in CSS pixels.</p> <p> TYPE: <code>int</code> </p> <code>y</code> <p>Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport, and Y increases going down.</p> <p> TYPE: <code>int</code> </p> <code>data</code> <p>Drag data containing items being dragged, their MIME types, and other information.</p> <p> TYPE: <code>Optional[DragData]</code> DEFAULT: <code>None</code> </p> <code>modifiers</code> <p>Bit field representing pressed modifier keys. Values:       Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).</p> <p> TYPE: <code>Optional[KeyModifier]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to dispatch the drag event.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/input/#pydoll.commands.input_commands.InputCommands.emulate_touch_from_mouse_event","title":"emulate_touch_from_mouse_event  <code>staticmethod</code>","text":"<pre><code>emulate_touch_from_mouse_event(type, x, y, button, timestamp=None, delta_x=None, delta_y=None, modifiers=None, click_count=None)\n</code></pre> <p>Generates a command to emulate touch event from the mouse event parameters.</p> <p>This experimental method allows converting mouse events into touch events, useful for testing touch interactions in environments where touch is not available.</p> PARAMETER DESCRIPTION <code>type</code> <p>Type of the mouse event to convert. Allowed values:  - mousePressed: Converted to touchStart  - mouseReleased: Converted to touchEnd  - mouseMoved: Converted to touchMove  - mouseWheel: May trigger scrolling</p> <p> TYPE: <code>MouseEventType</code> </p> <code>x</code> <p>X coordinate of the mouse pointer in device-independent pixels (DIP).</p> <p> TYPE: <code>int</code> </p> <code>y</code> <p>Y coordinate of the mouse pointer in DIP.</p> <p> TYPE: <code>int</code> </p> <code>button</code> <p>Mouse button. Only \"none\", \"left\", \"right\" are supported.</p> <p> TYPE: <code>MouseButton</code> </p> <code>timestamp</code> <p>Time at which the event occurred, in seconds since epoch.       Default is current time.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>delta_x</code> <p>X delta in DIP for mouse wheel event (default: 0). Used for scrolling.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>delta_y</code> <p>Y delta in DIP for mouse wheel event (default: 0). Used for scrolling.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>modifiers</code> <p>Bit field representing pressed modifier keys. Values:       Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).</p> <p> TYPE: <code>Optional[KeyModifier]</code> DEFAULT: <code>None</code> </p> <code>click_count</code> <p>Number of times the mouse button was clicked (default: 0).        For example, 2 for a double-click.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to emulate touch from mouse event.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/input/#pydoll.commands.input_commands.InputCommands.ime_set_composition","title":"ime_set_composition  <code>staticmethod</code>","text":"<pre><code>ime_set_composition(text, selection_start, selection_end, replacement_start=None, replacement_end=None)\n</code></pre> <p>Generates a command to set the current candidate text for IME.</p> <p>This experimental method sets the text for Input Method Editors (IME), which are used for entering characters in languages that require more keystrokes than the number of characters (like Chinese, Japanese, Korean).</p> <p>Use imeCommitComposition to commit the final text. Use imeSetComposition with empty string as text to cancel composition.</p> PARAMETER DESCRIPTION <code>text</code> <p>The text to insert as the IME composition.</p> <p> TYPE: <code>str</code> </p> <code>selection_start</code> <p>Start position of the selection within the composition text.</p> <p> TYPE: <code>int</code> </p> <code>selection_end</code> <p>End position of the selection within the composition text.</p> <p> TYPE: <code>int</code> </p> <code>replacement_start</code> <p>Start position of the text to be replaced (default: same as selection_start).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>replacement_end</code> <p>End position of the text to be replaced (default: same as selection_end).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set IME composition.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/input/#pydoll.commands.input_commands.InputCommands.insert_text","title":"insert_text  <code>staticmethod</code>","text":"<pre><code>insert_text(text)\n</code></pre> <p>Generates a command to emulate inserting text that doesn't come from a key press.</p> <p>This experimental method is useful for inserting text that would normally come from sources other than keyboard, such as emoji pickers, IMEs, or clipboard pastes.</p> PARAMETER DESCRIPTION <code>text</code> <p>The text to insert.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to insert text.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/input/#pydoll.commands.input_commands.InputCommands.set_intercept_drags","title":"set_intercept_drags  <code>staticmethod</code>","text":"<pre><code>set_intercept_drags(enabled)\n</code></pre> <p>Generates a command to control interception of drag and drop events.</p> <p>This experimental method prevents default drag and drop behavior and instead emits Input.dragIntercepted events. Drag and drop behavior can then be directly controlled via Input.dispatchDragEvent.</p> <p>This is useful for implementing custom drag and drop logic or for testing drag and drop behavior in automated tests.</p> PARAMETER DESCRIPTION <code>enabled</code> <p>If true, drag events will be intercepted and reported as     dragIntercepted events, preventing the default behavior.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set drag interception.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/input/#pydoll.commands.input_commands.InputCommands.synthesize_pinch_gesture","title":"synthesize_pinch_gesture  <code>staticmethod</code>","text":"<pre><code>synthesize_pinch_gesture(x, y, scale_factor, relative_speed=None, gesture_source_type=None)\n</code></pre> <p>Generates a command to synthesize a pinch gesture over a time period.</p> <p>This experimental method creates a synthetic pinch gesture (zoom in/out) by issuing appropriate touch events over time. This is useful for testing pinch-to-zoom functionality in web applications.</p> PARAMETER DESCRIPTION <code>x</code> <p>X coordinate of the start of the gesture in CSS pixels.</p> <p> TYPE: <code>int</code> </p> <code>y</code> <p>Y coordinate of the start of the gesture in CSS pixels.</p> <p> TYPE: <code>int</code> </p> <code>scale_factor</code> <p>Relative scale factor after zooming:         - &gt;1.0 zooms in (fingers moving apart)         - &lt;1.0 zooms out (fingers moving together)</p> <p> TYPE: <code>float</code> </p> <code>relative_speed</code> <p>Relative pointer speed in pixels per second (default: 800).           Controls how fast the gesture happens.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>gesture_source_type</code> <p>Which type of input events to be generated:               - 'default': Platform's preferred input type               - 'touch': Touch input               - 'mouse': Mouse input</p> <p> TYPE: <code>Optional[GestureSourceType]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to synthesize a pinch gesture.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/input/#pydoll.commands.input_commands.InputCommands.synthesize_scroll_gesture","title":"synthesize_scroll_gesture  <code>staticmethod</code>","text":"<pre><code>synthesize_scroll_gesture(x, y, x_distance=None, y_distance=None, x_overscroll=None, y_overscroll=None, prevent_fling=None, speed=None, gesture_source_type=None, repeat_count=None, repeat_delay_ms=None, interaction_marker_name=None)\n</code></pre> <p>Generates a command to synthesize a scroll gesture over a time period.</p> <p>This experimental method creates a synthetic scroll gesture by issuing appropriate touch events over time. This is useful for testing scrolling behavior in web applications.</p> PARAMETER DESCRIPTION <code>x</code> <p>X coordinate of the start of the gesture in CSS pixels.</p> <p> TYPE: <code>int</code> </p> <code>y</code> <p>Y coordinate of the start of the gesture in CSS pixels.</p> <p> TYPE: <code>int</code> </p> <code>x_distance</code> <p>The distance to scroll along the X axis (positive to scroll left).</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>y_distance</code> <p>The distance to scroll along the Y axis (positive to scroll up).</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>x_overscroll</code> <p>The number of additional pixels to scroll back along the X axis,         in addition to the given distance. This creates an overscroll         effect (rubber-banding).</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>y_overscroll</code> <p>The number of additional pixels to scroll back along the Y axis,         in addition to the given distance. This creates an overscroll         effect (rubber-banding).</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>prevent_fling</code> <p>Prevent fling (default: true). If false, a fling animation might          continue after the gesture.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>speed</code> <p>Swipe speed in pixels per second (default: 800).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>gesture_source_type</code> <p>Which type of input events to be generated:               - 'default': Platform's preferred input type               - 'touch': Touch input               - 'mouse': Mouse input</p> <p> TYPE: <code>Optional[GestureSourceType]</code> DEFAULT: <code>None</code> </p> <code>repeat_count</code> <p>The number of times to repeat the gesture (default: 0).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>repeat_delay_ms</code> <p>The number of milliseconds delay between each repeat (default: 250).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>interaction_marker_name</code> <p>The name of the interaction markers to generate, if not empty.                   Used for tracking gesture timing in performance measurements.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to synthesize a scroll gesture.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/input/#pydoll.commands.input_commands.InputCommands.synthesize_tap_gesture","title":"synthesize_tap_gesture  <code>staticmethod</code>","text":"<pre><code>synthesize_tap_gesture(x, y, duration=None, tap_count=None, gesture_source_type=None)\n</code></pre> <p>Generates a command to synthesize a tap gesture over a time period.</p> <p>This experimental method creates a synthetic tap gesture by issuing appropriate touch events over time. This is useful for testing touch interaction in web applications.</p> PARAMETER DESCRIPTION <code>x</code> <p>X coordinate of the start of the gesture in CSS pixels.</p> <p> TYPE: <code>int</code> </p> <code>y</code> <p>Y coordinate of the start of the gesture in CSS pixels.</p> <p> TYPE: <code>int</code> </p> <code>duration</code> <p>Duration between touchdown and touchup events in milliseconds (default: 50).      Controls how long the tap gesture takes.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>tap_count</code> <p>Number of times to perform the tap (e.g., 2 for a double tap, default: 1).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>gesture_source_type</code> <p>Which type of input events to be generated:               - 'default': Platform's preferred input type               - 'touch': Touch input               - 'mouse': Mouse input</p> <p> TYPE: <code>Optional[GestureSourceType]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to synthesize a tap gesture.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/input/#usage","title":"Usage","text":"<p>Input commands are used by element interaction methods and can be used directly for advanced input scenarios:</p> <pre><code>from pydoll.commands.input_commands import dispatch_mouse_event, dispatch_key_event\nfrom pydoll.connection.connection_handler import ConnectionHandler\n\n# Simulate mouse click\nconnection = ConnectionHandler()\nawait dispatch_mouse_event(\n    connection, \n    type=\"mousePressed\", \n    x=100, \n    y=200, \n    button=\"left\"\n)\n\n# Simulate keyboard typing\nawait dispatch_key_event(\n    connection,\n    type=\"keyDown\",\n    key=\"Enter\"\n)\n</code></pre>"},{"location":"api/commands/input/#key-functionality","title":"Key Functionality","text":"<p>The input commands module provides functions for:</p>"},{"location":"api/commands/input/#mouse-events","title":"Mouse Events","text":"<ul> <li><code>dispatch_mouse_event()</code> - Mouse clicks, movements, and wheel events</li> <li>Mouse button states (left, right, middle)</li> <li>Coordinate-based positioning</li> <li>Drag and drop operations</li> </ul>"},{"location":"api/commands/input/#keyboard-events","title":"Keyboard Events","text":"<ul> <li><code>dispatch_key_event()</code> - Key press and release events</li> <li><code>insert_text()</code> - Direct text insertion</li> <li>Special key handling (Enter, Tab, Arrow keys, etc.)</li> <li>Modifier keys (Ctrl, Alt, Shift)</li> </ul>"},{"location":"api/commands/input/#touch-events","title":"Touch Events","text":"<ul> <li>Touch screen simulation</li> <li>Multi-touch gestures</li> <li>Touch coordinates and pressure</li> </ul>"},{"location":"api/commands/input/#human-like-behavior","title":"Human-like Behavior","text":"<p>The input commands support human-like behavior patterns:</p> <ul> <li>Natural mouse movement curves</li> <li>Realistic typing speeds and patterns</li> <li>Random micro-delays between actions</li> <li>Pressure-sensitive touch events</li> </ul> <p>Element Methods</p> <p>For most use cases, use the higher-level element methods like <code>element.click()</code> and <code>element.type_text()</code> which provide a more convenient API and handle common scenarios automatically. </p>"},{"location":"api/commands/network/","title":"Network Commands","text":"<p>Network commands provide comprehensive control over network requests, responses, and browser networking behavior.</p>"},{"location":"api/commands/network/#overview","title":"Overview","text":"<p>The network commands module enables request interception, response modification, cookie management, and network monitoring capabilities.</p>"},{"location":"api/commands/network/#pydoll.commands.network_commands","title":"pydoll.commands.network_commands","text":""},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands","title":"NetworkCommands","text":"<p>Implementation of Chrome DevTools Protocol for the Network domain.</p> <p>This class provides commands for monitoring and manipulating network activities, enabling detailed inspection and control over HTTP requests and responses. The Network domain exposes comprehensive network-related information including: - Request/response headers and bodies - Resource timing and caching behavior - Cookie management and security details - Network conditions emulation - Traffic interception and modification</p> <p>The commands allow developers to analyze performance, debug network issues, and test application behavior under various network conditions.</p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.clear_browser_cache","title":"clear_browser_cache  <code>staticmethod</code>","text":"<pre><code>clear_browser_cache()\n</code></pre> <p>Clears browser cache storage.</p> <p>This command is essential for testing cache behavior and ensuring fresh resource loading. It affects all cached resources including: - CSS/JavaScript files - Images and media assets - API response caching</p> <p>Use cases: - Testing cache invalidation strategies - Reproducing issues with stale content - Performance benchmarking without cache influence</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to clear the entire browser cache</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.clear_browser_cookies","title":"clear_browser_cookies  <code>staticmethod</code>","text":"<pre><code>clear_browser_cookies()\n</code></pre> <p>Command to clear all cookies stored in the browser.</p> <p>This can be beneficial for testing scenarios where you need to simulate a fresh user session without any previously stored cookies that might affect the application's behavior.</p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: A command to clear all cookies in the browser.</p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.delete_cookies","title":"delete_cookies  <code>staticmethod</code>","text":"<pre><code>delete_cookies(name, url=None, domain=None, path=None, partition_key=None)\n</code></pre> <p>Deletes browser cookies with matching criteria.</p> <p>Provides granular control over cookie removal through multiple parameters: - Delete by name only (affects all matching cookies) - Scope deletion using URL, domain, or path - Handle partitioned cookies for privacy-aware applications</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the cookies to remove (required)</p> <p> TYPE: <code>str</code> </p> <code>url</code> <p>Delete cookies for specific URL (domain/path must match)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>domain</code> <p>Exact domain for cookie deletion</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>path</code> <p>Exact path for cookie deletion</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>partition_key</code> <p>Partition key attributes for cookie isolation</p> <p> TYPE: <code>Optional[CookiePartitionKey]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to execute selective cookie deletion</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.disable","title":"disable  <code>staticmethod</code>","text":"<pre><code>disable()\n</code></pre> <p>Stops network monitoring and event reporting.</p> <p>Preserves network state but stops: - Request/response events - WebSocket message tracking - Loading progress notifications</p> <p>Use when: - Reducing overhead during non-network operations - Pausing monitoring temporarily - Finalizing network-related tests</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to disable network monitoring</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.enable","title":"enable  <code>staticmethod</code>","text":"<pre><code>enable(max_total_buffer_size=None, max_resource_buffer_size=None, max_post_data_size=None)\n</code></pre> <p>Enables network monitoring with configurable buffers.</p> PARAMETER DESCRIPTION <code>max_total_buffer_size</code> <p>Total memory buffer for network data (bytes)</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>max_resource_buffer_size</code> <p>Per-resource buffer limit (bytes)</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>max_post_data_size</code> <p>Maximum POST payload to capture (bytes)</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <p>Recommended settings: - Increase buffers for long-running sessions - Adjust post size for API testing - Monitor memory usage with large buffers</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to enable network monitoring</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.get_cookies","title":"get_cookies  <code>staticmethod</code>","text":"<pre><code>get_cookies(urls=None)\n</code></pre> <p>Retrieves cookies matching specified URLs.</p> PARAMETER DESCRIPTION <code>urls</code> <p>list of URLs to scope cookie retrieval</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command returning cookie details including: - Name, value, and attributes - Security and scope parameters - Expiration and size information</p> <p> TYPE: <code>Command[GetCookiesResponse]</code> </p> <p>Usage notes: - Empty URL list returns all cookies - Includes HTTP-only and secure cookies - Shows partitioned cookie status</p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.get_request_post_data","title":"get_request_post_data  <code>staticmethod</code>","text":"<pre><code>get_request_post_data(request_id)\n</code></pre> <p>Retrieves POST data from a specific network request.</p> <p>Essential for: - Form submission analysis - API request debugging - File upload monitoring - Security testing</p> PARAMETER DESCRIPTION <code>request_id</code> <p>Unique identifier for the network request</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns: - Raw POST data content - Multipart form data (excluding file contents) - Content encoding information</p> <p> TYPE: <code>Command[GetRequestPostDataResponse]</code> </p> <p>Note: Large POST bodies may be truncated based on buffer settings</p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.get_response_body","title":"get_response_body  <code>staticmethod</code>","text":"<pre><code>get_response_body(request_id)\n</code></pre> <p>Retrieves the full content of a network response.</p> <p>Supports various content types: - Text-based resources (HTML, CSS, JSON) - Base64-encoded binary content (images, media) - Gzip/deflate compressed responses</p> PARAMETER DESCRIPTION <code>request_id</code> <p>Unique network request identifier</p> <p> TYPE: <code>str</code> </p> <p>Important considerations: - Response must be available in browser memory - Large responses may require streaming approaches - Sensitive data should be handled securely</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command returning response body and encoding details</p> <p> TYPE: <code>Command[GetResponseBodyResponse]</code> </p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.set_cache_disabled","title":"set_cache_disabled  <code>staticmethod</code>","text":"<pre><code>set_cache_disabled(cache_disabled)\n</code></pre> <p>Controls browser's cache mechanism.</p> <p>Use cases: - Testing resource update behavior - Forcing fresh content loading - Performance impact analysis - Cache-busting scenarios</p> PARAMETER DESCRIPTION <code>cache_disabled</code> <p>True to disable caching, False to enable</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to modify cache behavior</p> <p> TYPE: <code>Command[Response]</code> </p> <p>Note: Affects all requests until re-enabled</p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.set_cookie","title":"set_cookie  <code>staticmethod</code>","text":"<pre><code>set_cookie(name, value, url=None, domain=None, path=None, secure=None, http_only=None, same_site=None, expires=None, priority=None, same_party=None, source_scheme=None, source_port=None, partition_key=None)\n</code></pre> <p>Creates or updates a cookie with specified attributes.</p> <p>Comprehensive cookie control supporting: - Session and persistent cookies - Security attributes (Secure, HttpOnly) - SameSite policies - Cookie partitioning - Priority levels</p> PARAMETER DESCRIPTION <code>name</code> <p>Cookie name</p> <p> TYPE: <code>str</code> </p> <code>value</code> <p>Cookie value</p> <p> TYPE: <code>str</code> </p> <code>url</code> <p>Target URL for the cookie</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>domain</code> <p>Cookie domain scope</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>path</code> <p>Cookie path scope</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>secure</code> <p>Require HTTPS</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>http_only</code> <p>Prevent JavaScript access</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>same_site</code> <p>Cross-site access policy</p> <p> TYPE: <code>Optional[CookieSameSite]</code> DEFAULT: <code>None</code> </p> <code>expires</code> <p>Expiration timestamp</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>priority</code> <p>Cookie priority level</p> <p> TYPE: <code>Optional[CookiePriority]</code> DEFAULT: <code>None</code> </p> <code>same_party</code> <p>First-Party Sets flag</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>source_scheme</code> <p>Cookie source context</p> <p> TYPE: <code>Optional[CookieSourceScheme]</code> DEFAULT: <code>None</code> </p> <code>source_port</code> <p>Source port restriction</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>partition_key</code> <p>Storage partition key</p> <p> TYPE: <code>Optional[CookiePartitionKey]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns success status</p> <p> TYPE: <code>Command[SetCookieResponse]</code> </p> <p>Security considerations: - Use secure flag for sensitive data - Consider SameSite policies - Be aware of cross-site implications</p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.set_cookies","title":"set_cookies  <code>staticmethod</code>","text":"<pre><code>set_cookies(cookies)\n</code></pre> <p>Sets multiple cookies in a single operation.</p> <p>Efficient for: - Batch cookie operations - Session state restoration - Testing multiple authentication states - Cross-domain cookie setup</p> PARAMETER DESCRIPTION <code>cookies</code> <p>list of cookie parameters including     name, value, and attributes</p> <p> TYPE: <code>list[SetCookieParams]</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command for bulk cookie setting</p> <p> TYPE: <code>Command[Response]</code> </p> <p>Performance note: - More efficient than multiple set_cookie calls - Consider memory impact with large batches</p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.set_extra_http_headers","title":"set_extra_http_headers  <code>staticmethod</code>","text":"<pre><code>set_extra_http_headers(headers)\n</code></pre> <p>Applies custom HTTP headers to all subsequent requests.</p> <p>Enables advanced scenarios: - A/B testing with custom headers - Authentication bypass for testing - Content negotiation simulations - Security header validation</p> PARAMETER DESCRIPTION <code>headers</code> <p>list of key-value header pairs</p> <p> TYPE: <code>list[HeaderEntry]</code> </p> <p>Security notes: - Headers are applied browser-wide - Sensitive headers (e.g., Authorization) persist until cleared - Use with caution in shared environments</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to set global HTTP headers</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.set_useragent_override","title":"set_useragent_override  <code>staticmethod</code>","text":"<pre><code>set_useragent_override(user_agent, accept_language=None, platform=None, user_agent_metadata=None)\n</code></pre> <p>Overrides the browser's User-Agent string.</p> <p>Use cases: - Device/browser simulation - Compatibility testing - Content negotiation - Bot detection bypass</p> PARAMETER DESCRIPTION <code>user_agent</code> <p>Complete User-Agent string</p> <p> TYPE: <code>str</code> </p> <code>accept_language</code> <p>Language preference header</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>platform</code> <p>Platform identifier</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>user_agent_metadata</code> <p>Detailed UA metadata</p> <p> TYPE: <code>Optional[UserAgentMetadata]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to override user agent</p> <p> TYPE: <code>Command[Response]</code> </p> <p>Testing considerations: - Affects all subsequent requests - May impact server-side behavior - Consider mobile/desktop differences</p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.clear_accepted_encodings_override","title":"clear_accepted_encodings_override  <code>staticmethod</code>","text":"<pre><code>clear_accepted_encodings_override()\n</code></pre> <p>Restores default content encoding acceptance.</p> <p>Effects: - Resets compression preferences - Restores default Accept-Encoding header - Allows server-chosen encoding</p> <p>Use when: - Testing encoding fallbacks - Debugging compression issues - Resetting after encoding tests</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to clear encoding overrides</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.enable_reporting_api","title":"enable_reporting_api  <code>staticmethod</code>","text":"<pre><code>enable_reporting_api(enabled)\n</code></pre> <p>Controls the Reporting API functionality.</p> <p>Features: - Network error reporting - Deprecation notices - CSP violation reports - CORS issues</p> PARAMETER DESCRIPTION <code>enabled</code> <p>True to enable, False to disable</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to configure Reporting API</p> <p> TYPE: <code>Command[Response]</code> </p> <p>Note: Requires browser support for Reporting API</p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.search_in_response_body","title":"search_in_response_body  <code>staticmethod</code>","text":"<pre><code>search_in_response_body(request_id, query, case_sensitive=False, is_regex=False)\n</code></pre> <p>Searches for content within response bodies.</p> <p>Powerful for: - Content verification - Security scanning - Data extraction - Response validation</p> PARAMETER DESCRIPTION <code>request_id</code> <p>Target response identifier</p> <p> TYPE: <code>str</code> </p> <code>query</code> <p>Search string or pattern</p> <p> TYPE: <code>str</code> </p> <code>case_sensitive</code> <p>Match case sensitivity</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>is_regex</code> <p>Use regular expression matching</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command returning match results</p> <p> TYPE: <code>Command[SearchInResponseBodyResponse]</code> </p> <p>Performance tip: - Use specific queries for large responses - Consider regex complexity</p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.set_blocked_urls","title":"set_blocked_urls  <code>staticmethod</code>","text":"<pre><code>set_blocked_urls(urls)\n</code></pre> <p>Blocks specified URLs from loading.</p> <p>Key features: - Pattern-based URL blocking - Resource type filtering - Network request prevention - Error simulation</p> PARAMETER DESCRIPTION <code>urls</code> <p>list of URL patterns to block  Supports wildcards and pattern matching</p> <p> TYPE: <code>list[str]</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to set URL blocking rules</p> <p> TYPE: <code>Command[Response]</code> </p> <p>Common applications: - Ad/tracker blocking simulation - Resource loading control - Error handling testing - Network isolation testing</p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.set_bypass_service_worker","title":"set_bypass_service_worker  <code>staticmethod</code>","text":"<pre><code>set_bypass_service_worker(bypass)\n</code></pre> <p>Controls Service Worker interception of network requests.</p> <p>Use cases: - Testing direct network behavior - Bypassing offline functionality - Debug caching issues - Performance comparison</p> PARAMETER DESCRIPTION <code>bypass</code> <p>True to skip Service Worker, False to allow</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to configure Service Worker behavior</p> <p> TYPE: <code>Command[Response]</code> </p> <p>Impact: - Affects offline capabilities - Changes caching behavior - Modifies push notifications</p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.get_certificate","title":"get_certificate  <code>staticmethod</code>","text":"<pre><code>get_certificate(origin)\n</code></pre> <p>Retrieves SSL/TLS certificate information for a domain.</p> <p>Provides: - Certificate chain details - Validation status - Expiration information - Issuer details</p> PARAMETER DESCRIPTION <code>origin</code> <p>Target domain for certificate inspection</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command returning certificate data</p> <p> TYPE: <code>Command[GetCertificateResponse]</code> </p> <p>Security applications: - Certificate validation - SSL/TLS verification - Security assessment - Chain of trust verification</p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.get_response_body_for_interception","title":"get_response_body_for_interception  <code>staticmethod</code>","text":"<pre><code>get_response_body_for_interception(interception_id)\n</code></pre> <p>Retrieves response body from an intercepted request.</p> <p>Essential for: - Response modification - Content inspection - Security testing - API response validation</p> PARAMETER DESCRIPTION <code>interception_id</code> <p>Identifier for intercepted request</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command providing intercepted response content</p> <p> TYPE: <code>Command[GetResponseBodyForInterceptionResponse]</code> </p> <p>Note: - Must be used with interception enabled - Supports streaming responses - Handles various content types</p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.set_accepted_encodings","title":"set_accepted_encodings  <code>staticmethod</code>","text":"<pre><code>set_accepted_encodings(encodings)\n</code></pre> <p>Specifies accepted content encodings for requests.</p> <p>Controls: - Compression algorithms - Transfer encoding - Content optimization</p> PARAMETER DESCRIPTION <code>encodings</code> <p>list of accepted encoding methods      (gzip, deflate, br, etc.)</p> <p> TYPE: <code>list[ContentEncoding]</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to set encoding preferences</p> <p> TYPE: <code>Command[Response]</code> </p> <p>Performance implications: - Affects bandwidth usage - Impacts response time - Changes server behavior</p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.set_attach_debug_stack","title":"set_attach_debug_stack  <code>staticmethod</code>","text":"<pre><code>set_attach_debug_stack(enabled)\n</code></pre> <p>Enables/disables debug stack attachment to requests.</p> <p>Debug features: - Stack trace collection - Request origin tracking - Initialization context - Call site identification</p> PARAMETER DESCRIPTION <code>enabled</code> <p>True to attach debug info, False to disable</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to configure debug stack attachment</p> <p> TYPE: <code>Command[Response]</code> </p> <p>Performance note: - May impact performance when enabled - Useful for development/debugging - Consider memory usage</p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.set_cookie_controls","title":"set_cookie_controls  <code>staticmethod</code>","text":"<pre><code>set_cookie_controls(enable_third_party_cookie_restriction, disable_third_party_cookie_metadata=None, disable_third_party_cookie_heuristics=None)\n</code></pre> <p>Configures third-party cookie handling policies.</p> <p>Privacy features: - Cookie access control - Third-party restrictions - Tracking prevention - Privacy policy enforcement</p> PARAMETER DESCRIPTION <code>enable_third_party_cookie_restriction</code> <p>Enable restrictions</p> <p> TYPE: <code>bool</code> </p> <code>disable_third_party_cookie_metadata</code> <p>Skip metadata checks</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>disable_third_party_cookie_heuristics</code> <p>Disable detection logic</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to set cookie control policies</p> <p> TYPE: <code>Command[Response]</code> </p> <p>Security implications: - Affects cross-site tracking - Changes authentication behavior - Impacts embedded content</p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.stream_resource_content","title":"stream_resource_content  <code>staticmethod</code>","text":"<pre><code>stream_resource_content(request_id)\n</code></pre> <p>Enables streaming of response content.</p> <p>Useful for: - Large file downloads - Progressive loading - Memory optimization - Real-time processing</p> PARAMETER DESCRIPTION <code>request_id</code> <p>Target request identifier</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to initiate content streaming</p> <p> TYPE: <code>Command[StreamResourceContentResponse]</code> </p> <p>Best practices: - Monitor memory usage - Handle stream chunks efficiently - Consider error recovery</p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.take_response_body_for_interception_as_stream","title":"take_response_body_for_interception_as_stream  <code>staticmethod</code>","text":"<pre><code>take_response_body_for_interception_as_stream(interception_id)\n</code></pre> <p>Creates a stream for intercepted response body.</p> <p>Applications: - Large response handling - Content modification - Bandwidth optimization - Progressive processing</p> PARAMETER DESCRIPTION <code>interception_id</code> <p>Intercepted response identifier</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command returning stream handle</p> <p> TYPE: <code>Command[TakeResponseBodyForInterceptionAsStreamResponse]</code> </p> <p>Stream handling: - Supports chunked transfer - Manages memory efficiently - Enables real-time processing</p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.emulate_network_conditions","title":"emulate_network_conditions  <code>staticmethod</code>","text":"<pre><code>emulate_network_conditions(offline, latency, download_throughput, upload_throughput, connection_type=None, packet_loss=None, packet_queue_length=None, packet_reordering=None)\n</code></pre> <p>Emulates custom network conditions for realistic testing scenarios.</p> <p>Simulates various network profiles including: - Offline mode - High-latency connections - Bandwidth throttling - Unreliable network characteristics</p> PARAMETER DESCRIPTION <code>offline</code> <p>Simulate complete network disconnection</p> <p> TYPE: <code>bool</code> </p> <code>latency</code> <p>Minimum latency in milliseconds (round-trip time)</p> <p> TYPE: <code>float</code> </p> <code>download_throughput</code> <p>Max download speed (bytes/sec, -1 to disable)</p> <p> TYPE: <code>float</code> </p> <code>upload_throughput</code> <p>Max upload speed (bytes/sec, -1 to disable)</p> <p> TYPE: <code>float</code> </p> <code>connection_type</code> <p>Network connection type (cellular, wifi, etc.)</p> <p> TYPE: <code>Optional[ConnectionType]</code> DEFAULT: <code>None</code> </p> <code>packet_loss</code> <p>Simulated packet loss percentage (0-100)</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>packet_queue_length</code> <p>Network buffer size simulation</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>packet_reordering</code> <p>Enable packet order randomization</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <p>Typical use cases: - Testing progressive loading states - Validating offline-first functionality - Performance optimization under constrained networks</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to activate network emulation</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.get_security_isolation_status","title":"get_security_isolation_status  <code>staticmethod</code>","text":"<pre><code>get_security_isolation_status(frame_id=None)\n</code></pre> <p>Retrieves security isolation information.</p> <p>Provides: - CORS status - Cross-origin isolation - Security context - Frame isolation</p> PARAMETER DESCRIPTION <code>frame_id</code> <p>Optional frame to check</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command returning isolation status</p> <p> TYPE: <code>Command[GetSecurityIsolationStatusResponse]</code> </p> <p>Security aspects: - Cross-origin policies - Iframe security - Site isolation - Content protection</p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.load_network_resource","title":"load_network_resource  <code>staticmethod</code>","text":"<pre><code>load_network_resource(url, options, frame_id=None)\n</code></pre> <p>Loads a network resource with specific options.</p> <p>Features: - Custom request configuration - Resource loading control - Frame-specific loading - Error handling</p> PARAMETER DESCRIPTION <code>url</code> <p>Resource URL to load</p> <p> TYPE: <code>str</code> </p> <code>options</code> <p>Loading configuration</p> <p> TYPE: <code>LoadNetworkResourceOptions</code> </p> <code>frame_id</code> <p>Target frame context</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to load resource</p> <p> TYPE: <code>Command[LoadNetworkResourceResponse]</code> </p> <p>Usage considerations: - Respects CORS policies - Handles authentication - Manages redirects - Supports streaming</p>"},{"location":"api/commands/network/#pydoll.commands.network_commands.NetworkCommands.replay_xhr","title":"replay_xhr  <code>staticmethod</code>","text":"<pre><code>replay_xhr(request_id)\n</code></pre> <p>Replays an XHR request.</p> <p>Applications: - Request debugging - Response testing - Race condition analysis - API verification</p> PARAMETER DESCRIPTION <code>request_id</code> <p>XHR request to replay</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to replay XHR</p> <p> TYPE: <code>Command[Response]</code> </p> <p>Note: - Maintains original headers - Preserves request body - Updates timestamps - Creates new request ID</p>"},{"location":"api/commands/network/#usage","title":"Usage","text":"<p>Network commands are used for advanced scenarios like request interception and network monitoring:</p> <pre><code>from pydoll.commands.network_commands import enable, set_request_interception\nfrom pydoll.connection.connection_handler import ConnectionHandler\n\n# Enable network monitoring\nconnection = ConnectionHandler()\nawait enable(connection)\n\n# Enable request interception\nawait set_request_interception(connection, patterns=[{\"urlPattern\": \"*\"}])\n</code></pre>"},{"location":"api/commands/network/#key-functionality","title":"Key Functionality","text":"<p>The network commands module provides functions for:</p>"},{"location":"api/commands/network/#request-management","title":"Request Management","text":"<ul> <li><code>enable()</code> / <code>disable()</code> - Enable/disable network monitoring</li> <li><code>set_request_interception()</code> - Intercept and modify requests</li> <li><code>continue_intercepted_request()</code> - Continue or modify intercepted requests</li> <li><code>get_request_post_data()</code> - Get request body data</li> </ul>"},{"location":"api/commands/network/#response-handling","title":"Response Handling","text":"<ul> <li><code>get_response_body()</code> - Get response content</li> <li><code>fulfill_request()</code> - Provide custom responses</li> <li><code>fail_request()</code> - Simulate network failures</li> </ul>"},{"location":"api/commands/network/#cookie-management","title":"Cookie Management","text":"<ul> <li><code>get_cookies()</code> - Get browser cookies</li> <li><code>set_cookies()</code> - Set browser cookies</li> <li><code>delete_cookies()</code> - Delete specific cookies</li> <li><code>clear_browser_cookies()</code> - Clear all cookies</li> </ul>"},{"location":"api/commands/network/#cache-control","title":"Cache Control","text":"<ul> <li><code>clear_browser_cache()</code> - Clear browser cache</li> <li><code>set_cache_disabled()</code> - Disable browser cache</li> <li><code>get_response_body_for_interception()</code> - Get cached responses</li> </ul>"},{"location":"api/commands/network/#security-headers","title":"Security &amp; Headers","text":"<ul> <li><code>set_user_agent_override()</code> - Override user agent</li> <li><code>set_extra_http_headers()</code> - Add custom headers</li> <li><code>emulate_network_conditions()</code> - Simulate network conditions</li> </ul>"},{"location":"api/commands/network/#advanced-use-cases","title":"Advanced Use Cases","text":""},{"location":"api/commands/network/#request-interception","title":"Request Interception","text":"<pre><code># Intercept and modify requests\nawait set_request_interception(connection, patterns=[\n    {\"urlPattern\": \"*/api/*\", \"requestStage\": \"Request\"}\n])\n\n# Handle intercepted request\nasync def handle_request(request):\n    if \"api/login\" in request.url:\n        # Modify request headers\n        headers = request.headers.copy()\n        headers[\"Authorization\"] = \"Bearer token\"\n        await continue_intercepted_request(\n            connection, \n            request_id=request.request_id,\n            headers=headers\n        )\n</code></pre>"},{"location":"api/commands/network/#response-mocking","title":"Response Mocking","text":"<pre><code># Mock API responses\nawait fulfill_request(\n    connection,\n    request_id=request_id,\n    response_code=200,\n    response_headers={\"Content-Type\": \"application/json\"},\n    body='{\"status\": \"success\"}'\n)\n</code></pre> <p>Performance Impact</p> <p>Network interception can impact page loading performance. Use selectively and disable when not needed. </p>"},{"location":"api/commands/page/","title":"Page Commands","text":"<p>Page commands handle page navigation, lifecycle events, and page-level operations.</p>"},{"location":"api/commands/page/#overview","title":"Overview","text":"<p>The page commands module provides functionality for navigating between pages, managing page lifecycle, handling JavaScript execution, and controlling page behavior.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands","title":"pydoll.commands.page_commands","text":""},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands","title":"PageCommands","text":"<p>This class encapsulates the page commands of the Chrome DevTools Protocol (CDP).</p> <p>CDP's Page domain allows for interacting with browser pages, including navigation, content manipulation, and page state monitoring. These commands provide powerful capabilities for web automation, testing, and debugging.</p> <p>The commands defined in this class provide functionality for: - Navigating to URLs and managing page history - Capturing screenshots and generating PDFs - Handling JavaScript dialogs - Enabling and controlling page events - Managing download behavior - Manipulating page content and state</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.add_script_to_evaluate_on_new_document","title":"add_script_to_evaluate_on_new_document  <code>staticmethod</code>","text":"<pre><code>add_script_to_evaluate_on_new_document(source, world_name=None, include_command_line_api=None, run_immediately=None)\n</code></pre> <p>Creates a command to add a script that will be evaluated when a new document is created.</p> PARAMETER DESCRIPTION <code>source</code> <p>Script source to be evaluated when a new document is created.</p> <p> TYPE: <code>str</code> </p> <code>world_name</code> <p>If specified, creates an isolated world with the given name.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>include_command_line_api</code> <p>Whether to include command line API.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>run_immediately</code> <p>Whether to run the script immediately on existing contexts.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[AddScriptToEvaluateOnNewDocumentResponse]</code> <p>Command[AddScriptToEvaluateOnNewDocumentResponse]: Command object with the identifier of the added script.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.bring_to_front","title":"bring_to_front  <code>staticmethod</code>","text":"<pre><code>bring_to_front()\n</code></pre> <p>Brings the page to front.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.capture_screenshot","title":"capture_screenshot  <code>staticmethod</code>","text":"<pre><code>capture_screenshot(format=None, quality=None, clip=None, from_surface=None, capture_beyond_viewport=None, optimize_for_speed=None)\n</code></pre> <p>Creates a command to capture a screenshot of the current page.</p> PARAMETER DESCRIPTION <code>format</code> <p>Image compression format (jpeg, png, or webp).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>quality</code> <p>Compression quality from 0-100 (jpeg only).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>clip</code> <p>Region of the page to capture.</p> <p> TYPE: <code>Optional[Viewport]</code> DEFAULT: <code>None</code> </p> <code>from_surface</code> <p>Capture from the surface, not the view.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>capture_beyond_viewport</code> <p>Capture beyond the viewport.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>optimize_for_speed</code> <p>Optimize for speed, not for size.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[CaptureScreenshotResponse]</code> <p>Command[CaptureScreenshotResponse]: Command object with base64-encoded image data.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.close","title":"close  <code>staticmethod</code>","text":"<pre><code>close()\n</code></pre> <p>Creates a command to close the current page.</p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to close the page.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.create_isolated_world","title":"create_isolated_world  <code>staticmethod</code>","text":"<pre><code>create_isolated_world(frame_id, world_name=None, grant_universal_access=None)\n</code></pre> <p>Creates a command to create an isolated world for the given frame.</p> PARAMETER DESCRIPTION <code>frame_id</code> <p>ID of the frame in which to create the isolated world.</p> <p> TYPE: <code>str</code> </p> <code>world_name</code> <p>Name to be reported in the Execution Context.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>grant_universal_access</code> <p>Whether to grant universal access.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[CreateIsolatedWorldResponse]</code> <p>Command[CreateIsolatedWorldResponse]: Command object with the execution context ID.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.disable","title":"disable  <code>staticmethod</code>","text":"<pre><code>disable()\n</code></pre> <p>Creates a command to disable page domain notifications.</p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to disable the Page domain.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.enable","title":"enable  <code>staticmethod</code>","text":"<pre><code>enable(enable_file_chooser_opened_event=None)\n</code></pre> <p>Creates a command to enable page domain notifications.</p> PARAMETER DESCRIPTION <code>enable_file_chooser_opened_event</code> <p>Whether to emit Page.fileChooserOpened event.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to enable the Page domain.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.get_app_manifest","title":"get_app_manifest  <code>staticmethod</code>","text":"<pre><code>get_app_manifest(manifest_id=None)\n</code></pre> <p>Creates a command to get the manifest for the current document.</p> RETURNS DESCRIPTION <code>Command[GetAppManifestResponse]</code> <p>Command[GetAppManifestResponse]: Command object with manifest information.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.get_frame_tree","title":"get_frame_tree  <code>staticmethod</code>","text":"<pre><code>get_frame_tree()\n</code></pre> <p>Creates a command to get the frame tree for the current page.</p> RETURNS DESCRIPTION <code>Command[GetFrameTreeResponse]</code> <p>Command[GetFrameTreeResponse]: Command object with frame tree information.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.get_layout_metrics","title":"get_layout_metrics  <code>staticmethod</code>","text":"<pre><code>get_layout_metrics()\n</code></pre> <p>Creates a command to get layout metrics for the page.</p> RETURNS DESCRIPTION <code>Command[GetLayoutMetricsResponse]</code> <p>Command[GetLayoutMetricsResponse]: Command object with layout metrics.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.get_navigation_history","title":"get_navigation_history  <code>staticmethod</code>","text":"<pre><code>get_navigation_history()\n</code></pre> <p>Creates a command to get the navigation history for the current page.</p> RETURNS DESCRIPTION <code>Command[GetNavigationHistoryResponse]</code> <p>Command[GetNavigationHistoryResponse]: Command object with navigation history.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.handle_javascript_dialog","title":"handle_javascript_dialog  <code>staticmethod</code>","text":"<pre><code>handle_javascript_dialog(accept, prompt_text=None)\n</code></pre> <p>Creates a command to handle a JavaScript dialog.</p> PARAMETER DESCRIPTION <code>accept</code> <p>Whether to accept or dismiss the dialog.</p> <p> TYPE: <code>bool</code> </p> <code>prompt_text</code> <p>Text to enter in prompt dialogs.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to handle a JavaScript dialog.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.navigate","title":"navigate  <code>staticmethod</code>","text":"<pre><code>navigate(url, referrer=None, transition_type=None, frame_id=None, referrer_policy=None)\n</code></pre> <p>Creates a command to navigate to a specific URL.</p> PARAMETER DESCRIPTION <code>url</code> <p>URL to navigate to.</p> <p> TYPE: <code>str</code> </p> <code>referrer</code> <p>Referrer URL.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>transition_type</code> <p>Intended transition type.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>frame_id</code> <p>Frame ID to navigate.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>referrer_policy</code> <p>Referrer policy.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[NavigateResponse]</code> <p>Command[NavigateResponse]: Command object to navigate to a URL.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.navigate_to_history_entry","title":"navigate_to_history_entry  <code>staticmethod</code>","text":"<pre><code>navigate_to_history_entry(entry_id)\n</code></pre> <p>Creates a command to navigate to a specific history entry.</p> PARAMETER DESCRIPTION <code>entry_id</code> <p>ID of the history entry to navigate to.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to navigate to a history entry.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.print_to_pdf","title":"print_to_pdf  <code>staticmethod</code>","text":"<pre><code>print_to_pdf(landscape=None, display_header_footer=None, print_background=None, scale=None, paper_width=None, paper_height=None, margin_top=None, margin_bottom=None, margin_left=None, margin_right=None, page_ranges=None, header_template=None, footer_template=None, prefer_css_page_size=None, transfer_mode=None, generate_tagged_pdf=None, generate_document_outline=None)\n</code></pre> <p>Creates a command to print the current page to PDF.</p> PARAMETER DESCRIPTION <code>landscape</code> <p>Paper orientation.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>display_header_footer</code> <p>Display header and footer.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>print_background</code> <p>Print background graphics.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>scale</code> <p>Scale of the webpage rendering.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>paper_width</code> <p>Paper width in inches.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>paper_height</code> <p>Paper height in inches.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>margin_top</code> <p>Top margin in inches.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>margin_bottom</code> <p>Bottom margin in inches.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>margin_left</code> <p>Left margin in inches.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>margin_right</code> <p>Right margin in inches.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>page_ranges</code> <p>Paper ranges to print, e.g., '1-5, 8, 11-13'.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>header_template</code> <p>HTML template for the print header.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>footer_template</code> <p>HTML template for the print footer.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>prefer_css_page_size</code> <p>Whether to prefer page size as defined by CSS.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>transfer_mode</code> <p>Transfer mode.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[PrintToPDFResponse]</code> <p>Command[PrintToPDFResponse]: Command object to print the page to PDF.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.reload","title":"reload  <code>staticmethod</code>","text":"<pre><code>reload(ignore_cache=None, script_to_evaluate_on_load=None, loader_id=None)\n</code></pre> <p>Creates a command to reload the current page.</p> PARAMETER DESCRIPTION <code>ignore_cache</code> <p>If true, browser cache is ignored.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>script_to_evaluate_on_load</code> <p>Script to be injected into the page on load.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to reload the page.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.reset_navigation_history","title":"reset_navigation_history  <code>staticmethod</code>","text":"<pre><code>reset_navigation_history()\n</code></pre> <p>Creates a command to reset the navigation history.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.remove_script_to_evaluate_on_new_document","title":"remove_script_to_evaluate_on_new_document  <code>staticmethod</code>","text":"<pre><code>remove_script_to_evaluate_on_new_document(identifier)\n</code></pre> <p>Creates a command to remove a script that was added to be evaluated on new documents.</p> PARAMETER DESCRIPTION <code>identifier</code> <p>Identifier of the script to remove.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to remove a script.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.set_bypass_csp","title":"set_bypass_csp  <code>staticmethod</code>","text":"<pre><code>set_bypass_csp(enabled)\n</code></pre> <p>Creates a command to toggle bypassing page CSP.</p> PARAMETER DESCRIPTION <code>enabled</code> <p>Whether to bypass page CSP.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to toggle bypassing page CSP.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.set_document_content","title":"set_document_content  <code>staticmethod</code>","text":"<pre><code>set_document_content(frame_id, html)\n</code></pre> <p>Creates a command to set the document content of a frame.</p> PARAMETER DESCRIPTION <code>frame_id</code> <p>Frame ID to set the document content for.</p> <p> TYPE: <code>str</code> </p> <code>html</code> <p>HTML content to set.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to set the document content.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.set_intercept_file_chooser_dialog","title":"set_intercept_file_chooser_dialog  <code>staticmethod</code>","text":"<pre><code>set_intercept_file_chooser_dialog(enabled)\n</code></pre> <p>Creates a command to set whether to intercept file chooser dialogs.</p> PARAMETER DESCRIPTION <code>enabled</code> <p>Whether to intercept file chooser dialogs.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to set file chooser dialog interception.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.set_lifecycle_events_enabled","title":"set_lifecycle_events_enabled  <code>staticmethod</code>","text":"<pre><code>set_lifecycle_events_enabled(enabled)\n</code></pre> <p>Creates a command to enable/disable lifecycle events.</p> PARAMETER DESCRIPTION <code>enabled</code> <p>Whether to enable lifecycle events.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to enable/disable lifecycle events.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.stop_loading","title":"stop_loading  <code>staticmethod</code>","text":"<pre><code>stop_loading()\n</code></pre> <p>Creates a command to stop loading the page.</p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to stop loading the page.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.add_compilation_cache","title":"add_compilation_cache  <code>staticmethod</code>","text":"<pre><code>add_compilation_cache(url, data)\n</code></pre> <p>Creates a command to add a compilation cache entry.</p> <p>Experimental: This method is experimental and may be subject to change.</p> PARAMETER DESCRIPTION <code>url</code> <p>URL for which to add the compilation cache entry.</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>Base64-encoded data.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to add a compilation cache entry.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.capture_snapshot","title":"capture_snapshot  <code>staticmethod</code>","text":"<pre><code>capture_snapshot(format='mhtml')\n</code></pre> <p>Creates a command to capture a snapshot of the page.</p> <p>Experimental: This method is experimental and may be subject to change.</p> PARAMETER DESCRIPTION <code>format</code> <p>Format of the snapshot (only 'mhtml' is supported).</p> <p> TYPE: <code>Literal['mhtml']</code> DEFAULT: <code>'mhtml'</code> </p> RETURNS DESCRIPTION <code>Command[CaptureSnapshotResponse]</code> <p>Command[CaptureSnapshotResponse]: Command object to capture a snapshot.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.clear_compilation_cache","title":"clear_compilation_cache  <code>staticmethod</code>","text":"<pre><code>clear_compilation_cache()\n</code></pre> <p>Creates a command to clear the compilation cache.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.crash","title":"crash  <code>staticmethod</code>","text":"<pre><code>crash()\n</code></pre> <p>Creates a command to crash the page.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.generate_test_report","title":"generate_test_report  <code>staticmethod</code>","text":"<pre><code>generate_test_report(message, group=None)\n</code></pre> <p>Creates a command to generate a test report.</p> <p>Experimental: This method is experimental and may be subject to change.</p> PARAMETER DESCRIPTION <code>message</code> <p>Message to be displayed in the report.</p> <p> TYPE: <code>str</code> </p> <code>group</code> <p>Group label for the report.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to generate a test report.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.get_ad_script_ancestry_ids","title":"get_ad_script_ancestry_ids  <code>staticmethod</code>","text":"<pre><code>get_ad_script_ancestry_ids(frame_id)\n</code></pre> <p>Creates a command to get the ad script ancestry IDs for a given frame.</p> <p>Experimental: This method is experimental and may be subject to change.</p> PARAMETER DESCRIPTION <code>frame_id</code> <p>ID of the frame to get ad script ancestry IDs for.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command[GetAdScriptAncestryIdsResponse]</code> <p>Command[GetAdScriptAncestryIdsResponse]: Command object to get ad script ancestry IDs.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.get_app_id","title":"get_app_id  <code>staticmethod</code>","text":"<pre><code>get_app_id(app_id=None, recommended_id=None)\n</code></pre> <p>Creates a command to get the app ID.</p> <p>Experimental: This method is experimental and may be subject to change.</p> PARAMETER DESCRIPTION <code>app_id</code> <p>App ID for verification.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>recommended_id</code> <p>Recommended app ID.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[GetAppIdResponse]</code> <p>Command[GetAppIdResponse]: Command object to get the app ID.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.get_installability_errors","title":"get_installability_errors  <code>staticmethod</code>","text":"<pre><code>get_installability_errors()\n</code></pre> <p>Creates a command to get the installability errors.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.get_origin_trials","title":"get_origin_trials  <code>staticmethod</code>","text":"<pre><code>get_origin_trials(frame_id)\n</code></pre> <p>Creates a command to get origin trials for a given origin.</p> <p>Experimental: This method is experimental and may be subject to change.</p> PARAMETER DESCRIPTION <code>frame_id</code> <p>Frame ID to get trials for.</p> <p> TYPE: <code>Optional[str]</code> </p> RETURNS DESCRIPTION <code>Command[GetOriginTrialsResponse]</code> <p>Command[GetOriginTrialsResponse]: Command object to get origin trials.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.get_permissions_policy_state","title":"get_permissions_policy_state  <code>staticmethod</code>","text":"<pre><code>get_permissions_policy_state(frame_id)\n</code></pre> <p>Creates a command to get the permissions policy state.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.get_resource_content","title":"get_resource_content  <code>staticmethod</code>","text":"<pre><code>get_resource_content(frame_id, url)\n</code></pre> <p>Creates a command to get the resource content.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.get_resource_tree","title":"get_resource_tree  <code>staticmethod</code>","text":"<pre><code>get_resource_tree()\n</code></pre> <p>Creates a command to get the resource tree.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.produce_compilation_cache","title":"produce_compilation_cache  <code>staticmethod</code>","text":"<pre><code>produce_compilation_cache(scripts)\n</code></pre> <p>Creates a command to produce a compilation cache entry.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.screencast_frame_ack","title":"screencast_frame_ack  <code>staticmethod</code>","text":"<pre><code>screencast_frame_ack(session_id)\n</code></pre> <p>Creates a command to acknowledge a screencast frame.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.search_in_resource","title":"search_in_resource  <code>staticmethod</code>","text":"<pre><code>search_in_resource(frame_id, url, query, case_sensitive=None, is_regex=None)\n</code></pre> <p>Creates a command to search for a string in a resource.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.set_ad_blocking_enabled","title":"set_ad_blocking_enabled  <code>staticmethod</code>","text":"<pre><code>set_ad_blocking_enabled(enabled)\n</code></pre> <p>Creates a command to set ad blocking enabled.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.set_font_families","title":"set_font_families  <code>staticmethod</code>","text":"<pre><code>set_font_families(font_families, for_scripts)\n</code></pre> <p>Creates a command to set font families.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.set_font_sizes","title":"set_font_sizes  <code>staticmethod</code>","text":"<pre><code>set_font_sizes(font_sizes)\n</code></pre> <p>Creates a command to set font sizes.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.set_prerendering_allowed","title":"set_prerendering_allowed  <code>staticmethod</code>","text":"<pre><code>set_prerendering_allowed(allowed)\n</code></pre> <p>Creates a command to set prerendering allowed.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.set_rph_registration_mode","title":"set_rph_registration_mode  <code>staticmethod</code>","text":"<pre><code>set_rph_registration_mode(mode)\n</code></pre> <p>Creates a command to set the RPH registration mode.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.set_spc_transaction_mode","title":"set_spc_transaction_mode  <code>staticmethod</code>","text":"<pre><code>set_spc_transaction_mode(mode)\n</code></pre> <p>Creates a command to set the SPC transaction mode.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.set_web_lifecycle_state","title":"set_web_lifecycle_state  <code>staticmethod</code>","text":"<pre><code>set_web_lifecycle_state(state)\n</code></pre> <p>Creates a command to set the web lifecycle state.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.start_screencast","title":"start_screencast  <code>staticmethod</code>","text":"<pre><code>start_screencast(format, quality=None, max_width=None, max_height=None, every_nth_frame=None)\n</code></pre> <p>Creates a command to start a screencast.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.stop_screencast","title":"stop_screencast  <code>staticmethod</code>","text":"<pre><code>stop_screencast()\n</code></pre> <p>Creates a command to stop a screencast.</p>"},{"location":"api/commands/page/#pydoll.commands.page_commands.PageCommands.wait_for_debugger","title":"wait_for_debugger  <code>staticmethod</code>","text":"<pre><code>wait_for_debugger()\n</code></pre> <p>Creates a command to wait for a debugger.</p>"},{"location":"api/commands/page/#usage","title":"Usage","text":"<p>Page commands are used extensively by the <code>Tab</code> class for navigation and page management:</p> <pre><code>from pydoll.commands.page_commands import navigate, reload, enable\nfrom pydoll.connection.connection_handler import ConnectionHandler\n\n# Navigate to a URL\nconnection = ConnectionHandler()\nawait enable(connection)  # Enable page events\nawait navigate(connection, url=\"https://example.com\")\n\n# Reload the page\nawait reload(connection)\n</code></pre>"},{"location":"api/commands/page/#key-functionality","title":"Key Functionality","text":"<p>The page commands module provides functions for:</p>"},{"location":"api/commands/page/#navigation","title":"Navigation","text":"<ul> <li><code>navigate()</code> - Navigate to URLs</li> <li><code>reload()</code> - Reload current page</li> <li><code>go_back()</code> - Navigate back in history</li> <li><code>go_forward()</code> - Navigate forward in history</li> <li><code>stop_loading()</code> - Stop page loading</li> </ul>"},{"location":"api/commands/page/#page-lifecycle","title":"Page Lifecycle","text":"<ul> <li><code>enable()</code> / <code>disable()</code> - Enable/disable page events</li> <li><code>get_frame_tree()</code> - Get page frame structure</li> <li><code>get_navigation_history()</code> - Get navigation history</li> </ul>"},{"location":"api/commands/page/#content-management","title":"Content Management","text":"<ul> <li><code>get_resource_content()</code> - Get page resource content</li> <li><code>search_in_resource()</code> - Search within page resources</li> <li><code>set_document_content()</code> - Set page HTML content</li> </ul>"},{"location":"api/commands/page/#screenshots-pdf","title":"Screenshots &amp; PDF","text":"<ul> <li><code>capture_screenshot()</code> - Take page screenshots</li> <li><code>print_to_pdf()</code> - Generate PDF from page</li> <li><code>capture_snapshot()</code> - Capture page snapshots</li> </ul>"},{"location":"api/commands/page/#javascript-execution","title":"JavaScript Execution","text":"<ul> <li><code>add_script_to_evaluate_on_new_document()</code> - Add startup scripts</li> <li><code>remove_script_to_evaluate_on_new_document()</code> - Remove startup scripts</li> </ul>"},{"location":"api/commands/page/#page-settings","title":"Page Settings","text":"<ul> <li><code>set_lifecycle_events_enabled()</code> - Control lifecycle events</li> <li><code>set_ad_blocking_enabled()</code> - Enable/disable ad blocking</li> <li><code>set_bypass_csp()</code> - Bypass Content Security Policy</li> </ul>"},{"location":"api/commands/page/#advanced-features","title":"Advanced Features","text":""},{"location":"api/commands/page/#frame-management","title":"Frame Management","text":"<pre><code># Get all frames in the page\nframe_tree = await get_frame_tree(connection)\nfor frame in frame_tree.child_frames:\n    print(f\"Frame: {frame.frame.url}\")\n</code></pre>"},{"location":"api/commands/page/#resource-interception","title":"Resource Interception","text":"<pre><code># Get resource content\ncontent = await get_resource_content(\n    connection, \n    frame_id=frame_id, \n    url=\"https://example.com/script.js\"\n)\n</code></pre>"},{"location":"api/commands/page/#page-events","title":"Page Events","text":"<p>The page commands work with various page events: - <code>Page.loadEventFired</code> - Page load completed - <code>Page.domContentEventFired</code> - DOM content loaded - <code>Page.frameNavigated</code> - Frame navigation - <code>Page.frameStartedLoading</code> - Frame loading started</p> <p>Tab Class Integration</p> <p>Most page operations are available through the <code>Tab</code> class methods like <code>tab.go_to()</code>, <code>tab.reload()</code>, and <code>tab.screenshot()</code> which provide a more convenient API. </p>"},{"location":"api/commands/runtime/","title":"Runtime Commands","text":"<p>Runtime commands provide JavaScript execution capabilities and runtime environment management.</p>"},{"location":"api/commands/runtime/#overview","title":"Overview","text":"<p>The runtime commands module enables JavaScript code execution, object inspection, and runtime environment control within browser contexts.</p>"},{"location":"api/commands/runtime/#pydoll.commands.runtime_commands","title":"pydoll.commands.runtime_commands","text":""},{"location":"api/commands/runtime/#pydoll.commands.runtime_commands.RuntimeCommands","title":"RuntimeCommands","text":"<p>A class for interacting with the JavaScript runtime using Chrome DevTools Protocol.</p> <p>This class provides methods to create commands for evaluating JavaScript expressions, calling functions on JavaScript objects, and retrieving object properties through CDP.</p> ATTRIBUTE DESCRIPTION <code>EVALUATE_TEMPLATE</code> <p>Template for the Runtime.evaluate command.</p> <p> TYPE: <code>dict</code> </p> <code>CALL_FUNCTION_ON_TEMPLATE</code> <p>Template for the Runtime.callFunctionOn command.</p> <p> TYPE: <code>dict</code> </p> <code>GET_PROPERTIES</code> <p>Template for the Runtime.getProperties command.</p> <p> TYPE: <code>dict</code> </p>"},{"location":"api/commands/runtime/#pydoll.commands.runtime_commands.RuntimeCommands.add_binding","title":"add_binding  <code>staticmethod</code>","text":"<pre><code>add_binding(name, execution_context_name=None)\n</code></pre> <p>Creates a command to add a JavaScript binding.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the binding to add.</p> <p> TYPE: <code>str</code> </p> <code>execution_context_name</code> <p>Name of the execution context to bind to.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to add a JavaScript binding.</p>"},{"location":"api/commands/runtime/#pydoll.commands.runtime_commands.RuntimeCommands.await_promise","title":"await_promise  <code>staticmethod</code>","text":"<pre><code>await_promise(promise_object_id, return_by_value=None, generate_preview=None)\n</code></pre> <p>Creates a command to await a JavaScript promise and return its result.</p> PARAMETER DESCRIPTION <code>promise_object_id</code> <p>ID of the promise to await.</p> <p> TYPE: <code>str</code> </p> <code>return_by_value</code> <p>Whether to return the result by value instead of reference.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>generate_preview</code> <p>Whether to generate a preview for the result.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[AwaitPromiseResponse]</code> <p>Command[AwaitPromiseResponse]: Command object to await a promise.</p>"},{"location":"api/commands/runtime/#pydoll.commands.runtime_commands.RuntimeCommands.call_function_on","title":"call_function_on  <code>staticmethod</code>","text":"<pre><code>call_function_on(function_declaration, object_id=None, arguments=None, silent=None, return_by_value=None, generate_preview=None, user_gesture=None, await_promise=None, execution_context_id=None, object_group=None, throw_on_side_effect=None, unique_context_id=None, serialization_options=None)\n</code></pre> <p>Creates a command to call a function with a given declaration on a specific object.</p> PARAMETER DESCRIPTION <code>function_declaration</code> <p>Declaration of the function to call.</p> <p> TYPE: <code>str</code> </p> <code>object_id</code> <p>ID of the object to call the function on.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>arguments</code> <p>Arguments to pass to the function.</p> <p> TYPE: <code>Optional[list[CallArgument]]</code> DEFAULT: <code>None</code> </p> <code>silent</code> <p>Whether to silence exceptions.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>return_by_value</code> <p>Whether to return the result by value instead of reference.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>generate_preview</code> <p>Whether to generate a preview for the result.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>user_gesture</code> <p>Whether to treat the call as initiated by user gesture.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>await_promise</code> <p>Whether to await promise result.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>execution_context_id</code> <p>ID of the execution context to call the function in.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>object_group</code> <p>Symbolic group name for the result.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>throw_on_side_effect</code> <p>Whether to throw if side effect cannot be ruled out.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>unique_context_id</code> <p>Unique context ID for the function call.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>serialization_options</code> <p>Serialization options for the result.</p> <p> TYPE: <code>Optional[SerializationOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[CallFunctionOnResponse]</code> <p>Command[CallFunctionOnResponse]: Command object to call a function on an object.</p>"},{"location":"api/commands/runtime/#pydoll.commands.runtime_commands.RuntimeCommands.compile_script","title":"compile_script  <code>staticmethod</code>","text":"<pre><code>compile_script(expression, source_url=None, persist_script=None, execution_context_id=None)\n</code></pre> <p>Creates a command to compile a JavaScript expression.</p> PARAMETER DESCRIPTION <code>expression</code> <p>JavaScript expression to compile.</p> <p> TYPE: <code>str</code> </p> <code>source_url</code> <p>URL of the source file for the script.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>persist_script</code> <p>Whether to persist the compiled script.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>execution_context_id</code> <p>ID of the execution context to compile the script in.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[CompileScriptResponse]</code> <p>Command[CompileScriptResponse]: Command object to compile a script.</p>"},{"location":"api/commands/runtime/#pydoll.commands.runtime_commands.RuntimeCommands.disable","title":"disable  <code>staticmethod</code>","text":"<pre><code>disable()\n</code></pre> <p>Disables the runtime domain.</p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to disable the runtime domain.</p>"},{"location":"api/commands/runtime/#pydoll.commands.runtime_commands.RuntimeCommands.enable","title":"enable  <code>staticmethod</code>","text":"<pre><code>enable()\n</code></pre> <p>Enables the runtime domain.</p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to enable the runtime domain.</p>"},{"location":"api/commands/runtime/#pydoll.commands.runtime_commands.RuntimeCommands.evaluate","title":"evaluate  <code>staticmethod</code>","text":"<pre><code>evaluate(expression, object_group=None, include_command_line_api=None, silent=None, context_id=None, return_by_value=None, generate_preview=None, user_gesture=None, await_promise=None, throw_on_side_effect=None, timeout=None, disable_breaks=None, repl_mode=None, allow_unsafe_eval_blocked_by_csp=None, unique_context_id=None, serialization_options=None)\n</code></pre> <p>Creates a command to evaluate a JavaScript expression in the global context.</p> PARAMETER DESCRIPTION <code>expression</code> <p>JavaScript expression to evaluate.</p> <p> TYPE: <code>str</code> </p> <code>object_group</code> <p>Symbolic group name for the result.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>include_command_line_api</code> <p>Whether to include command line API.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>silent</code> <p>Whether to silence exceptions.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>context_id</code> <p>ID of the execution context to evaluate in.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>return_by_value</code> <p>Whether to return the result by value instead of reference.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>generate_preview</code> <p>Whether to generate a preview for the result.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>user_gesture</code> <p>Whether to treat evaluation as initiated by user gesture.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>await_promise</code> <p>Whether to await promise result.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>throw_on_side_effect</code> <p>Whether to throw if side effect cannot be ruled out.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>Timeout in milliseconds.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>disable_breaks</code> <p>Whether to disable breakpoints during evaluation.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>repl_mode</code> <p>Whether to execute in REPL mode.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>allow_unsafe_eval_blocked_by_csp</code> <p>Allow unsafe evaluation.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>unique_context_id</code> <p>Unique context ID for evaluation.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>serialization_options</code> <p>Serialization for the result.</p> <p> TYPE: <code>Optional[SerializationOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[EvaluateResponse]</code> <p>Command[EvaluateResponse]: Command object to evaluate JavaScript.</p>"},{"location":"api/commands/runtime/#pydoll.commands.runtime_commands.RuntimeCommands.get_properties","title":"get_properties  <code>staticmethod</code>","text":"<pre><code>get_properties(object_id, own_properties=None, accessor_properties_only=None, generate_preview=None, non_indexed_properties_only=None)\n</code></pre> <p>Creates a command to get properties of a JavaScript object.</p> PARAMETER DESCRIPTION <code>object_id</code> <p>ID of the object to get properties for.</p> <p> TYPE: <code>str</code> </p> <code>own_properties</code> <p>Whether to return only own properties.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>accessor_properties_only</code> <p>Whether to return only accessor properties.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>generate_preview</code> <p>Whether to generate previews for property values.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>non_indexed_properties_only</code> <p>Whether to return only non-indexed properties.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[GetPropertiesResponse]</code> <p>Command[GetPropertiesResponse]: Command object to get object properties.</p>"},{"location":"api/commands/runtime/#pydoll.commands.runtime_commands.RuntimeCommands.global_lexical_scope_names","title":"global_lexical_scope_names  <code>staticmethod</code>","text":"<pre><code>global_lexical_scope_names(execution_context_id=None)\n</code></pre> <p>Creates a command to retrieve names of variables from global lexical scope.</p> PARAMETER DESCRIPTION <code>execution_context_id</code> <p>ID of the execution context to get scope names from.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[GlobalLexicalScopeNamesResponse]</code> <p>Command[GlobalLexicalScopeNamesResponse]: Command object to get global lexical scope names.</p>"},{"location":"api/commands/runtime/#pydoll.commands.runtime_commands.RuntimeCommands.query_objects","title":"query_objects  <code>staticmethod</code>","text":"<pre><code>query_objects(prototype_object_id, object_group=None)\n</code></pre> <p>Creates a command to query objects with a given prototype.</p> PARAMETER DESCRIPTION <code>prototype_object_id</code> <p>ID of the prototype object.</p> <p> TYPE: <code>str</code> </p> <code>object_group</code> <p>Symbolic group name for the results.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[QueryObjectsResponse]</code> <p>Command[QueryObjectsResponse]: Command object to query objects.</p>"},{"location":"api/commands/runtime/#pydoll.commands.runtime_commands.RuntimeCommands.release_object","title":"release_object  <code>staticmethod</code>","text":"<pre><code>release_object(object_id)\n</code></pre> <p>Creates a command to release a JavaScript object.</p> PARAMETER DESCRIPTION <code>object_id</code> <p>ID of the object to release.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to release an object.</p>"},{"location":"api/commands/runtime/#pydoll.commands.runtime_commands.RuntimeCommands.release_object_group","title":"release_object_group  <code>staticmethod</code>","text":"<pre><code>release_object_group(object_group)\n</code></pre> <p>Creates a command to release all objects in a group.</p> PARAMETER DESCRIPTION <code>object_group</code> <p>Name of the object group to release.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to release an object group.</p>"},{"location":"api/commands/runtime/#pydoll.commands.runtime_commands.RuntimeCommands.remove_binding","title":"remove_binding  <code>staticmethod</code>","text":"<pre><code>remove_binding(name)\n</code></pre> <p>Creates a command to remove a JavaScript binding.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the binding to remove.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to remove a JavaScript binding.</p>"},{"location":"api/commands/runtime/#pydoll.commands.runtime_commands.RuntimeCommands.run_script","title":"run_script  <code>staticmethod</code>","text":"<pre><code>run_script(script_id, execution_context_id=None, object_group=None, silent=None, include_command_line_api=None, return_by_value=None, generate_preview=None, await_promise=None)\n</code></pre> <p>Creates a command to run a compiled script.</p> PARAMETER DESCRIPTION <code>script_id</code> <p>ID of the compiled script to run.</p> <p> TYPE: <code>str</code> </p> <code>execution_context_id</code> <p>ID of the execution context to run the script in.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>object_group</code> <p>Symbolic group name for the result.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>silent</code> <p>Whether to silence exceptions.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>include_command_line_api</code> <p>Whether to include command line API.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>return_by_value</code> <p>Whether to return the result by value instead of reference.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>generate_preview</code> <p>Whether to generate a preview for the result.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>await_promise</code> <p>Whether to await promise result.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[RunScriptResponse]</code> <p>Command[RunScriptResponse]: Command object to run a script.</p>"},{"location":"api/commands/runtime/#pydoll.commands.runtime_commands.RuntimeCommands.set_async_call_stack_depth","title":"set_async_call_stack_depth  <code>staticmethod</code>","text":"<pre><code>set_async_call_stack_depth(max_depth)\n</code></pre> <p>Creates a command to set the async call stack depth.</p> PARAMETER DESCRIPTION <code>max_depth</code> <p>Maximum depth of async call stacks.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to set async call stack depth.</p>"},{"location":"api/commands/runtime/#pydoll.commands.runtime_commands.RuntimeCommands.set_custom_object_formatter_enabled","title":"set_custom_object_formatter_enabled  <code>staticmethod</code>","text":"<pre><code>set_custom_object_formatter_enabled(enabled)\n</code></pre> <p>Creates a command to enable or disable custom object formatters.</p> PARAMETER DESCRIPTION <code>enabled</code> <p>Whether to enable custom object formatters.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to enable/disable custom object formatters.</p>"},{"location":"api/commands/runtime/#pydoll.commands.runtime_commands.RuntimeCommands.set_max_call_stack_size_to_capture","title":"set_max_call_stack_size_to_capture  <code>staticmethod</code>","text":"<pre><code>set_max_call_stack_size_to_capture(size)\n</code></pre> <p>Creates a command to set the maximum call stack size to capture.</p> PARAMETER DESCRIPTION <code>size</code> <p>Maximum call stack size to capture.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to set max call stack size.</p>"},{"location":"api/commands/runtime/#usage","title":"Usage","text":"<p>Runtime commands are used for JavaScript execution and runtime management:</p> <pre><code>from pydoll.commands.runtime_commands import evaluate, enable\nfrom pydoll.connection.connection_handler import ConnectionHandler\n\n# Enable runtime events\nconnection = ConnectionHandler()\nawait enable(connection)\n\n# Execute JavaScript\nresult = await evaluate(\n    connection, \n    expression=\"document.title\",\n    return_by_value=True\n)\nprint(result.value)  # Page title\n</code></pre>"},{"location":"api/commands/runtime/#key-functionality","title":"Key Functionality","text":"<p>The runtime commands module provides functions for:</p>"},{"location":"api/commands/runtime/#javascript-execution","title":"JavaScript Execution","text":"<ul> <li><code>evaluate()</code> - Execute JavaScript expressions</li> <li><code>call_function_on()</code> - Call functions on objects</li> <li><code>compile_script()</code> - Compile JavaScript for reuse</li> <li><code>run_script()</code> - Run compiled scripts</li> </ul>"},{"location":"api/commands/runtime/#object-management","title":"Object Management","text":"<ul> <li><code>get_properties()</code> - Get object properties</li> <li><code>release_object()</code> - Release object references</li> <li><code>release_object_group()</code> - Release object groups</li> </ul>"},{"location":"api/commands/runtime/#runtime-control","title":"Runtime Control","text":"<ul> <li><code>enable()</code> / <code>disable()</code> - Enable/disable runtime events</li> <li><code>discard_console_entries()</code> - Clear console entries</li> <li><code>set_custom_object_formatter_enabled()</code> - Enable custom formatters</li> </ul>"},{"location":"api/commands/runtime/#exception-handling","title":"Exception Handling","text":"<ul> <li><code>set_async_call_stack_depth()</code> - Set call stack depth</li> <li>Exception capture and reporting</li> <li>Error object inspection</li> </ul>"},{"location":"api/commands/runtime/#advanced-usage","title":"Advanced Usage","text":""},{"location":"api/commands/runtime/#complex-javascript-execution","title":"Complex JavaScript Execution","text":"<pre><code># Execute complex JavaScript with error handling\nscript = \"\"\"\ntry {\n    const elements = document.querySelectorAll('.item');\n    return Array.from(elements).map(el =&gt; ({\n        text: el.textContent,\n        href: el.href\n    }));\n} catch (error) {\n    return { error: error.message };\n}\n\"\"\"\n\nresult = await evaluate(\n    connection,\n    expression=script,\n    return_by_value=True,\n    await_promise=True\n)\n</code></pre>"},{"location":"api/commands/runtime/#object-inspection","title":"Object Inspection","text":"<pre><code># Get detailed object properties\nproperties = await get_properties(\n    connection,\n    object_id=object_id,\n    own_properties=True,\n    accessor_properties_only=False\n)\n\nfor prop in properties:\n    print(f\"{prop.name}: {prop.value}\")\n</code></pre>"},{"location":"api/commands/runtime/#console-integration","title":"Console Integration","text":"<p>Runtime commands integrate with browser console: - Console messages and errors - Console API method calls - Custom console formatters</p> <p>Performance Considerations</p> <p>JavaScript execution through runtime commands can be slower than native browser execution. Use judiciously for complex operations. </p>"},{"location":"api/commands/storage/","title":"Storage Commands","text":"<p>Storage commands provide comprehensive browser storage management including cookies, localStorage, sessionStorage, and IndexedDB.</p>"},{"location":"api/commands/storage/#overview","title":"Overview","text":"<p>The storage commands module enables management of all browser storage mechanisms, providing functionality for data persistence and retrieval.</p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands","title":"pydoll.commands.storage_commands","text":""},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands","title":"StorageCommands","text":"<p>A class for interacting with browser storage using Chrome DevTools Protocol (CDP).</p> <p>The Storage domain of CDP allows managing various types of browser storage, including: - Cookies - Cache Storage - IndexedDB - Web Storage (localStorage/sessionStorage) - Shared Storage - Storage Buckets - Trust Tokens - Interest Groups - Attribution Reporting</p> <p>This class provides static methods that generate CDP commands to manage these types of storage without the need for traditional webdrivers.</p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.clear_cookies","title":"clear_cookies  <code>staticmethod</code>","text":"<pre><code>clear_cookies(browser_context_id=None)\n</code></pre> <p>Generates a command to clear all browser cookies.</p> PARAMETER DESCRIPTION <code>browser_context_id</code> <p>Browser context ID (optional). Useful when working                with multiple contexts (e.g., multiple windows or tabs).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to clear all cookies.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.clear_data_for_origin","title":"clear_data_for_origin  <code>staticmethod</code>","text":"<pre><code>clear_data_for_origin(origin, storage_types)\n</code></pre> <p>Generates a command to clear storage data for a specific origin.</p> PARAMETER DESCRIPTION <code>origin</code> <p>The security origin (e.g., \"https://example.com\").</p> <p> TYPE: <code>str</code> </p> <code>storage_types</code> <p>Comma-separated list of storage types to clear.           Possible values include: \"cookies\", \"local_storage\", \"indexeddb\",           \"cache_storage\", etc. Use \"all\" to clear all types.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to clear data for the specified origin.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.clear_data_for_storage_key","title":"clear_data_for_storage_key  <code>staticmethod</code>","text":"<pre><code>clear_data_for_storage_key(storage_key, storage_types)\n</code></pre> <p>Generates a command to clear data for a specific storage key.</p> PARAMETER DESCRIPTION <code>storage_key</code> <p>The storage key for which to clear data.         Unlike origin, a storage key is a more specific identifier         that may include partition isolation.</p> <p> TYPE: <code>str</code> </p> <code>storage_types</code> <p>Comma-separated list of storage types to clear.           Possible values include: \"cookies\", \"local_storage\", \"indexeddb\",           \"cache_storage\", etc. Use \"all\" to clear all types.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to clear data for the specified storage key.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.get_cookies","title":"get_cookies  <code>staticmethod</code>","text":"<pre><code>get_cookies(browser_context_id=None)\n</code></pre> <p>Generates a command to get all browser cookies.</p> PARAMETER DESCRIPTION <code>browser_context_id</code> <p>Browser context ID (optional). Useful when working                with multiple contexts (e.g., multiple windows or tabs).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to get all cookies, which will return an array of Cookie objects.</p> <p> TYPE: <code>Command[GetCookiesResponse]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.get_storage_key_for_frame","title":"get_storage_key_for_frame  <code>staticmethod</code>","text":"<pre><code>get_storage_key_for_frame(frame_id)\n</code></pre> <p>Generates a command to get the storage key for a specific frame.</p> <p>Storage keys are used to isolate data between different origins or partitions in the browser.</p> PARAMETER DESCRIPTION <code>frame_id</code> <p>The ID of the frame for which to get the storage key.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to get the storage key for the specified frame.</p> <p> TYPE: <code>Command[GetStorageKeyForFrameResponse]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.get_usage_and_quota","title":"get_usage_and_quota  <code>staticmethod</code>","text":"<pre><code>get_usage_and_quota(origin)\n</code></pre> <p>Generates a command to get storage usage and quota information for an origin.</p> <p>Useful for monitoring or debugging storage consumption of a site.</p> PARAMETER DESCRIPTION <code>origin</code> <p>The security origin (e.g., \"https://example.com\") for which to get information.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command that will return: - usage: Storage usage in bytes - quota: Storage quota in bytes - usageBreakdown: Breakdown of usage by storage type - overrideActive: Whether there is an active quota override</p> <p> TYPE: <code>Command[GetUsageAndQuotaResponse]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.set_cookies","title":"set_cookies  <code>staticmethod</code>","text":"<pre><code>set_cookies(cookies, browser_context_id=None)\n</code></pre> <p>Generates a command to set browser cookies.</p> PARAMETER DESCRIPTION <code>cookies</code> <p>list of Cookie objects to set.</p> <p> TYPE: <code>list[CookieParam]</code> </p> <code>browser_context_id</code> <p>Browser context ID (optional). Useful when working                with multiple contexts (e.g., multiple windows or tabs).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set the specified cookies.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.set_protected_audience_k_anonymity","title":"set_protected_audience_k_anonymity  <code>staticmethod</code>","text":"<pre><code>set_protected_audience_k_anonymity(owner, name, hashes)\n</code></pre> <p>Generates a command to set K-anonymity for protected audience.</p> <p>This command is used to configure anonymity in privacy-preserving advertising systems (part of Google's Privacy Sandbox).</p> PARAMETER DESCRIPTION <code>owner</code> <p>Owner of the K-anonymity configuration.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name of the K-anonymity configuration.</p> <p> TYPE: <code>str</code> </p> <code>hashes</code> <p>list of hashes for the configuration.</p> <p> TYPE: <code>list[str]</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set protected audience K-anonymity.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.track_cache_storage_for_origin","title":"track_cache_storage_for_origin  <code>staticmethod</code>","text":"<pre><code>track_cache_storage_for_origin(origin)\n</code></pre> <p>Generates a command to register an origin to receive notifications about changes to its Cache Storage.</p> <p>Cache Storage is primarily used by Service Workers to store resources for offline use.</p> PARAMETER DESCRIPTION <code>origin</code> <p>The security origin (e.g., \"https://example.com\") to monitor.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to register monitoring of the origin's Cache Storage.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.track_cache_storage_for_storage_key","title":"track_cache_storage_for_storage_key  <code>staticmethod</code>","text":"<pre><code>track_cache_storage_for_storage_key(storage_key)\n</code></pre> <p>Generates a command to register a storage key to receive notifications about changes to its Cache Storage.</p> <p>Similar to track_cache_storage_for_origin, but uses the storage key for more precise isolation.</p> PARAMETER DESCRIPTION <code>storage_key</code> <p>The storage key to monitor.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to register monitoring of the key's Cache Storage.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.track_indexed_db_for_origin","title":"track_indexed_db_for_origin  <code>staticmethod</code>","text":"<pre><code>track_indexed_db_for_origin(origin)\n</code></pre> <p>Generates a command to register an origin to receive notifications about changes to its IndexedDB.</p> <p>IndexedDB is a NoSQL database system in the browser for storing large amounts of structured data.</p> PARAMETER DESCRIPTION <code>origin</code> <p>The security origin (e.g., \"https://example.com\") to monitor.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to register monitoring of the origin's IndexedDB.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.track_indexed_db_for_storage_key","title":"track_indexed_db_for_storage_key  <code>staticmethod</code>","text":"<pre><code>track_indexed_db_for_storage_key(storage_key)\n</code></pre> <p>Generates a command to register a storage key to receive notifications about changes to its IndexedDB.</p> <p>Similar to track_indexed_db_for_origin, but uses the storage key for more precise isolation.</p> PARAMETER DESCRIPTION <code>storage_key</code> <p>The storage key to monitor.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to register monitoring of the key's IndexedDB.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.untrack_cache_storage_for_origin","title":"untrack_cache_storage_for_origin  <code>staticmethod</code>","text":"<pre><code>untrack_cache_storage_for_origin(origin)\n</code></pre> <p>Generates a command to unregister an origin from receiving notifications about changes to its Cache Storage.</p> <p>Use this method to stop monitoring Cache Storage after using track_cache_storage_for_origin.</p> PARAMETER DESCRIPTION <code>origin</code> <p>The security origin (e.g., \"https://example.com\") to stop monitoring.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to cancel monitoring of the origin's Cache Storage.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.untrack_cache_storage_for_storage_key","title":"untrack_cache_storage_for_storage_key  <code>staticmethod</code>","text":"<pre><code>untrack_cache_storage_for_storage_key(storage_key)\n</code></pre> <p>Generates a command to unregister a storage key from receiving notifications about changes to its Cache Storage.</p> <p>Use this method to stop monitoring Cache Storage after using track_cache_storage_for_storage_key.</p> PARAMETER DESCRIPTION <code>storage_key</code> <p>The storage key to stop monitoring.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to cancel monitoring of the key's Cache Storage.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.untrack_indexed_db_for_origin","title":"untrack_indexed_db_for_origin  <code>staticmethod</code>","text":"<pre><code>untrack_indexed_db_for_origin(origin)\n</code></pre> <p>Generates a command to unregister an origin from receiving notifications about changes to its IndexedDB.</p> <p>Use this method to stop monitoring IndexedDB after using track_indexed_db_for_origin.</p> PARAMETER DESCRIPTION <code>origin</code> <p>The security origin (e.g., \"https://example.com\") to stop monitoring.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to cancel monitoring of the origin's IndexedDB.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.untrack_indexed_db_for_storage_key","title":"untrack_indexed_db_for_storage_key  <code>staticmethod</code>","text":"<pre><code>untrack_indexed_db_for_storage_key(storage_key)\n</code></pre> <p>Generates a command to unregister a storage key from receiving notifications about changes to its IndexedDB.</p> <p>Use this method to stop monitoring IndexedDB after using track_indexed_db_for_storage_key.</p> PARAMETER DESCRIPTION <code>storage_key</code> <p>The storage key to stop monitoring.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to cancel monitoring of the key's IndexedDB.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.clear_shared_storage_entries","title":"clear_shared_storage_entries  <code>staticmethod</code>","text":"<pre><code>clear_shared_storage_entries(owner_origin)\n</code></pre> <p>Generates a command to clear all Shared Storage entries for a specific origin.</p> <p>Shared Storage is an experimental API that allows cross-origin shared storage with privacy protections.</p> PARAMETER DESCRIPTION <code>owner_origin</code> <p>The owner origin of the Shared Storage to clear.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to clear the Shared Storage entries.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.clear_trust_tokens","title":"clear_trust_tokens  <code>staticmethod</code>","text":"<pre><code>clear_trust_tokens(issuer_origin)\n</code></pre> <p>Generates a command to remove all Trust Tokens issued by the specified origin.</p> <p>Trust Tokens are an experimental API for combating fraud while preserving user privacy. This command keeps other stored data, including the issuer's redemption records, intact.</p> PARAMETER DESCRIPTION <code>issuer_origin</code> <p>The issuer origin of the tokens to remove.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to clear Trust Tokens, which will return: - didDeleteTokens: True if any tokens were deleted, False otherwise.</p> <p> TYPE: <code>Command[ClearTrustTokensResponse]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.delete_shared_storage_entry","title":"delete_shared_storage_entry  <code>staticmethod</code>","text":"<pre><code>delete_shared_storage_entry(owner_origin, key)\n</code></pre> <p>Generates a command to delete a specific Shared Storage entry.</p> PARAMETER DESCRIPTION <code>owner_origin</code> <p>The owner origin of the Shared Storage.</p> <p> TYPE: <code>str</code> </p> <code>key</code> <p>The key of the entry to delete.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to delete the Shared Storage entry.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.delete_storage_bucket","title":"delete_storage_bucket  <code>staticmethod</code>","text":"<pre><code>delete_storage_bucket(bucket)\n</code></pre> <p>Generates a command to delete a Storage Bucket with the specified key and name.</p> <p>Storage Buckets are an experimental API for managing storage data with greater granularity and expiration control.</p> PARAMETER DESCRIPTION <code>bucket</code> <p>A StorageBucket object containing the storageKey and name of the bucket to delete.</p> <p> TYPE: <code>StorageBucket</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to delete the Storage Bucket.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.get_affected_urls_for_third_party_cookie_metadata","title":"get_affected_urls_for_third_party_cookie_metadata  <code>staticmethod</code>","text":"<pre><code>get_affected_urls_for_third_party_cookie_metadata(first_party_url, third_party_urls)\n</code></pre> <p>Generates a command to get the list of URLs from a page and its embedded resources that match existing grace period URL pattern rules.</p> <p>This command is useful for monitoring which URLs would be affected by the Privacy Sandbox's third-party cookie policies.</p> PARAMETER DESCRIPTION <code>first_party_url</code> <p>The URL of the page being visited (first-party).</p> <p> TYPE: <code>str</code> </p> <code>third_party_urls</code> <p>Optional list of embedded third-party resource URLs.</p> <p> TYPE: <code>list[str]</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to get URLs affected by third-party cookie metadata.</p> <p> TYPE: <code>Command[GetAffectedUrlsForThirdPartyCookieMetadataResponse]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.get_interest_group_details","title":"get_interest_group_details  <code>staticmethod</code>","text":"<pre><code>get_interest_group_details(owner_origin, name)\n</code></pre> <p>Generates a command to get details of a specific interest group.</p> <p>Interest Groups are part of the FLEDGE/Protected Audience API for privacy-preserving advertising, enabling in-browser ad auctions.</p> PARAMETER DESCRIPTION <code>owner_origin</code> <p>The owner origin of the interest group.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>The name of the interest group.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to get interest group details.</p> <p> TYPE: <code>Command[GetInterestGroupDetailsResponse]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.get_related_website_sets","title":"get_related_website_sets  <code>staticmethod</code>","text":"<pre><code>get_related_website_sets(sets)\n</code></pre> <p>Generates a command to get related website sets.</p> <p>Related Website Sets are an API that allows sites under the same entity to share some data, despite third-party cookie restrictions.</p> PARAMETER DESCRIPTION <code>sets</code> <p>list of RelatedWebsiteSet objects.</p> <p> TYPE: <code>list[RelatedWebsiteSet]</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to get related website sets.</p> <p> TYPE: <code>Command[GetRelatedWebsiteSetsResponse]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.get_shared_storage_entries","title":"get_shared_storage_entries  <code>staticmethod</code>","text":"<pre><code>get_shared_storage_entries(owner_origin)\n</code></pre> <p>Generates a command to get all Shared Storage entries for an origin.</p> PARAMETER DESCRIPTION <code>owner_origin</code> <p>The owner origin of the Shared Storage.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to get the Shared Storage entries.</p> <p> TYPE: <code>Command[GetSharedStorageEntriesResponse]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.get_shared_storage_metadata","title":"get_shared_storage_metadata  <code>staticmethod</code>","text":"<pre><code>get_shared_storage_metadata(owner_origin)\n</code></pre> <p>Generates a command to get Shared Storage metadata for an origin.</p> <p>Metadata includes information such as usage, budget, and creation time.</p> PARAMETER DESCRIPTION <code>owner_origin</code> <p>The owner origin of the Shared Storage.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to get Shared Storage metadata.</p> <p> TYPE: <code>Command[GetSharedStorageMetadataResponse]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.get_trust_tokens","title":"get_trust_tokens  <code>staticmethod</code>","text":"<pre><code>get_trust_tokens()\n</code></pre> <p>Generates a command to get all available Trust Tokens.</p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to get Trust Tokens, which will return pairs     of issuer origin and count of available tokens.</p> <p> TYPE: <code>Command[GetTrustTokensResponse]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.override_quota_for_origin","title":"override_quota_for_origin  <code>staticmethod</code>","text":"<pre><code>override_quota_for_origin(origin, quota_size=None)\n</code></pre> <p>Generates a command to override the storage quota for a specific origin.</p> <p>This command is useful for storage exhaustion testing or simulating different storage conditions.</p> PARAMETER DESCRIPTION <code>origin</code> <p>The origin for which to override the quota.</p> <p> TYPE: <code>str</code> </p> <code>quota_size</code> <p>The size of the new quota in bytes (optional).        If not specified, any existing override will be removed.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to override the origin's quota.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.reset_shared_storage_budget","title":"reset_shared_storage_budget  <code>staticmethod</code>","text":"<pre><code>reset_shared_storage_budget(owner_origin)\n</code></pre> <p>Generates a command to reset the Shared Storage budget for an origin.</p> <p>Shared Storage uses a budget system to limit the amount of operations or specific operations to preserve user privacy.</p> PARAMETER DESCRIPTION <code>owner_origin</code> <p>The owner origin of the Shared Storage.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to reset the Shared Storage budget.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.run_bounce_tracking_mitigations","title":"run_bounce_tracking_mitigations  <code>staticmethod</code>","text":"<pre><code>run_bounce_tracking_mitigations()\n</code></pre> <p>Generates a command to run bounce tracking mitigations.</p> <p>Bounce tracking is a tracking technique that involves redirecting users through intermediate URLs to establish tracking cookies. This command activates protections against this technique.</p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to run bounce tracking mitigations.</p> <p> TYPE: <code>Command[RunBounceTrackingMitigationsResponse]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.send_pending_attribution_reports","title":"send_pending_attribution_reports  <code>staticmethod</code>","text":"<pre><code>send_pending_attribution_reports()\n</code></pre> <p>Generates a command to send pending attribution reports.</p> <p>Attribution Reporting is an API that allows measuring conversions while preserving user privacy. This command forces sending reports that are waiting to be sent.</p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to send pending attribution reports.</p> <p> TYPE: <code>Command[SendPendingAttributionReportsResponse]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.set_attribution_reporting_local_testing_mode","title":"set_attribution_reporting_local_testing_mode  <code>staticmethod</code>","text":"<pre><code>set_attribution_reporting_local_testing_mode(enable)\n</code></pre> <p>Generates a command to enable or disable local testing mode for Attribution Reporting.</p> <p>Testing mode makes it easier to develop and test the Attribution Reporting API by removing restrictions like delays and rate limits that would normally apply.</p> PARAMETER DESCRIPTION <code>enable</code> <p>True to enable local testing mode, False to disable it.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set Attribution Reporting local testing mode.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.set_attribution_reporting_tracking","title":"set_attribution_reporting_tracking  <code>staticmethod</code>","text":"<pre><code>set_attribution_reporting_tracking(enable)\n</code></pre> <p>Generates a command to enable or disable Attribution Reporting tracking.</p> PARAMETER DESCRIPTION <code>enable</code> <p>True to enable tracking, False to disable it.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set Attribution Reporting tracking.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.set_interest_group_auction_tracking","title":"set_interest_group_auction_tracking  <code>staticmethod</code>","text":"<pre><code>set_interest_group_auction_tracking(enable)\n</code></pre> <p>Generates a command to enable or disable interest group auction tracking.</p> <p>Interest group auctions are part of the FLEDGE/Protected Audience API and allow for in-browser ad auctions in a privacy-preserving way.</p> PARAMETER DESCRIPTION <code>enable</code> <p>True to enable tracking, False to disable it.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set interest group auction tracking.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.set_interest_group_tracking","title":"set_interest_group_tracking  <code>staticmethod</code>","text":"<pre><code>set_interest_group_tracking(enable)\n</code></pre> <p>Generates a command to enable or disable interest group tracking.</p> PARAMETER DESCRIPTION <code>enable</code> <p>True to enable tracking, False to disable it.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set interest group tracking.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.set_shared_storage_entry","title":"set_shared_storage_entry  <code>staticmethod</code>","text":"<pre><code>set_shared_storage_entry(owner_origin, key, value, ignore_if_present=None)\n</code></pre> <p>Generates a command to set an entry in Shared Storage.</p> PARAMETER DESCRIPTION <code>owner_origin</code> <p>The owner origin of the Shared Storage.</p> <p> TYPE: <code>str</code> </p> <code>key</code> <p>The key of the entry to set.</p> <p> TYPE: <code>str</code> </p> <code>value</code> <p>The value of the entry to set.</p> <p> TYPE: <code>str</code> </p> <code>ignore_if_present</code> <p>If True, won't replace an existing entry with the same key.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set a Shared Storage entry.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.set_shared_storage_tracking","title":"set_shared_storage_tracking  <code>staticmethod</code>","text":"<pre><code>set_shared_storage_tracking(enable)\n</code></pre> <p>Generates a command to enable or disable Shared Storage tracking.</p> <p>When enabled, events related to Shared Storage usage will be emitted.</p> PARAMETER DESCRIPTION <code>enable</code> <p>True to enable tracking, False to disable it.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set Shared Storage tracking.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/storage/#pydoll.commands.storage_commands.StorageCommands.set_storage_bucket_tracking","title":"set_storage_bucket_tracking  <code>staticmethod</code>","text":"<pre><code>set_storage_bucket_tracking(storage_key, enable)\n</code></pre> <p>Generates a command to enable or disable Storage Bucket tracking.</p> <p>When enabled, events related to changes in storage buckets will be emitted.</p> PARAMETER DESCRIPTION <code>storage_key</code> <p>The storage key for which to set tracking.</p> <p> TYPE: <code>str</code> </p> <code>enable</code> <p>True to enable tracking, False to disable it.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set Storage Bucket tracking.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/storage/#usage","title":"Usage","text":"<p>Storage commands are used for managing browser storage across different mechanisms:</p> <pre><code>from pydoll.commands.storage_commands import get_cookies, set_cookies, clear_data_for_origin\nfrom pydoll.connection.connection_handler import ConnectionHandler\n\n# Get cookies for a domain\nconnection = ConnectionHandler()\ncookies = await get_cookies(connection, urls=[\"https://example.com\"])\n\n# Set a new cookie\nawait set_cookies(connection, cookies=[{\n    \"name\": \"session_id\",\n    \"value\": \"abc123\",\n    \"domain\": \"example.com\",\n    \"path\": \"/\",\n    \"httpOnly\": True,\n    \"secure\": True\n}])\n\n# Clear all storage for an origin\nawait clear_data_for_origin(\n    connection,\n    origin=\"https://example.com\",\n    storage_types=\"all\"\n)\n</code></pre>"},{"location":"api/commands/storage/#key-functionality","title":"Key Functionality","text":"<p>The storage commands module provides functions for:</p>"},{"location":"api/commands/storage/#cookie-management","title":"Cookie Management","text":"<ul> <li><code>get_cookies()</code> - Get cookies by URL or domain</li> <li><code>set_cookies()</code> - Set new cookies</li> <li><code>delete_cookies()</code> - Delete specific cookies</li> <li><code>clear_cookies()</code> - Clear all cookies</li> </ul>"},{"location":"api/commands/storage/#local-storage","title":"Local Storage","text":"<ul> <li><code>get_dom_storage_items()</code> - Get localStorage items</li> <li><code>set_dom_storage_item()</code> - Set localStorage item</li> <li><code>remove_dom_storage_item()</code> - Remove localStorage item</li> <li><code>clear_dom_storage()</code> - Clear localStorage</li> </ul>"},{"location":"api/commands/storage/#session-storage","title":"Session Storage","text":"<ul> <li>Session storage operations (similar to localStorage)</li> <li>Session-specific data management</li> <li>Tab-isolated storage</li> </ul>"},{"location":"api/commands/storage/#indexeddb","title":"IndexedDB","text":"<ul> <li><code>get_database_names()</code> - Get IndexedDB databases</li> <li><code>request_database()</code> - Access database structure</li> <li><code>request_data()</code> - Query database data</li> <li><code>clear_object_store()</code> - Clear object stores</li> </ul>"},{"location":"api/commands/storage/#cache-storage","title":"Cache Storage","text":"<ul> <li><code>request_cache_names()</code> - Get cache names</li> <li><code>request_cached_response()</code> - Get cached responses</li> <li><code>delete_cache()</code> - Delete cache entries</li> </ul>"},{"location":"api/commands/storage/#application-cache-deprecated","title":"Application Cache (Deprecated)","text":"<ul> <li>Legacy application cache support</li> <li>Manifest-based caching</li> </ul>"},{"location":"api/commands/storage/#advanced-features","title":"Advanced Features","text":""},{"location":"api/commands/storage/#bulk-operations","title":"Bulk Operations","text":"<pre><code># Clear all storage types for multiple origins\norigins = [\"https://example.com\", \"https://api.example.com\"]\nfor origin in origins:\n    await clear_data_for_origin(\n        connection,\n        origin=origin,\n        storage_types=\"cookies,local_storage,session_storage,indexeddb\"\n    )\n</code></pre>"},{"location":"api/commands/storage/#storage-quotas","title":"Storage Quotas","text":"<pre><code># Get storage quota information\nquota_info = await get_usage_and_quota(connection, origin=\"https://example.com\")\nprint(f\"Used: {quota_info.usage} bytes\")\nprint(f\"Quota: {quota_info.quota} bytes\")\n</code></pre>"},{"location":"api/commands/storage/#cross-origin-storage","title":"Cross-Origin Storage","text":"<pre><code># Manage storage across different origins\nawait set_cookies(connection, cookies=[{\n    \"name\": \"cross_site_token\",\n    \"value\": \"token123\",\n    \"domain\": \".example.com\",  # Applies to all subdomains\n    \"sameSite\": \"None\",\n    \"secure\": True\n}])\n</code></pre>"},{"location":"api/commands/storage/#storage-types","title":"Storage Types","text":"<p>The module supports various storage mechanisms:</p> Storage Type Persistence Scope Capacity Cookies Persistent Domain/Path ~4KB per cookie localStorage Persistent Origin ~5-10MB sessionStorage Session Tab ~5-10MB IndexedDB Persistent Origin Large (GB+) Cache API Persistent Origin Large <p>Privacy Considerations</p> <p>Storage operations can affect user privacy. Always handle storage data responsibly and in compliance with privacy regulations. </p>"},{"location":"api/commands/target/","title":"Target Commands","text":"<p>Target commands manage browser targets including tabs, windows, and other browsing contexts.</p>"},{"location":"api/commands/target/#overview","title":"Overview","text":"<p>The target commands module provides functionality for creating, managing, and controlling browser targets such as tabs, popup windows, and service workers.</p>"},{"location":"api/commands/target/#pydoll.commands.target_commands","title":"pydoll.commands.target_commands","text":""},{"location":"api/commands/target/#pydoll.commands.target_commands.TargetCommands","title":"TargetCommands","text":"<p>A class for managing browser targets using Chrome DevTools Protocol.</p> <p>The Target domain of CDP supports additional targets discovery and allows to attach to them. Targets can represent browser tabs, windows, frames, web workers, service workers, etc. The domain provides methods to create, discover, and control these targets.</p> <p>This class provides methods to create commands for interacting with browser targets, including creating, activating, attaching to, and closing targets through CDP commands.</p>"},{"location":"api/commands/target/#pydoll.commands.target_commands.TargetCommands.activate_target","title":"activate_target  <code>staticmethod</code>","text":"<pre><code>activate_target(target_id)\n</code></pre> <p>Generates a command to activate (focus) a target.</p> PARAMETER DESCRIPTION <code>target_id</code> <p>ID of the target to activate.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to activate the target.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/target/#pydoll.commands.target_commands.TargetCommands.attach_to_target","title":"attach_to_target  <code>staticmethod</code>","text":"<pre><code>attach_to_target(target_id, flatten=None)\n</code></pre> <p>Generates a command to attach to a target with the given ID.</p> <p>When attached to a target, you can send commands to it and receive events from it. This is essential for controlling and automating targets like browser tabs.</p> PARAMETER DESCRIPTION <code>target_id</code> <p>ID of the target to attach to.</p> <p> TYPE: <code>str</code> </p> <code>flatten</code> <p>If true, enables \"flat\" access to the session via specifying sessionId     attribute in the commands. This is recommended as the non-flattened     mode is being deprecated. See https://crbug.com/991325</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to attach to the target, which will return a sessionId.</p> <p> TYPE: <code>Command[AttachToTargetResponse]</code> </p>"},{"location":"api/commands/target/#pydoll.commands.target_commands.TargetCommands.close_target","title":"close_target  <code>staticmethod</code>","text":"<pre><code>close_target(target_id)\n</code></pre> <p>Generates a command to close a target.</p> <p>If the target is a page or a tab, it will be closed. This is equivalent to clicking the close button on a browser tab.</p> PARAMETER DESCRIPTION <code>target_id</code> <p>ID of the target to close.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to close the target, which will return a success flag.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/target/#pydoll.commands.target_commands.TargetCommands.create_browser_context","title":"create_browser_context  <code>staticmethod</code>","text":"<pre><code>create_browser_context(dispose_on_detach=None, proxy_server=None, proxy_bypass_list=None, origins_with_universal_network_access=None)\n</code></pre> <p>Generates a command to create a new empty browser context.</p> <p>A browser context is similar to an incognito profile but you can have more than one. Each context has its own set of cookies, local storage, and other browser data. This is useful for testing multiple users or isolating sessions.</p> PARAMETER DESCRIPTION <code>dispose_on_detach</code> <p>If specified, the context will be disposed when the               debugging session disconnects.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>proxy_server</code> <p>Proxy server string, similar to the one passed to --proxy-server          command line argument (e.g., \"socks5://192.168.1.100:1080\").</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>proxy_bypass_list</code> <p>Proxy bypass list, similar to the one passed to                --proxy-bypass-list command line argument                (e.g., \"*.example.com,localhost\").</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>origins_with_universal_network_access</code> <p>An optional list of origins to grant                                   unlimited cross-origin access to.                                   Parts of the URL other than those                                   constituting origin are ignored.</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to create a browser context, which will return     the ID of the created context.</p> <p> TYPE: <code>Command[CreateBrowserContextResponse]</code> </p>"},{"location":"api/commands/target/#pydoll.commands.target_commands.TargetCommands.create_target","title":"create_target  <code>staticmethod</code>","text":"<pre><code>create_target(url, left=None, top=None, width=None, height=None, window_state=None, browser_context_id=None, enable_begin_frame_control=None, new_window=None, background=None, for_tab=None, hidden=None)\n</code></pre> <p>Generates a command to create a new page (target).</p> <p>This is one of the primary methods to open a new tab or window with specific properties such as position, size, and browser context.</p> PARAMETER DESCRIPTION <code>url</code> <p>The initial URL the page will navigate to. An empty string indicates about:blank.</p> <p> TYPE: <code>str</code> </p> <code>left</code> <p>Frame left position in device-independent pixels (DIP).  Requires newWindow to be true or in headless mode.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>top</code> <p>Frame top position in DIP. Requires newWindow to be true or in headless mode.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>width</code> <p>Frame width in DIP.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>height</code> <p>Frame height in DIP.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>window_state</code> <p>Frame window state: normal, minimized, maximized, or fullscreen.          Default is normal.</p> <p> TYPE: <code>Optional[WindowState]</code> DEFAULT: <code>None</code> </p> <code>browser_context_id</code> <p>The browser context to create the page in.                If not specified, the default browser context is used.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>enable_begin_frame_control</code> <p>Whether BeginFrames for this target will be controlled                        via DevTools (headless shell only, not supported on                        MacOS yet, false by default).</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>new_window</code> <p>Whether to create a new window or tab (false by default,        not supported by headless shell).</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>background</code> <p>Whether to create the target in background or foreground        (false by default, not supported by headless shell).</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>for_tab</code> <p>Whether to create the target of type \"tab\".</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>hidden</code> <p>Whether to create a hidden target. The hidden target is observable via    protocol, but not present in the tab UI strip. Cannot be created with    forTab:true, newWindow:true or background:false. The life-time of the    tab is limited to the life-time of the session.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to create a target, which will return the ID of the created target.</p> <p> TYPE: <code>Command[CreateTargetResponse]</code> </p>"},{"location":"api/commands/target/#pydoll.commands.target_commands.TargetCommands.detach_from_target","title":"detach_from_target  <code>staticmethod</code>","text":"<pre><code>detach_from_target(session_id=None)\n</code></pre> <p>Generates a command to detach a session from its target.</p> <p>After detaching, you will no longer receive events from the target and cannot send commands to it.</p> PARAMETER DESCRIPTION <code>session_id</code> <p>Session ID to detach. If not specified, detaches all sessions.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to detach from the target.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/target/#pydoll.commands.target_commands.TargetCommands.dispose_browser_context","title":"dispose_browser_context  <code>staticmethod</code>","text":"<pre><code>dispose_browser_context(browser_context_id)\n</code></pre> <p>Generates a command to delete a browser context.</p> <p>All pages belonging to the browser context will be closed without calling their beforeunload hooks. This is similar to closing an incognito profile.</p> PARAMETER DESCRIPTION <code>browser_context_id</code> <p>The ID of the browser context to dispose.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to dispose the browser context.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/target/#pydoll.commands.target_commands.TargetCommands.get_browser_contexts","title":"get_browser_contexts  <code>staticmethod</code>","text":"<pre><code>get_browser_contexts()\n</code></pre> <p>Generates a command to get all browser contexts created with createBrowserContext.</p> <p>This is useful for obtaining a list of all available contexts for managing multiple isolated browser sessions.</p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to get all browser contexts, which will return     an array of browser context IDs.</p> <p> TYPE: <code>Command[GetBrowserContextsResponse]</code> </p>"},{"location":"api/commands/target/#pydoll.commands.target_commands.TargetCommands.get_targets","title":"get_targets  <code>staticmethod</code>","text":"<pre><code>get_targets(filter=None)\n</code></pre> <p>Generates a command to retrieve a list of available targets.</p> <p>Targets include tabs, extensions, web workers, and other attachable entities in the browser. This is useful for discovering what targets exist before attaching to them.</p> PARAMETER DESCRIPTION <code>filter</code> <p>Only targets matching the filter will be reported. If filter is not    specified and target discovery is currently enabled, a filter used for    target discovery is used for consistency.</p> <p> TYPE: <code>Optional[list]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to get targets, which will return a list of     TargetInfo objects with details about each target.</p> <p> TYPE: <code>Command[GetTargetsResponse]</code> </p>"},{"location":"api/commands/target/#pydoll.commands.target_commands.TargetCommands.set_auto_attach","title":"set_auto_attach  <code>staticmethod</code>","text":"<pre><code>set_auto_attach(auto_attach, wait_for_debugger_on_start=None, flatten=None, filter=None)\n</code></pre> <p>Generates a command to control whether to automatically attach to new targets.</p> <p>This method controls whether to automatically attach to new targets which are considered to be directly related to the current one (for example, iframes or workers). When turned on, it also attaches to all existing related targets. When turned off, it automatically detaches from all currently attached targets.</p> PARAMETER DESCRIPTION <code>auto_attach</code> <p>Whether to auto-attach to related targets.</p> <p> TYPE: <code>bool</code> </p> <code>wait_for_debugger_on_start</code> <p>Whether to pause new targets when attaching to them.                        Use Runtime.runIfWaitingForDebugger to run paused targets.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>flatten</code> <p>Enables \"flat\" access to the session via specifying sessionId attribute     in the commands. This mode is being preferred, and non-flattened mode     is being deprecated (see crbug.com/991325).</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>filter</code> <p>Only targets matching filter will be attached.</p> <p> TYPE: <code>Optional[list]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set auto-attach behavior.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/target/#pydoll.commands.target_commands.TargetCommands.set_discover_targets","title":"set_discover_targets  <code>staticmethod</code>","text":"<pre><code>set_discover_targets(discover, filter=None)\n</code></pre> <p>Generates a command to control target discovery.</p> <p>This method controls whether to discover available targets and notify via targetCreated/targetInfoChanged/targetDestroyed events. Target discovery is useful for monitoring when new tabs, workers, or other targets are created or destroyed.</p> PARAMETER DESCRIPTION <code>discover</code> <p>Whether to discover available targets.</p> <p> TYPE: <code>bool</code> </p> <code>filter</code> <p>Only targets matching filter will be discovered. If discover is false,    filter must be omitted or empty.</p> <p> TYPE: <code>Optional[list]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set target discovery.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/target/#pydoll.commands.target_commands.TargetCommands.attach_to_browser_target","title":"attach_to_browser_target  <code>staticmethod</code>","text":"<pre><code>attach_to_browser_target(session_id)\n</code></pre> <p>Generates a command to attach to the browser target.</p> <p>This is an experimental method that attaches to the browser target, only using flat sessionId mode. The browser target is a special target that represents the browser itself rather than a page or other content.</p> PARAMETER DESCRIPTION <code>session_id</code> <p>ID of the session to attach to the browser target.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to attach to the browser target,     which will return a new session ID.</p> <p> TYPE: <code>Command[AttachToBrowserTargetResponse]</code> </p>"},{"location":"api/commands/target/#pydoll.commands.target_commands.TargetCommands.get_target_info","title":"get_target_info  <code>staticmethod</code>","text":"<pre><code>get_target_info(target_id)\n</code></pre> <p>Generates a command to get information about a specific target.</p> <p>This experimental method returns detailed information about a target, such as its type, URL, title, and other properties.</p> PARAMETER DESCRIPTION <code>target_id</code> <p>ID of the target to get information about.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to get target information, which will return     a TargetInfo object with details about the target.</p> <p> TYPE: <code>Command[GetTargetInfoResponse]</code> </p>"},{"location":"api/commands/target/#pydoll.commands.target_commands.TargetCommands.set_remote_locations","title":"set_remote_locations  <code>staticmethod</code>","text":"<pre><code>set_remote_locations(locations)\n</code></pre> <p>Generates a command to enable target discovery for specified remote locations.</p> <p>This experimental method enables target discovery for remote locations when setDiscoverTargets was set to true. This is useful for discovering targets on remote devices or in different browser instances.</p> PARAMETER DESCRIPTION <code>locations</code> <p>list of remote locations, each containing a host and port.</p> <p> TYPE: <code>list[RemoteLocation]</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set remote locations for target discovery.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/commands/target/#usage","title":"Usage","text":"<p>Target commands are used internally by browser classes to manage tabs and windows:</p> <pre><code>from pydoll.commands.target_commands import get_targets, create_target, close_target\nfrom pydoll.connection.connection_handler import ConnectionHandler\n\n# Get all browser targets\nconnection = ConnectionHandler()\ntargets = await get_targets(connection)\n\n# Create a new tab\nnew_target = await create_target(connection, url=\"https://example.com\")\n\n# Close a target\nawait close_target(connection, target_id=new_target.target_id)\n</code></pre>"},{"location":"api/commands/target/#key-functionality","title":"Key Functionality","text":"<p>The target commands module provides functions for:</p>"},{"location":"api/commands/target/#target-management","title":"Target Management","text":"<ul> <li><code>get_targets()</code> - List all browser targets</li> <li><code>create_target()</code> - Create new tabs or windows</li> <li><code>close_target()</code> - Close specific targets</li> <li><code>activate_target()</code> - Bring target to foreground</li> </ul>"},{"location":"api/commands/target/#target-information","title":"Target Information","text":"<ul> <li><code>get_target_info()</code> - Get detailed target information</li> <li>Target types: page, background_page, service_worker, browser</li> <li>Target states: attached, detached, crashed</li> </ul>"},{"location":"api/commands/target/#session-management","title":"Session Management","text":"<ul> <li><code>attach_to_target()</code> - Attach to target for control</li> <li><code>detach_from_target()</code> - Detach from target</li> <li><code>send_message_to_target()</code> - Send commands to targets</li> </ul>"},{"location":"api/commands/target/#browser-context","title":"Browser Context","text":"<ul> <li><code>create_browser_context()</code> - Create isolated browser context</li> <li><code>dispose_browser_context()</code> - Remove browser context</li> <li><code>get_browser_contexts()</code> - List browser contexts</li> </ul>"},{"location":"api/commands/target/#target-types","title":"Target Types","text":"<p>Different types of targets can be managed:</p>"},{"location":"api/commands/target/#page-targets","title":"Page Targets","text":"<pre><code># Create a new tab\npage_target = await create_target(\n    connection,\n    url=\"https://example.com\",\n    width=1920,\n    height=1080,\n    browser_context_id=None  # Default context\n)\n</code></pre>"},{"location":"api/commands/target/#popup-windows","title":"Popup Windows","text":"<pre><code># Create a popup window\npopup_target = await create_target(\n    connection,\n    url=\"https://popup.example.com\",\n    width=800,\n    height=600,\n    new_window=True\n)\n</code></pre>"},{"location":"api/commands/target/#incognito-contexts","title":"Incognito Contexts","text":"<pre><code># Create incognito browser context\nincognito_context = await create_browser_context(connection)\n\n# Create tab in incognito context\nincognito_tab = await create_target(\n    connection,\n    url=\"https://private.example.com\",\n    browser_context_id=incognito_context.browser_context_id\n)\n</code></pre>"},{"location":"api/commands/target/#advanced-features","title":"Advanced Features","text":""},{"location":"api/commands/target/#target-events","title":"Target Events","text":"<p>Target commands work with various target events: - <code>Target.targetCreated</code> - New target created - <code>Target.targetDestroyed</code> - Target closed - <code>Target.targetInfoChanged</code> - Target information updated - <code>Target.targetCrashed</code> - Target crashed</p>"},{"location":"api/commands/target/#multi-target-coordination","title":"Multi-Target Coordination","text":"<pre><code># Manage multiple tabs\ntargets = await get_targets(connection)\npage_targets = [t for t in targets if t.type == \"page\"]\n\nfor target in page_targets:\n    # Perform operations on each tab\n    await activate_target(connection, target_id=target.target_id)\n    # ... do work in this tab\n</code></pre>"},{"location":"api/commands/target/#target-isolation","title":"Target Isolation","text":"<pre><code># Create isolated browser context for testing\ntest_context = await create_browser_context(connection)\n\n# All targets in this context are isolated\ntest_tab1 = await create_target(\n    connection, \n    url=\"https://test1.com\",\n    browser_context_id=test_context.browser_context_id\n)\n\ntest_tab2 = await create_target(\n    connection,\n    url=\"https://test2.com\", \n    browser_context_id=test_context.browser_context_id\n)\n</code></pre> <p>Browser Integration</p> <p>Target commands are primarily used internally by the <code>Chrome</code> and <code>Edge</code> browser classes. The high-level browser APIs provide more convenient methods for tab management. </p>"},{"location":"api/connection/connection/","title":"Connection Handler","text":""},{"location":"api/connection/connection/#pydoll.connection.connection_handler.ConnectionHandler","title":"pydoll.connection.connection_handler.ConnectionHandler","text":"<pre><code>ConnectionHandler(connection_port, page_id=None, ws_address_resolver=get_browser_ws_address, ws_connector=connect)\n</code></pre> <p>WebSocket connection manager for Chrome DevTools Protocol endpoints.</p> <p>Handles connection lifecycle, command execution, and event subscription for both browser-level and page-level CDP endpoints.</p> <p>Initialize connection handler.</p> PARAMETER DESCRIPTION <code>connection_port</code> <p>Browser's debugging server port.</p> <p> TYPE: <code>int</code> </p> <code>page_id</code> <p>Target page ID. If None, connects to browser-level endpoint.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>ws_address_resolver</code> <p>Function to resolve WebSocket URL from port.</p> <p> TYPE: <code>Callable[[int], Coroutine[Any, Any, str]]</code> DEFAULT: <code>get_browser_ws_address</code> </p> <code>ws_connector</code> <p>WebSocket connection factory (mainly for testing).</p> <p> TYPE: <code>type[connect]</code> DEFAULT: <code>connect</code> </p>"},{"location":"api/connection/connection/#pydoll.connection.connection_handler.ConnectionHandler.network_logs","title":"network_logs  <code>property</code>","text":"<pre><code>network_logs\n</code></pre> <p>Access captured network request and response logs.</p>"},{"location":"api/connection/connection/#pydoll.connection.connection_handler.ConnectionHandler.dialog","title":"dialog  <code>property</code>","text":"<pre><code>dialog\n</code></pre> <p>Access currently active JavaScript dialog information.</p>"},{"location":"api/connection/connection/#pydoll.connection.connection_handler.ConnectionHandler.ping","title":"ping  <code>async</code>","text":"<pre><code>ping()\n</code></pre> <p>Test if WebSocket connection is active and responsive.</p>"},{"location":"api/connection/connection/#pydoll.connection.connection_handler.ConnectionHandler.execute_command","title":"execute_command  <code>async</code>","text":"<pre><code>execute_command(command, timeout=10)\n</code></pre> <p>Send CDP command and await response.</p> PARAMETER DESCRIPTION <code>command</code> <p>CDP command to send.</p> <p> TYPE: <code>Command[T]</code> </p> <code>timeout</code> <p>Maximum seconds to wait for response.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> RETURNS DESCRIPTION <code>T</code> <p>Parsed response object matching command's expected type.</p> RAISES DESCRIPTION <code>CommandExecutionTimeout</code> <p>If browser doesn't respond within timeout.</p> <code>WebSocketConnectionClosed</code> <p>If connection closes during execution.</p>"},{"location":"api/connection/connection/#pydoll.connection.connection_handler.ConnectionHandler.register_callback","title":"register_callback  <code>async</code>","text":"<pre><code>register_callback(event_name, callback, temporary=False)\n</code></pre> <p>Register event listener for CDP events.</p> PARAMETER DESCRIPTION <code>event_name</code> <p>CDP event name (e.g., 'Page.loadEventFired').</p> <p> TYPE: <code>str</code> </p> <code>callback</code> <p>Async function called when event occurs.</p> <p> TYPE: <code>Callable[[dict], Awaitable[None]]</code> </p> <code>temporary</code> <p>If True, callback removed after first trigger.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Callback ID for later removal.</p> Note <p>Corresponding CDP domain must be enabled before events fire.</p>"},{"location":"api/connection/connection/#pydoll.connection.connection_handler.ConnectionHandler.remove_callback","title":"remove_callback  <code>async</code>","text":"<pre><code>remove_callback(callback_id)\n</code></pre> <p>Remove registered event callback by ID.</p>"},{"location":"api/connection/connection/#pydoll.connection.connection_handler.ConnectionHandler.clear_callbacks","title":"clear_callbacks  <code>async</code>","text":"<pre><code>clear_callbacks()\n</code></pre> <p>Remove all registered event callbacks.</p>"},{"location":"api/connection/connection/#pydoll.connection.connection_handler.ConnectionHandler.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close WebSocket connection and release resources.</p>"},{"location":"api/connection/managers/","title":"Connection Managers","text":""},{"location":"api/connection/managers/#commandsmanager","title":"CommandsManager","text":""},{"location":"api/connection/managers/#pydoll.connection.managers.commands_manager.CommandsManager","title":"pydoll.connection.managers.commands_manager.CommandsManager","text":"<pre><code>CommandsManager()\n</code></pre> <p>Manages command lifecycle and ID assignment for CDP commands.</p> <p>Handles command future creation, ID generation, and response resolution for asynchronous command execution.</p> <p>Initialize command manager with empty state.</p>"},{"location":"api/connection/managers/#pydoll.connection.managers.commands_manager.CommandsManager.create_command_future","title":"create_command_future","text":"<pre><code>create_command_future(command)\n</code></pre> <p>Create future for command and assign unique ID.</p> PARAMETER DESCRIPTION <code>command</code> <p>Command to prepare for execution.</p> <p> TYPE: <code>Command</code> </p> RETURNS DESCRIPTION <code>Future</code> <p>Future that resolves when command completes.</p>"},{"location":"api/connection/managers/#pydoll.connection.managers.commands_manager.CommandsManager.resolve_command","title":"resolve_command","text":"<pre><code>resolve_command(response_id, result)\n</code></pre> <p>Resolve pending command with its result.</p>"},{"location":"api/connection/managers/#pydoll.connection.managers.commands_manager.CommandsManager.remove_pending_command","title":"remove_pending_command","text":"<pre><code>remove_pending_command(command_id)\n</code></pre> <p>Remove pending command without resolving (for timeouts/cancellations).</p>"},{"location":"api/connection/managers/#eventsmanager","title":"EventsManager","text":""},{"location":"api/connection/managers/#pydoll.connection.managers.events_manager.EventsManager","title":"pydoll.connection.managers.events_manager.EventsManager","text":"<pre><code>EventsManager()\n</code></pre> <p>Manages event callbacks, processing, and network logs.</p> <p>Handles event callback registration, triggering, and maintains state for network logs and dialog information.</p> <p>Initialize events manager with empty state.</p>"},{"location":"api/connection/managers/#pydoll.connection.managers.events_manager.EventsManager.network_logs","title":"network_logs  <code>instance-attribute</code>","text":"<pre><code>network_logs = []\n</code></pre>"},{"location":"api/connection/managers/#pydoll.connection.managers.events_manager.EventsManager.dialog","title":"dialog  <code>instance-attribute</code>","text":"<pre><code>dialog = JavascriptDialogOpeningEvent(method='')\n</code></pre>"},{"location":"api/connection/managers/#pydoll.connection.managers.events_manager.EventsManager.register_callback","title":"register_callback","text":"<pre><code>register_callback(event_name, callback, temporary=False)\n</code></pre> <p>Register callback for specific event type.</p> PARAMETER DESCRIPTION <code>event_name</code> <p>Event name to listen for.</p> <p> TYPE: <code>str</code> </p> <code>callback</code> <p>Function called when event occurs.</p> <p> TYPE: <code>Callable[[dict], Any]</code> </p> <code>temporary</code> <p>If True, callback removed after first trigger.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Callback ID for later removal.</p>"},{"location":"api/connection/managers/#pydoll.connection.managers.events_manager.EventsManager.remove_callback","title":"remove_callback","text":"<pre><code>remove_callback(callback_id)\n</code></pre> <p>Remove callback by ID.</p>"},{"location":"api/connection/managers/#pydoll.connection.managers.events_manager.EventsManager.clear_callbacks","title":"clear_callbacks","text":"<pre><code>clear_callbacks()\n</code></pre> <p>Remove all registered callbacks.</p>"},{"location":"api/connection/managers/#pydoll.connection.managers.events_manager.EventsManager.process_event","title":"process_event  <code>async</code>","text":"<pre><code>process_event(event_data)\n</code></pre> <p>Process received event and trigger callbacks.</p> <p>Handles special events (network requests, dialogs) and updates internal state before triggering registered callbacks.</p>"},{"location":"api/core/constants/","title":"Constants","text":"<p>This section documents all constants, enums, and configuration values used throughout Pydoll.</p>"},{"location":"api/core/constants/#pydoll.constants","title":"pydoll.constants","text":""},{"location":"api/core/constants/#pydoll.constants.By","title":"By","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.By.CSS_SELECTOR","title":"CSS_SELECTOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CSS_SELECTOR = 'css'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.By.XPATH","title":"XPATH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>XPATH = 'xpath'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.By.CLASS_NAME","title":"CLASS_NAME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CLASS_NAME = 'class_name'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.By.ID","title":"ID  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ID = 'id'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.By.TAG_NAME","title":"TAG_NAME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TAG_NAME = 'tag_name'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.By.NAME","title":"NAME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NAME = 'name'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Scripts","title":"Scripts","text":""},{"location":"api/core/constants/#pydoll.constants.Scripts.ELEMENT_VISIBLE","title":"ELEMENT_VISIBLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ELEMENT_VISIBLE = \"\\n    function() {\\n        const rect = this.getBoundingClientRect();\\n        return (\\n            rect.width &gt; 0 &amp;&amp; rect.height &gt; 0\\n            &amp;&amp; getComputedStyle(this).visibility !== 'hidden'\\n            &amp;&amp; getComputedStyle(this).display !== 'none'\\n        )\\n    }\\n    \"\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Scripts.ELEMENT_ON_TOP","title":"ELEMENT_ON_TOP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ELEMENT_ON_TOP = '\\n    function() {\\n        const rect = this.getBoundingClientRect();\\n        const elementFromPoint = document.elementFromPoint(\\n            rect.x + rect.width / 2,\\n            rect.y + rect.height / 2\\n        );\\n        return elementFromPoint === this;\\n    }\\n    '\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Scripts.CLICK","title":"CLICK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CLICK = \"\\n    function(){\\n        clicked = false;\\n        this.addEventListener('click', function(){\\n            clicked = true;\\n        });\\n        this.click();\\n        return clicked;\\n    }\\n    \"\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Scripts.CLICK_OPTION_TAG","title":"CLICK_OPTION_TAG  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CLICK_OPTION_TAG = '\\n    document.querySelector(\\'option[value=\"{self.value}\"]\\').selected = true;\\n    var selectParentXpath = (\\n        \\'//option[@value=\"{self.value}\"]//ancestor::select\\'\\n    );\\n    var select = document.evaluate(\\n        selectParentXpath,\\n        document,\\n        null,\\n        XPathResult.FIRST_ORDERED_NODE_TYPE,\\n        null\\n    ).singleNodeValue;\\n    var event = new Event(\\'change\\', { bubbles: true });\\n    select.dispatchEvent(event);\\n    '\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Scripts.BOUNDS","title":"BOUNDS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BOUNDS = '\\n    function() {\\n        return JSON.stringify(this.getBoundingClientRect());\\n    }\\n    '\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Scripts.FIND_RELATIVE_XPATH_ELEMENT","title":"FIND_RELATIVE_XPATH_ELEMENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FIND_RELATIVE_XPATH_ELEMENT = '\\n        function() {\\n            return document.evaluate(\\n                \"{escaped_value}\", this, null,\\n                XPathResult.FIRST_ORDERED_NODE_TYPE, null\\n            ).singleNodeValue;\\n        }\\n    '\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Scripts.FIND_XPATH_ELEMENT","title":"FIND_XPATH_ELEMENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FIND_XPATH_ELEMENT = '\\n        var element = document.evaluate(\\n            \"{escaped_value}\", document, null,\\n            XPathResult.FIRST_ORDERED_NODE_TYPE, null\\n        ).singleNodeValue;\\n        element;\\n    '\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Scripts.FIND_RELATIVE_XPATH_ELEMENTS","title":"FIND_RELATIVE_XPATH_ELEMENTS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FIND_RELATIVE_XPATH_ELEMENTS = '\\n        function() {\\n            var elements = document.evaluate(\\n                \"{escaped_value}\", this, null,\\n                XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null\\n            );\\n            var results = [];\\n            for (var i = 0; i &lt; elements.snapshotLength; i++) {\\n                results.push(elements.snapshotItem(i));\\n            }\\n            return results;\\n        }\\n    '\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Scripts.FIND_XPATH_ELEMENTS","title":"FIND_XPATH_ELEMENTS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FIND_XPATH_ELEMENTS = '\\n        var elements = document.evaluate(\\n            \"{escaped_value}\", document, null,\\n            XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null\\n        );\\n        var results = [];\\n        for (var i = 0; i &lt; elements.snapshotLength; i++) {\\n            results.push(elements.snapshotItem(i));\\n        }\\n        results;\\n    '\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Scripts.QUERY_SELECTOR","title":"QUERY_SELECTOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QUERY_SELECTOR = 'document.querySelector(\"{selector}\");'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Scripts.RELATIVE_QUERY_SELECTOR","title":"RELATIVE_QUERY_SELECTOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RELATIVE_QUERY_SELECTOR = '\\n        function() {\\n            return this.querySelector(\"{selector}\");\\n        }\\n    '\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Scripts.QUERY_SELECTOR_ALL","title":"QUERY_SELECTOR_ALL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QUERY_SELECTOR_ALL = 'document.querySelectorAll(\"{selector}\");'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Scripts.RELATIVE_QUERY_SELECTOR_ALL","title":"RELATIVE_QUERY_SELECTOR_ALL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RELATIVE_QUERY_SELECTOR_ALL = '\\n        function() {\\n            return this.querySelectorAll(\"{selector}\");\\n        }\\n    '\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key","title":"Key","text":"<p>               Bases: <code>tuple[str, int]</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.Key.BACKSPACE","title":"BACKSPACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BACKSPACE = ('Backspace', 8)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.TAB","title":"TAB  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TAB = ('Tab', 9)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.ENTER","title":"ENTER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ENTER = ('Enter', 13)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.SHIFT","title":"SHIFT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SHIFT = ('Shift', 16)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.CONTROL","title":"CONTROL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CONTROL = ('Control', 17)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.ALT","title":"ALT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ALT = ('Alt', 18)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.PAUSE","title":"PAUSE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PAUSE = ('Pause', 19)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.CAPSLOCK","title":"CAPSLOCK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CAPSLOCK = ('CapsLock', 20)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.ESCAPE","title":"ESCAPE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ESCAPE = ('Escape', 27)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.SPACE","title":"SPACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SPACE = ('Space', 32)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.PAGEUP","title":"PAGEUP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PAGEUP = ('PageUp', 33)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.PAGEDOWN","title":"PAGEDOWN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PAGEDOWN = ('PageDown', 34)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.END","title":"END  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>END = ('End', 35)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.HOME","title":"HOME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HOME = ('Home', 36)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.ARROWLEFT","title":"ARROWLEFT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ARROWLEFT = ('ArrowLeft', 37)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.ARROWUP","title":"ARROWUP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ARROWUP = ('ArrowUp', 38)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.ARROWRIGHT","title":"ARROWRIGHT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ARROWRIGHT = ('ArrowRight', 39)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.ARROWDOWN","title":"ARROWDOWN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ARROWDOWN = ('ArrowDown', 40)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.PRINTSCREEN","title":"PRINTSCREEN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PRINTSCREEN = ('PrintScreen', 44)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.INSERT","title":"INSERT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INSERT = ('Insert', 45)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.DELETE","title":"DELETE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DELETE = ('Delete', 46)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.META","title":"META  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>META = ('Meta', 91)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.METARIGHT","title":"METARIGHT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>METARIGHT = ('MetaRight', 92)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.CONTEXTMENU","title":"CONTEXTMENU  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CONTEXTMENU = ('ContextMenu', 93)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.NUMLOCK","title":"NUMLOCK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NUMLOCK = ('NumLock', 144)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.SCROLLLOCK","title":"SCROLLLOCK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SCROLLLOCK = ('ScrollLock', 145)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.F1","title":"F1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>F1 = ('F1', 112)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.F2","title":"F2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>F2 = ('F2', 113)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.F3","title":"F3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>F3 = ('F3', 114)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.F4","title":"F4  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>F4 = ('F4', 115)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.F5","title":"F5  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>F5 = ('F5', 116)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.F6","title":"F6  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>F6 = ('F6', 117)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.F7","title":"F7  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>F7 = ('F7', 118)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.F8","title":"F8  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>F8 = ('F8', 119)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.F9","title":"F9  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>F9 = ('F9', 120)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.F10","title":"F10  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>F10 = ('F10', 121)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.F11","title":"F11  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>F11 = ('F11', 122)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.F12","title":"F12  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>F12 = ('F12', 123)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.SEMICOLON","title":"SEMICOLON  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SEMICOLON = ('Semicolon', 186)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.EQUALSIGN","title":"EQUALSIGN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EQUALSIGN = ('EqualSign', 187)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.COMMA","title":"COMMA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>COMMA = ('Comma', 188)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.MINUS","title":"MINUS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MINUS = ('Minus', 189)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.PERIOD","title":"PERIOD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PERIOD = ('Period', 190)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.SLASH","title":"SLASH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SLASH = ('Slash', 191)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.GRAVEACCENT","title":"GRAVEACCENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GRAVEACCENT = ('GraveAccent', 192)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.BRACKETLEFT","title":"BRACKETLEFT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BRACKETLEFT = ('BracketLeft', 219)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.BACKSLASH","title":"BACKSLASH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BACKSLASH = ('Backslash', 220)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.BRACKETRIGHT","title":"BRACKETRIGHT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BRACKETRIGHT = ('BracketRight', 221)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.Key.QUOTE","title":"QUOTE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QUOTE = ('Quote', 222)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.BrowserType","title":"BrowserType","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.BrowserType.CHROME","title":"CHROME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHROME = auto()\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.BrowserType.EDGE","title":"EDGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EDGE = auto()\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.WindowState","title":"WindowState","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Possible states for a browser window.</p>"},{"location":"api/core/constants/#pydoll.constants.WindowState.MAXIMIZED","title":"MAXIMIZED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAXIMIZED = 'maximized'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.WindowState.MINIMIZED","title":"MINIMIZED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MINIMIZED = 'minimized'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.WindowState.NORMAL","title":"NORMAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NORMAL = 'normal'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DownloadBehavior","title":"DownloadBehavior","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Possible behaviors for download handling.</p>"},{"location":"api/core/constants/#pydoll.constants.DownloadBehavior.ALLOW","title":"ALLOW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ALLOW = 'allow'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DownloadBehavior.DENY","title":"DENY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DENY = 'deny'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DownloadBehavior.ALLOW_AND_NAME","title":"ALLOW_AND_NAME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ALLOW_AND_NAME = 'allowAndName'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DownloadBehavior.DEFAULT","title":"DEFAULT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFAULT = 'default'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType","title":"PermissionType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Browser permission types as defined in the Chrome DevTools Protocol.</p>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.AR","title":"AR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AR = 'ar'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.AUDIO_CAPTURE","title":"AUDIO_CAPTURE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AUDIO_CAPTURE = 'audioCapture'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.AUTOMATIC_FULLSCREEN","title":"AUTOMATIC_FULLSCREEN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AUTOMATIC_FULLSCREEN = 'automaticFullscreen'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.BACKGROUND_FETCH","title":"BACKGROUND_FETCH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BACKGROUND_FETCH = 'backgroundFetch'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.BACKGROUND_SYNC","title":"BACKGROUND_SYNC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BACKGROUND_SYNC = 'backgroundSync'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.CAMERA_PAN_TILT_ZOOM","title":"CAMERA_PAN_TILT_ZOOM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CAMERA_PAN_TILT_ZOOM = 'cameraPanTiltZoom'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.CAPTURED_SURFACE_CONTROL","title":"CAPTURED_SURFACE_CONTROL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CAPTURED_SURFACE_CONTROL = 'capturedSurfaceControl'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.CLIPBOARD_READ_WRITE","title":"CLIPBOARD_READ_WRITE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CLIPBOARD_READ_WRITE = 'clipboardReadWrite'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.CLIPBOARD_SANITIZED_WRITE","title":"CLIPBOARD_SANITIZED_WRITE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CLIPBOARD_SANITIZED_WRITE = 'clipboardSanitizedWrite'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.DISPLAY_CAPTURE","title":"DISPLAY_CAPTURE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISPLAY_CAPTURE = 'displayCapture'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.DURABLE_STORAGE","title":"DURABLE_STORAGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DURABLE_STORAGE = 'durableStorage'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.GEOLOCATION","title":"GEOLOCATION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GEOLOCATION = 'geolocation'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.HAND_TRACKING","title":"HAND_TRACKING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HAND_TRACKING = 'handTracking'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.IDLE_DETECTION","title":"IDLE_DETECTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IDLE_DETECTION = 'idleDetection'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.KEYBOARD_LOCK","title":"KEYBOARD_LOCK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>KEYBOARD_LOCK = 'keyboardLock'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.LOCAL_FONTS","title":"LOCAL_FONTS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LOCAL_FONTS = 'localFonts'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.LOCAL_NETWORK_ACCESS","title":"LOCAL_NETWORK_ACCESS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LOCAL_NETWORK_ACCESS = 'localNetworkAccess'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.MIDI","title":"MIDI  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MIDI = 'midi'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.MIDI_SYSEX","title":"MIDI_SYSEX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MIDI_SYSEX = 'midiSysex'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.NFC","title":"NFC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NFC = 'nfc'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.NOTIFICATIONS","title":"NOTIFICATIONS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NOTIFICATIONS = 'notifications'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.PAYMENT_HANDLER","title":"PAYMENT_HANDLER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PAYMENT_HANDLER = 'paymentHandler'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.PERIODIC_BACKGROUND_SYNC","title":"PERIODIC_BACKGROUND_SYNC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PERIODIC_BACKGROUND_SYNC = 'periodicBackgroundSync'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.POINTER_LOCK","title":"POINTER_LOCK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POINTER_LOCK = 'pointerLock'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.PROTECTED_MEDIA_IDENTIFIER","title":"PROTECTED_MEDIA_IDENTIFIER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROTECTED_MEDIA_IDENTIFIER = 'protectedMediaIdentifier'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.SENSORS","title":"SENSORS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SENSORS = 'sensors'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.SMART_CARD","title":"SMART_CARD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SMART_CARD = 'smartCard'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.SPEAKER_SELECTION","title":"SPEAKER_SELECTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SPEAKER_SELECTION = 'speakerSelection'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.STORAGE_ACCESS","title":"STORAGE_ACCESS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STORAGE_ACCESS = 'storageAccess'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.TOP_LEVEL_STORAGE_ACCESS","title":"TOP_LEVEL_STORAGE_ACCESS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TOP_LEVEL_STORAGE_ACCESS = 'topLevelStorageAccess'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.VIDEO_CAPTURE","title":"VIDEO_CAPTURE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VIDEO_CAPTURE = 'videoCapture'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.VR","title":"VR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VR = 'vr'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.WAKE_LOCK_SCREEN","title":"WAKE_LOCK_SCREEN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WAKE_LOCK_SCREEN = 'wakeLockScreen'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.WAKE_LOCK_SYSTEM","title":"WAKE_LOCK_SYSTEM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WAKE_LOCK_SYSTEM = 'wakeLockSystem'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.WEB_APP_INSTALLATION","title":"WEB_APP_INSTALLATION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEB_APP_INSTALLATION = 'webAppInstallation'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.WEB_PRINTING","title":"WEB_PRINTING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEB_PRINTING = 'webPrinting'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionType.WINDOW_MANAGEMENT","title":"WINDOW_MANAGEMENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WINDOW_MANAGEMENT = 'windowManagement'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RequestMethod","title":"RequestMethod","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>HTTP request methods.</p>"},{"location":"api/core/constants/#pydoll.constants.RequestMethod.GET","title":"GET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GET = 'GET'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RequestMethod.POST","title":"POST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POST = 'POST'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RequestMethod.OPTIONS","title":"OPTIONS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OPTIONS = 'OPTIONS'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RequestMethod.PUT","title":"PUT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PUT = 'PUT'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RequestMethod.DELETE","title":"DELETE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DELETE = 'DELETE'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.AuthChallengeResponseValues","title":"AuthChallengeResponseValues","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.AuthChallengeResponseValues.DEFAULT","title":"DEFAULT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFAULT = 'Default'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.AuthChallengeResponseValues.CANCEL_AUTH","title":"CANCEL_AUTH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CANCEL_AUTH = 'CancelAuth'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.AuthChallengeResponseValues.PROVIDE_CREDENTIALS","title":"PROVIDE_CREDENTIALS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROVIDE_CREDENTIALS = 'ProvideCredentials'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ResourceType","title":"ResourceType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.ResourceType.DOCUMENT","title":"DOCUMENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DOCUMENT = 'Document'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ResourceType.STYLESHEET","title":"STYLESHEET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STYLESHEET = 'Stylesheet'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ResourceType.IMAGE","title":"IMAGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IMAGE = 'Image'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ResourceType.MEDIA","title":"MEDIA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MEDIA = 'Media'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ResourceType.FONT","title":"FONT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FONT = 'Font'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ResourceType.SCRIPT","title":"SCRIPT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SCRIPT = 'Script'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ResourceType.TEXT_TRACK","title":"TEXT_TRACK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TEXT_TRACK = 'TextTrack'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ResourceType.XHR","title":"XHR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>XHR = 'XHR'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ResourceType.FETCH","title":"FETCH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FETCH = 'Fetch'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ResourceType.PREFETCH","title":"PREFETCH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFETCH = 'Prefetch'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ResourceType.EVENT_SOURCE","title":"EVENT_SOURCE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EVENT_SOURCE = 'EventSource'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ResourceType.WEBSOCKET","title":"WEBSOCKET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEBSOCKET = 'WebSocket'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ResourceType.MANIFEST","title":"MANIFEST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MANIFEST = 'Manifest'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ResourceType.SIGNED_EXCHANGE","title":"SIGNED_EXCHANGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SIGNED_EXCHANGE = 'SignedExchange'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ResourceType.PING","title":"PING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PING = 'Ping'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ResourceType.CSP_VIOLATION_REPORT","title":"CSP_VIOLATION_REPORT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CSP_VIOLATION_REPORT = 'CSPViolationReport'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ResourceType.PREFLIGHT","title":"PREFLIGHT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFLIGHT = 'Preflight'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ResourceType.OTHER","title":"OTHER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OTHER = 'OTHER'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RequestStage","title":"RequestStage","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.RequestStage.REQUEST","title":"REQUEST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REQUEST = 'Request'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RequestStage.RESPONSE","title":"RESPONSE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESPONSE = 'Response'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.NetworkErrorReason","title":"NetworkErrorReason","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Network level fetch failure reason.</p>"},{"location":"api/core/constants/#pydoll.constants.NetworkErrorReason.FAILED","title":"FAILED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FAILED = 'Failed'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.NetworkErrorReason.ABORTED","title":"ABORTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ABORTED = 'Aborted'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.NetworkErrorReason.TIMED_OUT","title":"TIMED_OUT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TIMED_OUT = 'TimedOut'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.NetworkErrorReason.ACCESS_DENIED","title":"ACCESS_DENIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACCESS_DENIED = 'AccessDenied'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.NetworkErrorReason.CONNECTION_CLOSED","title":"CONNECTION_CLOSED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CONNECTION_CLOSED = 'ConnectionClosed'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.NetworkErrorReason.CONNECTION_RESET","title":"CONNECTION_RESET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CONNECTION_RESET = 'ConnectionReset'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.NetworkErrorReason.CONNECTION_REFUSED","title":"CONNECTION_REFUSED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CONNECTION_REFUSED = 'ConnectionRefused'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.NetworkErrorReason.CONNECTION_ABORTED","title":"CONNECTION_ABORTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CONNECTION_ABORTED = 'ConnectionAborted'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.NetworkErrorReason.CONNECTION_FAILED","title":"CONNECTION_FAILED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CONNECTION_FAILED = 'ConnectionFailed'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.NetworkErrorReason.NAME_NOT_RESOLVED","title":"NAME_NOT_RESOLVED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NAME_NOT_RESOLVED = 'NameNotResolved'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.NetworkErrorReason.INTERNET_DISCONNECTED","title":"INTERNET_DISCONNECTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INTERNET_DISCONNECTED = 'InternetDisconnected'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.NetworkErrorReason.ADDRESS_UNREACHABLE","title":"ADDRESS_UNREACHABLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ADDRESS_UNREACHABLE = 'AddressUnreachable'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.NetworkErrorReason.BLOCKED_BY_CLIENT","title":"BLOCKED_BY_CLIENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BLOCKED_BY_CLIENT = 'BlockedByClient'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.NetworkErrorReason.BLOCKED_BY_RESPONSE","title":"BLOCKED_BY_RESPONSE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BLOCKED_BY_RESPONSE = 'BlockedByResponse'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.CookiePriority","title":"CookiePriority","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Cookie priority levels.</p>"},{"location":"api/core/constants/#pydoll.constants.CookiePriority.LOW","title":"LOW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LOW = 'Low'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.CookiePriority.MEDIUM","title":"MEDIUM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MEDIUM = 'Medium'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.CookiePriority.HIGH","title":"HIGH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HIGH = 'High'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.CookieSourceScheme","title":"CookieSourceScheme","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Cookie source schemes.</p>"},{"location":"api/core/constants/#pydoll.constants.CookieSourceScheme.UNSET","title":"UNSET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSET = 'Unset'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.CookieSourceScheme.NON_SECURE","title":"NON_SECURE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NON_SECURE = 'NonSecure'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.CookieSourceScheme.SECURE","title":"SECURE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SECURE = 'Secure'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.CookieSameSite","title":"CookieSameSite","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Cookie same site values.</p>"},{"location":"api/core/constants/#pydoll.constants.CookieSameSite.STRICT","title":"STRICT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STRICT = 'Strict'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.CookieSameSite.LAX","title":"LAX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LAX = 'Lax'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.CookieSameSite.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NONE = 'None'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ConnectionType","title":"ConnectionType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Network connection types.</p>"},{"location":"api/core/constants/#pydoll.constants.ConnectionType.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NONE = 'none'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ConnectionType.CELLULAR2G","title":"CELLULAR2G  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CELLULAR2G = 'cellular2g'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ConnectionType.CELLULAR3G","title":"CELLULAR3G  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CELLULAR3G = 'cellular3g'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ConnectionType.CELLULAR4G","title":"CELLULAR4G  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CELLULAR4G = 'cellular4g'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ConnectionType.WIFI","title":"WIFI  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WIFI = 'wifi'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ConnectionType.ETHERNET","title":"ETHERNET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ETHERNET = 'ethernet'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ConnectionType.BLUETOOTH","title":"BLUETOOTH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BLUETOOTH = 'bluetooth'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ConnectionType.WIMAX","title":"WIMAX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WIMAX = 'wimax'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ConnectionType.OTHER","title":"OTHER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OTHER = 'other'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ContentEncoding","title":"ContentEncoding","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Content encoding types.</p>"},{"location":"api/core/constants/#pydoll.constants.ContentEncoding.GZIP","title":"GZIP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GZIP = 'gzip'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ContentEncoding.DEFLATE","title":"DEFLATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFLATE = 'deflate'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ContentEncoding.BR","title":"BR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BR = 'br'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ContentEncoding.ZSTD","title":"ZSTD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ZSTD = 'zstd'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ScreenshotFormat","title":"ScreenshotFormat","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Screenshot formats.</p>"},{"location":"api/core/constants/#pydoll.constants.ScreenshotFormat.JPEG","title":"JPEG  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>JPEG = 'jpeg'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ScreenshotFormat.PNG","title":"PNG  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PNG = 'png'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ScreenshotFormat.WEBP","title":"WEBP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEBP = 'webp'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ScreenshotFormat.has_value","title":"has_value  <code>classmethod</code>","text":"<pre><code>has_value(value)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ScreenshotFormat.get_value","title":"get_value  <code>classmethod</code>","text":"<pre><code>get_value(value)\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.TransitionType","title":"TransitionType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Transition types.</p>"},{"location":"api/core/constants/#pydoll.constants.TransitionType.LINK","title":"LINK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LINK = 'link'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.TransitionType.TYPED","title":"TYPED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TYPED = 'typed'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.TransitionType.ADDRESS_BAR","title":"ADDRESS_BAR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ADDRESS_BAR = 'address_bar'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.TransitionType.AUTO_BOOKMARK","title":"AUTO_BOOKMARK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AUTO_BOOKMARK = 'auto_bookmark'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.TransitionType.AUTO_SUBFRAME","title":"AUTO_SUBFRAME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AUTO_SUBFRAME = 'auto_subframe'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.TransitionType.MANUAL_SUBFRAME","title":"MANUAL_SUBFRAME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MANUAL_SUBFRAME = 'manual_subframe'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.TransitionType.GENERATED","title":"GENERATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GENERATED = 'generated'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.TransitionType.AUTO_TOPLEVEL","title":"AUTO_TOPLEVEL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AUTO_TOPLEVEL = 'auto_toplevel'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.TransitionType.FORM_SUBMIT","title":"FORM_SUBMIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FORM_SUBMIT = 'form_submit'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.TransitionType.RELOAD","title":"RELOAD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RELOAD = 'reload'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.TransitionType.KEYWORD","title":"KEYWORD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>KEYWORD = 'keyword'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.TransitionType.KEYWORD_GENERATED","title":"KEYWORD_GENERATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>KEYWORD_GENERATED = 'keyword_generated'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.TransitionType.OTHER","title":"OTHER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OTHER = 'other'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ReferrerPolicy","title":"ReferrerPolicy","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Referrer policies.</p>"},{"location":"api/core/constants/#pydoll.constants.ReferrerPolicy.NO_REFERRER","title":"NO_REFERRER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NO_REFERRER = 'noReferrer'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ReferrerPolicy.NO_REFERRER_WHEN_DOWNGRADE","title":"NO_REFERRER_WHEN_DOWNGRADE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NO_REFERRER_WHEN_DOWNGRADE = 'noReferrerWhenDowngrade'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ReferrerPolicy.ORIGIN","title":"ORIGIN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ORIGIN = 'origin'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ReferrerPolicy.ORIGIN_WHEN_CROSS_ORIGIN","title":"ORIGIN_WHEN_CROSS_ORIGIN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ORIGIN_WHEN_CROSS_ORIGIN = 'originWhenCrossOrigin'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ReferrerPolicy.SAME_ORIGIN","title":"SAME_ORIGIN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SAME_ORIGIN = 'sameOrigin'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ReferrerPolicy.STRICT_ORIGIN","title":"STRICT_ORIGIN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STRICT_ORIGIN = 'strictOrigin'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ReferrerPolicy.STRICT_ORIGIN_WHEN_CROSS_ORIGIN","title":"STRICT_ORIGIN_WHEN_CROSS_ORIGIN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STRICT_ORIGIN_WHEN_CROSS_ORIGIN = 'strictOriginWhenCrossOrigin'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ReferrerPolicy.UNSAFE_URL","title":"UNSAFE_URL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSAFE_URL = 'unsafeUrl'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.TransferMode","title":"TransferMode","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Transfer modes.</p>"},{"location":"api/core/constants/#pydoll.constants.TransferMode.RETURN_AS_STREAM","title":"RETURN_AS_STREAM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RETURN_AS_STREAM = 'returnAsStream'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.TransferMode.RETURN_AS_BASE64","title":"RETURN_AS_BASE64  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RETURN_AS_BASE64 = 'returnAsBase64'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.AutoResponseMode","title":"AutoResponseMode","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.AutoResponseMode.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NONE = 'none'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.AutoResponseMode.AUTO_ACCEPT","title":"AUTO_ACCEPT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AUTO_ACCEPT = 'autoAccept'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.AutoResponseMode.AUTO_REJECT","title":"AUTO_REJECT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AUTO_REJECT = 'autoReject'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.AutoResponseMode.AUTO_OPTOUT","title":"AUTO_OPTOUT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AUTO_OPTOUT = 'autoOptout'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.WebLifecycleState","title":"WebLifecycleState","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Web lifecycle states.</p>"},{"location":"api/core/constants/#pydoll.constants.WebLifecycleState.FROZEN","title":"FROZEN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FROZEN = 'frozen'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.WebLifecycleState.ACTIVE","title":"ACTIVE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE = 'active'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ScreencastFormat","title":"ScreencastFormat","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Screencast formats.</p>"},{"location":"api/core/constants/#pydoll.constants.ScreencastFormat.JPEG","title":"JPEG  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>JPEG = 'jpeg'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ScreencastFormat.PNG","title":"PNG  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PNG = 'png'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.OriginTrialStatus","title":"OriginTrialStatus","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.OriginTrialStatus.ENABLED","title":"ENABLED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ENABLED = 'Enabled'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.OriginTrialStatus.VALID_TOKEN_NOT_PROVIDED","title":"VALID_TOKEN_NOT_PROVIDED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VALID_TOKEN_NOT_PROVIDED = 'ValidTokenNotProvided'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.OriginTrialStatus.OS_NOT_SUPPORTED","title":"OS_NOT_SUPPORTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OS_NOT_SUPPORTED = 'OsNotSupported'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.OriginTrialStatus.TRIAL_NOT_ALLOWED","title":"TRIAL_NOT_ALLOWED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TRIAL_NOT_ALLOWED = 'TrialNotAllowed'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.OriginTrialUsageRestriction","title":"OriginTrialUsageRestriction","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.OriginTrialUsageRestriction.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NONE = 'None'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.OriginTrialUsageRestriction.SUBSET","title":"SUBSET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SUBSET = 'Subset'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.OriginTrialTokenStatus","title":"OriginTrialTokenStatus","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.OriginTrialTokenStatus.SUCCESS","title":"SUCCESS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SUCCESS = 'Success'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.OriginTrialTokenStatus.NOT_SUPPORTED","title":"NOT_SUPPORTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NOT_SUPPORTED = 'NotSupported'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.OriginTrialTokenStatus.INSECURE","title":"INSECURE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INSECURE = 'Insecure'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.OriginTrialTokenStatus.EXPIRED","title":"EXPIRED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EXPIRED = 'Expired'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.OriginTrialTokenStatus.WRONG_ORIGIN","title":"WRONG_ORIGIN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WRONG_ORIGIN = 'WrongOrigin'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.OriginTrialTokenStatus.INVALID_SIGNATURE","title":"INVALID_SIGNATURE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INVALID_SIGNATURE = 'InvalidSignature'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.OriginTrialTokenStatus.MALFORMED","title":"MALFORMED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MALFORMED = 'Malformed'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.OriginTrialTokenStatus.WRONG_VERSION","title":"WRONG_VERSION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WRONG_VERSION = 'WrongVersion'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.OriginTrialTokenStatus.FEATURE_DISABLED","title":"FEATURE_DISABLED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FEATURE_DISABLED = 'FeatureDisabled'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.OriginTrialTokenStatus.TOKEN_DISABLED","title":"TOKEN_DISABLED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TOKEN_DISABLED = 'TokenDisabled'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.OriginTrialTokenStatus.FEATURE_DISABLED_FOR_USER","title":"FEATURE_DISABLED_FOR_USER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FEATURE_DISABLED_FOR_USER = 'FeatureDisabledForUser'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.OriginTrialTokenStatus.UNKNOWN_TRIAL","title":"UNKNOWN_TRIAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNKNOWN_TRIAL = 'UnknownTrial'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyBlockReason","title":"PermissionsPolicyBlockReason","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyBlockReason.HEADER","title":"HEADER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HEADER = 'Header'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyBlockReason.IFRAME_ATTRIBUTE","title":"IFRAME_ATTRIBUTE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IFRAME_ATTRIBUTE = 'IframeAttribute'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyBlockReason.IN_FANCED_FRAME_TREE","title":"IN_FANCED_FRAME_TREE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IN_FANCED_FRAME_TREE = 'InFancedFrameTree'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyBlockReason.IN_ISOLATED_APP","title":"IN_ISOLATED_APP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IN_ISOLATED_APP = 'InIsolatedApp'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature","title":"PermissionsPolicyFeature","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.ACCELEROMETER","title":"ACCELEROMETER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACCELEROMETER = 'accelerometer'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.ALL_SCREENS_CAPTURE","title":"ALL_SCREENS_CAPTURE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ALL_SCREENS_CAPTURE = 'all-screens-capture'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.AMBIENT_LIGHT_SENSOR","title":"AMBIENT_LIGHT_SENSOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AMBIENT_LIGHT_SENSOR = 'ambient-light-sensor'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.ATTRIBUTION_REPORTING","title":"ATTRIBUTION_REPORTING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ATTRIBUTION_REPORTING = 'attribution-reporting'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.AUTOPLAY","title":"AUTOPLAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AUTOPLAY = 'autoplay'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.BLUETOOTH","title":"BLUETOOTH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BLUETOOTH = 'bluetooth'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.BROWSING_TOPICS","title":"BROWSING_TOPICS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BROWSING_TOPICS = 'browsing-topics'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CAMERA","title":"CAMERA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CAMERA = 'camera'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CAPTURED_SURFACE_CONTROL","title":"CAPTURED_SURFACE_CONTROL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CAPTURED_SURFACE_CONTROL = 'captured-surface-control'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CH_DPR","title":"CH_DPR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CH_DPR = 'ch-dpr'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CH_DEVICE_MEMORY","title":"CH_DEVICE_MEMORY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CH_DEVICE_MEMORY = 'ch-device-memory'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CH_DOWNLINK","title":"CH_DOWNLINK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CH_DOWNLINK = 'ch-downlink'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CH_ECT","title":"CH_ECT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CH_ECT = 'ch-ect'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CH_PREFERS_COLOR_SCHEME","title":"CH_PREFERS_COLOR_SCHEME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CH_PREFERS_COLOR_SCHEME = 'ch-prefers-color-scheme'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CH_PREFERS_REDUCED_MOTION","title":"CH_PREFERS_REDUCED_MOTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CH_PREFERS_REDUCED_MOTION = 'ch-prefers-reduced-motion'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CH_PREFERS_REDUCED_TRANSPARENCY","title":"CH_PREFERS_REDUCED_TRANSPARENCY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CH_PREFERS_REDUCED_TRANSPARENCY = 'ch-prefers-reduced-transparency'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CH_RTT","title":"CH_RTT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CH_RTT = 'ch-rtt'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CH_SAVE_DATA","title":"CH_SAVE_DATA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CH_SAVE_DATA = 'ch-save-data'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CH_UA","title":"CH_UA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CH_UA = 'ch-ua'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CH_UA_ARCH","title":"CH_UA_ARCH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CH_UA_ARCH = 'ch-ua-arch'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CH_UA_BITNESS","title":"CH_UA_BITNESS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CH_UA_BITNESS = 'ch-ua-bitness'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CH_UA_HIGH_ENTROPY_VALUES","title":"CH_UA_HIGH_ENTROPY_VALUES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CH_UA_HIGH_ENTROPY_VALUES = 'ch-ua-high-entropy-values'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CH_UA_PLATFORM","title":"CH_UA_PLATFORM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CH_UA_PLATFORM = 'ch-ua-platform'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CH_UA_MODEL","title":"CH_UA_MODEL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CH_UA_MODEL = 'ch-ua-model'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CH_UA_MOBILE","title":"CH_UA_MOBILE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CH_UA_MOBILE = 'ch-ua-mobile'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CH_UA_FORM_FACTORS","title":"CH_UA_FORM_FACTORS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CH_UA_FORM_FACTORS = 'ch-ua-form-factors'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CH_UA_FULL_VERSION","title":"CH_UA_FULL_VERSION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CH_UA_FULL_VERSION = 'ch-ua-full-version'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CH_UA_FULL_VERSION_LIST","title":"CH_UA_FULL_VERSION_LIST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CH_UA_FULL_VERSION_LIST = 'ch-ua-full-version-list'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CH_UA_PLATFORM_VERSION","title":"CH_UA_PLATFORM_VERSION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CH_UA_PLATFORM_VERSION = 'ch-ua-platform-version'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CH_UA_WOW64","title":"CH_UA_WOW64  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CH_UA_WOW64 = 'ch-ua-wow64'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CH_VIEWPORT_HEIGHT","title":"CH_VIEWPORT_HEIGHT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CH_VIEWPORT_HEIGHT = 'ch-viewport-height'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CH_VIEWPORT_WIDTH","title":"CH_VIEWPORT_WIDTH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CH_VIEWPORT_WIDTH = 'ch-viewport-width'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CH_WIDTH","title":"CH_WIDTH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CH_WIDTH = 'ch-width'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CLIPBOARD_READ","title":"CLIPBOARD_READ  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CLIPBOARD_READ = 'clipboard-read'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CLIPBOARD_WRITE","title":"CLIPBOARD_WRITE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CLIPBOARD_WRITE = 'clipboard-write'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.COMPUTE_PRESSURE","title":"COMPUTE_PRESSURE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>COMPUTE_PRESSURE = 'compute-pressure'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CONTROLLED_FRAME","title":"CONTROLLED_FRAME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CONTROLLED_FRAME = 'controlled-frame'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.CROSS_ORIGIN_ISOLATED","title":"CROSS_ORIGIN_ISOLATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CROSS_ORIGIN_ISOLATED = 'cross-origin-isolated'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.DEFERRED_FETCH","title":"DEFERRED_FETCH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFERRED_FETCH = 'deferred-fetch'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.DEFERRED_FETCH_MINIMAL","title":"DEFERRED_FETCH_MINIMAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFERRED_FETCH_MINIMAL = 'deferred-fetch-minimal'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.DEVICE_ATTRIBUTES","title":"DEVICE_ATTRIBUTES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEVICE_ATTRIBUTES = 'device-attributes'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.DIGITAL_CREDENTIALS_GET","title":"DIGITAL_CREDENTIALS_GET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIGITAL_CREDENTIALS_GET = 'digital-credentials-get'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.DIRECT_SOCKETS","title":"DIRECT_SOCKETS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIRECT_SOCKETS = 'direct-sockets'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.DIRECT_SOCKETS_PRIVATE","title":"DIRECT_SOCKETS_PRIVATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIRECT_SOCKETS_PRIVATE = 'direct-sockets-private'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.DISPLAY_CAPTURE","title":"DISPLAY_CAPTURE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISPLAY_CAPTURE = 'display-capture'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.DOCUMENT_DOMAIN","title":"DOCUMENT_DOMAIN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DOCUMENT_DOMAIN = 'document-domain'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.ENCRYPTED_MEDIA","title":"ENCRYPTED_MEDIA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ENCRYPTED_MEDIA = 'encrypted-media'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.EXECUTION_WHILE_OUT_OF_VIEWPORT","title":"EXECUTION_WHILE_OUT_OF_VIEWPORT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EXECUTION_WHILE_OUT_OF_VIEWPORT = 'execution-while-out-of-viewport'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.EXECUTION_WHILE_NOT_RENDERED","title":"EXECUTION_WHILE_NOT_RENDERED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EXECUTION_WHILE_NOT_RENDERED = 'execution-while-not-rendered'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.FENCED_UNPARTITIONED_STORAGE_READ","title":"FENCED_UNPARTITIONED_STORAGE_READ  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FENCED_UNPARTITIONED_STORAGE_READ = 'fenced-unpartitioned-storage-read'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.FOCUS_WITHOUT_USER_ACTIVATION","title":"FOCUS_WITHOUT_USER_ACTIVATION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FOCUS_WITHOUT_USER_ACTIVATION = 'focus-without-user-activation'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.FULLSCREEN","title":"FULLSCREEN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FULLSCREEN = 'fullscreen'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.FROBULATE","title":"FROBULATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FROBULATE = 'frobulate'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.GAMEPAD","title":"GAMEPAD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GAMEPAD = 'gamepad'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.GEOLOCATION","title":"GEOLOCATION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GEOLOCATION = 'geolocation'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.GYROSCOPE","title":"GYROSCOPE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GYROSCOPE = 'gyroscope'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.HID","title":"HID  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HID = 'hid'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.IDENTITY_CREDENTIALS_GET","title":"IDENTITY_CREDENTIALS_GET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IDENTITY_CREDENTIALS_GET = 'identity-credentials-get'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.IDLE_DETECTION","title":"IDLE_DETECTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IDLE_DETECTION = 'idle-detection'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.INTEREST_COHORT","title":"INTEREST_COHORT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INTEREST_COHORT = 'interest-cohort'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.JOIN_AD_INTEREST_GROUP","title":"JOIN_AD_INTEREST_GROUP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>JOIN_AD_INTEREST_GROUP = 'join-ad-interest-group'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.KEYBOARD_MAP","title":"KEYBOARD_MAP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>KEYBOARD_MAP = 'keyboard-map'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.LANGUAGE_DETECTOR","title":"LANGUAGE_DETECTOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LANGUAGE_DETECTOR = 'language-detector'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.LOCAL_FONTS","title":"LOCAL_FONTS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LOCAL_FONTS = 'local-fonts'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.MAGNETOMETER","title":"MAGNETOMETER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAGNETOMETER = 'magnetometer'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.MEDIA_PLAYBACK_WHILE_NOT_VISIBLE","title":"MEDIA_PLAYBACK_WHILE_NOT_VISIBLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MEDIA_PLAYBACK_WHILE_NOT_VISIBLE = 'media-playback-while-not-visible'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.MICROPHONE","title":"MICROPHONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MICROPHONE = 'microphone'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.MIDI","title":"MIDI  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MIDI = 'midi'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.OTP_CREDENTIALS","title":"OTP_CREDENTIALS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OTP_CREDENTIALS = 'otp-credentials'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.PAYMENT","title":"PAYMENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PAYMENT = 'payment'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.PICTURE_IN_PICTURE","title":"PICTURE_IN_PICTURE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PICTURE_IN_PICTURE = 'picture-in-picture'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.POPINS","title":"POPINS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POPINS = 'popins'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.PRIVATE_AGGREGATION","title":"PRIVATE_AGGREGATION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PRIVATE_AGGREGATION = 'private-aggregation'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.PRIVATE_STATE_TOKEN_ISSUANCE","title":"PRIVATE_STATE_TOKEN_ISSUANCE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PRIVATE_STATE_TOKEN_ISSUANCE = 'private-state-token-issuance'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.PRIVATE_STATE_TOKEN_REDEMPTION","title":"PRIVATE_STATE_TOKEN_REDEMPTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PRIVATE_STATE_TOKEN_REDEMPTION = 'private-state-token-redemption'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.PUBLICKEY_CREDENTIALS_CREATE","title":"PUBLICKEY_CREDENTIALS_CREATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PUBLICKEY_CREDENTIALS_CREATE = 'publickey-credentials-create'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.PUBLICKEY_CREDENTIALS_GET","title":"PUBLICKEY_CREDENTIALS_GET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PUBLICKEY_CREDENTIALS_GET = 'publickey-credentials-get'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.REWRITER","title":"REWRITER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REWRITER = 'rewriter'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.RUN_AD_AUCTION","title":"RUN_AD_AUCTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RUN_AD_AUCTION = 'run-ad-auction'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.SCREEN_WAKE_LOCK","title":"SCREEN_WAKE_LOCK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SCREEN_WAKE_LOCK = 'screen-wake-lock'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.SERIAL","title":"SERIAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SERIAL = 'serial'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.SHARED_AUTOFILL","title":"SHARED_AUTOFILL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SHARED_AUTOFILL = 'shared-autofill'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.SHARED_STORAGE","title":"SHARED_STORAGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SHARED_STORAGE = 'shared-storage'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.SHARED_STORAGE_SELECT_URL","title":"SHARED_STORAGE_SELECT_URL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SHARED_STORAGE_SELECT_URL = 'shared-storage-select-url'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.SMART_CARD","title":"SMART_CARD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SMART_CARD = 'smart-card'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.SPEAKER_SELECTION","title":"SPEAKER_SELECTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SPEAKER_SELECTION = 'speaker-selection'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.STORAGE_ACCESS","title":"STORAGE_ACCESS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STORAGE_ACCESS = 'storage-access'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.SUB_APPS","title":"SUB_APPS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SUB_APPS = 'sub-apps'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.SUMMARIZER","title":"SUMMARIZER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SUMMARIZER = 'summarizer'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.SYNC_XHR","title":"SYNC_XHR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SYNC_XHR = 'sync-xhr'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.TRANSLATOR","title":"TRANSLATOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TRANSLATOR = 'translator'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.UNLOAD","title":"UNLOAD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNLOAD = 'unload'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.USB","title":"USB  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>USB = 'usb'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.USB_UNRESTRICTED","title":"USB_UNRESTRICTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>USB_UNRESTRICTED = 'usb-unresStricted'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.VERTICAL_SCROLL","title":"VERTICAL_SCROLL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VERTICAL_SCROLL = 'vertical-scroll'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.WEB_APP_INSTALLATION","title":"WEB_APP_INSTALLATION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEB_APP_INSTALLATION = 'web-app-installation'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.WEB_PRINTING","title":"WEB_PRINTING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEB_PRINTING = 'web-printing'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.WEB_SHARE","title":"WEB_SHARE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEB_SHARE = 'web-share'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.WINDOW_MANAGEMENT","title":"WINDOW_MANAGEMENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WINDOW_MANAGEMENT = 'window-management'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.WRITER","title":"WRITER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WRITER = 'writer'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PermissionsPolicyFeature.XR_SPATIAL_TRACKING","title":"XR_SPATIAL_TRACKING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>XR_SPATIAL_TRACKING = 'xr-spatial-tracking'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.CrossOriginOpenerPolicyStatus","title":"CrossOriginOpenerPolicyStatus","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.CrossOriginOpenerPolicyStatus.SAME_ORIGIN","title":"SAME_ORIGIN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SAME_ORIGIN = 'SameOrigin'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.CrossOriginOpenerPolicyStatus.SAME_ORIGIN_ALLOW_POPUPS","title":"SAME_ORIGIN_ALLOW_POPUPS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SAME_ORIGIN_ALLOW_POPUPS = 'SameOriginAllowPopups'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.CrossOriginOpenerPolicyStatus.RESTRICT_PROPERTIES","title":"RESTRICT_PROPERTIES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESTRICT_PROPERTIES = 'RestrictProperties'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.CrossOriginOpenerPolicyStatus.UNSAFE_NONE","title":"UNSAFE_NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSAFE_NONE = 'UnsafeNone'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.CrossOriginOpenerPolicyStatus.SAME_ORIGIN_PLUS_COEP","title":"SAME_ORIGIN_PLUS_COEP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SAME_ORIGIN_PLUS_COEP = 'SameOriginPlusCoep'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.CrossOriginOpenerPolicyStatus.RESTRICT_PROPERTIES_PLUS_COEP","title":"RESTRICT_PROPERTIES_PLUS_COEP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESTRICT_PROPERTIES_PLUS_COEP = 'RestrictPropertiesPlusCoep'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.CrossOriginOpenerPolicyStatus.NO_OPENER_ALLOW_POPUPS","title":"NO_OPENER_ALLOW_POPUPS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NO_OPENER_ALLOW_POPUPS = 'NoopenerAllowPopups'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.CrossOriginEmbedderPolicyStatus","title":"CrossOriginEmbedderPolicyStatus","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Cross-origin embedder policy status values.</p>"},{"location":"api/core/constants/#pydoll.constants.CrossOriginEmbedderPolicyStatus.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NONE = 'None'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.CrossOriginEmbedderPolicyStatus.CREDENTIALLESS","title":"CREDENTIALLESS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CREDENTIALLESS = 'Credentialless'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.CrossOriginEmbedderPolicyStatus.REQUIRE_CORP","title":"REQUIRE_CORP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REQUIRE_CORP = 'RequireCorp'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ContentSecurityPolicySource","title":"ContentSecurityPolicySource","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.ContentSecurityPolicySource.HTTP","title":"HTTP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HTTP = 'HTTP'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ContentSecurityPolicySource.META","title":"META  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>META = 'Meta'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.UnserializableEnum","title":"UnserializableEnum","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.UnserializableEnum.NEGATIVE_ZERO","title":"NEGATIVE_ZERO  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NEGATIVE_ZERO = '-0'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.UnserializableEnum.NAN","title":"NAN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NAN = 'NaN'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.UnserializableEnum.INFINITY","title":"INFINITY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFINITY = 'Infinity'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.UnserializableEnum.NEGATIVE_INFINITY","title":"NEGATIVE_INFINITY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NEGATIVE_INFINITY = '-Infinity'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.SerializationValue","title":"SerializationValue","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.SerializationValue.DEEP","title":"DEEP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEEP = 'deep'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.SerializationValue.JSON","title":"JSON  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>JSON = 'json'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.SerializationValue.ID_ONLY","title":"ID_ONLY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ID_ONLY = 'idOnly'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectType","title":"RemoteObjectType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectType.OBJECT","title":"OBJECT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OBJECT = 'object'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectType.FUNCTION","title":"FUNCTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FUNCTION = 'function'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectType.UNDEFINED","title":"UNDEFINED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNDEFINED = 'undefined'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectType.STRING","title":"STRING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STRING = 'string'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectType.NUMBER","title":"NUMBER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NUMBER = 'number'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectType.BOOLEAN","title":"BOOLEAN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BOOLEAN = 'boolean'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectType.SYMBOL","title":"SYMBOL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SYMBOL = 'symbol'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectType.BIGINT","title":"BIGINT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BIGINT = 'bigint'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectSubtype","title":"RemoteObjectSubtype","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectSubtype.ARRAY","title":"ARRAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ARRAY = 'array'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectSubtype.NULL","title":"NULL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NULL = 'null'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectSubtype.NODE","title":"NODE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NODE = 'node'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectSubtype.REGEXP","title":"REGEXP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REGEXP = 'regexp'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectSubtype.DATE","title":"DATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DATE = 'date'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectSubtype.MAP","title":"MAP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAP = 'map'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectSubtype.SET","title":"SET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SET = 'set'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectSubtype.WEAK_MAP","title":"WEAK_MAP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEAK_MAP = 'weakmap'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectSubtype.WEAK_SET","title":"WEAK_SET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEAK_SET = 'weakset'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectSubtype.ITERATOR","title":"ITERATOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ITERATOR = 'iterator'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectSubtype.GENERATOR","title":"GENERATOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GENERATOR = 'generator'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectSubtype.ERROR","title":"ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ERROR = 'error'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectSubtype.PROXY","title":"PROXY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROXY = 'proxy'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectSubtype.PROMISE","title":"PROMISE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROMISE = 'promise'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectSubtype.TYPED_ARRAY","title":"TYPED_ARRAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TYPED_ARRAY = 'typedarray'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectSubtype.ARRAY_BUFFER","title":"ARRAY_BUFFER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ARRAY_BUFFER = 'arraybuffer'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectSubtype.DATA_VIEW","title":"DATA_VIEW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DATA_VIEW = 'dataview'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectSubtype.WEB_ASSEMBLY_MEMORY","title":"WEB_ASSEMBLY_MEMORY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEB_ASSEMBLY_MEMORY = 'webassemblymemory'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RemoteObjectSubtype.WASM_VALUE","title":"WASM_VALUE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WASM_VALUE = 'wasmvalue'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DeepSerializedValueType","title":"DeepSerializedValueType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.DeepSerializedValueType.UNDEFINED","title":"UNDEFINED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNDEFINED = 'undefined'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DeepSerializedValueType.NULL","title":"NULL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NULL = 'null'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DeepSerializedValueType.STRING","title":"STRING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STRING = 'string'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DeepSerializedValueType.NUMBER","title":"NUMBER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NUMBER = 'number'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DeepSerializedValueType.BOOLEAN","title":"BOOLEAN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BOOLEAN = 'boolean'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DeepSerializedValueType.BIGINT","title":"BIGINT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BIGINT = 'bigint'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DeepSerializedValueType.REGEXP","title":"REGEXP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REGEXP = 'regexp'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DeepSerializedValueType.DATE","title":"DATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DATE = 'date'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DeepSerializedValueType.SYMBOL","title":"SYMBOL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SYMBOL = 'symbol'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DeepSerializedValueType.ARRAY","title":"ARRAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ARRAY = 'array'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DeepSerializedValueType.OBJECT","title":"OBJECT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OBJECT = 'object'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DeepSerializedValueType.FUNCTION","title":"FUNCTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FUNCTION = 'function'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DeepSerializedValueType.MAP","title":"MAP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAP = 'map'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DeepSerializedValueType.SET","title":"SET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SET = 'set'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DeepSerializedValueType.WEAK_MAP","title":"WEAK_MAP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEAK_MAP = 'weakmap'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DeepSerializedValueType.WEAK_SET","title":"WEAK_SET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEAK_SET = 'weakset'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DeepSerializedValueType.ERROR","title":"ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ERROR = 'error'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DeepSerializedValueType.PROXY","title":"PROXY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROXY = 'proxy'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DeepSerializedValueType.PROMISE","title":"PROMISE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROMISE = 'promise'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DeepSerializedValueType.TYPED_ARRAY","title":"TYPED_ARRAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TYPED_ARRAY = 'typedarray'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DeepSerializedValueType.ARRAY_BUFFER","title":"ARRAY_BUFFER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ARRAY_BUFFER = 'arraybuffer'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DeepSerializedValueType.NODE","title":"NODE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NODE = 'node'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DeepSerializedValueType.WINDOW","title":"WINDOW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WINDOW = 'window'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DeepSerializedValueType.GENERATOR","title":"GENERATOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GENERATOR = 'generator'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewType","title":"ObjectPreviewType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewType.OBJECT","title":"OBJECT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OBJECT = 'object'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewType.FUNCTION","title":"FUNCTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FUNCTION = 'function'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewType.UNDEFINED","title":"UNDEFINED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNDEFINED = 'undefined'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewType.STRING","title":"STRING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STRING = 'string'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewType.NUMBER","title":"NUMBER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NUMBER = 'number'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewType.BOOLEAN","title":"BOOLEAN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BOOLEAN = 'boolean'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewType.SYMBOL","title":"SYMBOL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SYMBOL = 'symbol'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewType.BIGINT","title":"BIGINT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BIGINT = 'bigint'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewSubtype","title":"ObjectPreviewSubtype","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewSubtype.ARRAY","title":"ARRAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ARRAY = 'array'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewSubtype.NULL","title":"NULL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NULL = 'null'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewSubtype.NODE","title":"NODE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NODE = 'node'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewSubtype.REGEXP","title":"REGEXP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REGEXP = 'regexp'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewSubtype.DATE","title":"DATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DATE = 'date'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewSubtype.MAP","title":"MAP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAP = 'map'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewSubtype.SET","title":"SET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SET = 'set'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewSubtype.WEAKMAP","title":"WEAKMAP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEAKMAP = 'weakmap'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewSubtype.WEAKSET","title":"WEAKSET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEAKSET = 'weakset'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewSubtype.ITERATOR","title":"ITERATOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ITERATOR = 'iterator'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewSubtype.GENERATOR","title":"GENERATOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GENERATOR = 'generator'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewSubtype.ERROR","title":"ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ERROR = 'error'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewSubtype.PROXY","title":"PROXY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROXY = 'proxy'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewSubtype.PROMISE","title":"PROMISE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROMISE = 'promise'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewSubtype.TYPEDARRAY","title":"TYPEDARRAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TYPEDARRAY = 'typedarray'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewSubtype.ARRAYBUFFER","title":"ARRAYBUFFER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ARRAYBUFFER = 'arraybuffer'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewSubtype.DATAVIEW","title":"DATAVIEW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DATAVIEW = 'dataview'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewSubtype.WEB_ASSEMBLY_MEMORY","title":"WEB_ASSEMBLY_MEMORY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEB_ASSEMBLY_MEMORY = 'webassemblymemory'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ObjectPreviewSubtype.WASM_VALUE","title":"WASM_VALUE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WASM_VALUE = 'wasmvalue'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewType","title":"PropertyPreviewType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewType.OBJECT","title":"OBJECT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OBJECT = 'object'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewType.FUNCTION","title":"FUNCTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FUNCTION = 'function'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewType.UNDEFINED","title":"UNDEFINED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNDEFINED = 'undefined'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewType.STRING","title":"STRING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STRING = 'string'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewType.NUMBER","title":"NUMBER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NUMBER = 'number'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewType.BOOLEAN","title":"BOOLEAN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BOOLEAN = 'boolean'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewType.SYMBOL","title":"SYMBOL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SYMBOL = 'symbol'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewType.ACCESSOR","title":"ACCESSOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACCESSOR = 'accessor'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewType.BIGINT","title":"BIGINT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BIGINT = 'bigint'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewSubtype","title":"PropertyPreviewSubtype","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewSubtype.ARRAY","title":"ARRAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ARRAY = 'array'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewSubtype.NULL","title":"NULL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NULL = 'null'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewSubtype.NODE","title":"NODE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NODE = 'node'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewSubtype.REGEXP","title":"REGEXP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REGEXP = 'regexp'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewSubtype.DATE","title":"DATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DATE = 'date'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewSubtype.MAP","title":"MAP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAP = 'map'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewSubtype.SET","title":"SET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SET = 'set'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewSubtype.WEAKMAP","title":"WEAKMAP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEAKMAP = 'weakmap'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewSubtype.WEAKSET","title":"WEAKSET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEAKSET = 'weakset'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewSubtype.ITERATOR","title":"ITERATOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ITERATOR = 'iterator'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewSubtype.GENERATOR","title":"GENERATOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GENERATOR = 'generator'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewSubtype.ERROR","title":"ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ERROR = 'error'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewSubtype.PROXY","title":"PROXY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROXY = 'proxy'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewSubtype.PROMISE","title":"PROMISE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROMISE = 'promise'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewSubtype.TYPEDARRAY","title":"TYPEDARRAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TYPEDARRAY = 'typedarray'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewSubtype.ARRAYBUFFER","title":"ARRAYBUFFER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ARRAYBUFFER = 'arraybuffer'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewSubtype.DATAVIEW","title":"DATAVIEW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DATAVIEW = 'dataview'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewSubtype.WEB_ASSEMBLY_MEMORY","title":"WEB_ASSEMBLY_MEMORY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEB_ASSEMBLY_MEMORY = 'webassemblymemory'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PropertyPreviewSubtype.WASM_VALUE","title":"WASM_VALUE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WASM_VALUE = 'wasmvalue'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.StorageBucketDurability","title":"StorageBucketDurability","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.StorageBucketDurability.RELAXED","title":"RELAXED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RELAXED = 'relaxed'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.StorageBucketDurability.STRICT","title":"STRICT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STRICT = 'strict'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.StorageType","title":"StorageType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.StorageType.COOKIES","title":"COOKIES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>COOKIES = 'cookies'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.StorageType.FILE_SYSTEMS","title":"FILE_SYSTEMS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FILE_SYSTEMS = 'file_systems'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.StorageType.INDEXEDDB","title":"INDEXEDDB  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INDEXEDDB = 'indexeddb'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.StorageType.LOCAL_STORAGE","title":"LOCAL_STORAGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LOCAL_STORAGE = 'local_storage'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.StorageType.SHADER_CACHE","title":"SHADER_CACHE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SHADER_CACHE = 'shader_cache'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.StorageType.WEBSQL","title":"WEBSQL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEBSQL = 'websql'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.StorageType.SERVICE_WORKERS","title":"SERVICE_WORKERS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SERVICE_WORKERS = 'service_workers'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.StorageType.CACHE_STORAGE","title":"CACHE_STORAGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CACHE_STORAGE = 'cache_storage'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.StorageType.INTEREST_GROUPS","title":"INTEREST_GROUPS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INTEREST_GROUPS = 'interest_groups'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.StorageType.SHARED_STORAGE","title":"SHARED_STORAGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SHARED_STORAGE = 'shared_storage'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.StorageType.STORAGE_BUCKETS","title":"STORAGE_BUCKETS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STORAGE_BUCKETS = 'storage_buckets'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.StorageType.ALL","title":"ALL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ALL = 'all'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.StorageType.OTHER","title":"OTHER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OTHER = 'other'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.KeyEventType","title":"KeyEventType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.KeyEventType.KEY_DOWN","title":"KEY_DOWN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>KEY_DOWN = 'keyDown'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.KeyEventType.KEY_UP","title":"KEY_UP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>KEY_UP = 'keyUp'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.KeyEventType.CHAR","title":"CHAR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHAR = 'char'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.KeyEventType.RAW_KEY_DOWN","title":"RAW_KEY_DOWN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RAW_KEY_DOWN = 'rawKeyDown'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.KeyModifier","title":"KeyModifier","text":"<p>               Bases: <code>int</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.KeyModifier.ALT","title":"ALT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ALT = 1\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.KeyModifier.CTRL","title":"CTRL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CTRL = 2\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.KeyModifier.META","title":"META  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>META = 4\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.KeyModifier.SHIFT","title":"SHIFT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SHIFT = 8\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.KeyLocation","title":"KeyLocation","text":"<p>               Bases: <code>int</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.KeyLocation.LEFT","title":"LEFT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LEFT = 1\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.KeyLocation.RIGHT","title":"RIGHT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RIGHT = 2\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.MouseEventType","title":"MouseEventType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.MouseEventType.MOUSE_PRESSED","title":"MOUSE_PRESSED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MOUSE_PRESSED = 'mousePressed'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.MouseEventType.MOUSE_RELEASED","title":"MOUSE_RELEASED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MOUSE_RELEASED = 'mouseReleased'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.MouseEventType.MOUSE_MOVED","title":"MOUSE_MOVED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MOUSE_MOVED = 'mouseMoved'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.MouseEventType.MOUSE_WHEEL","title":"MOUSE_WHEEL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MOUSE_WHEEL = 'mouseWheel'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.MouseButton","title":"MouseButton","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.MouseButton.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NONE = 'none'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.MouseButton.LEFT","title":"LEFT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LEFT = 'left'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.MouseButton.MIDDLE","title":"MIDDLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MIDDLE = 'middle'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.MouseButton.RIGHT","title":"RIGHT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RIGHT = 'right'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.MouseButton.BACK","title":"BACK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BACK = 'back'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.MouseButton.FORWARD","title":"FORWARD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FORWARD = 'forward'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PointerType","title":"PointerType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.PointerType.MOUSE","title":"MOUSE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MOUSE = 'mouse'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PointerType.PEN","title":"PEN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PEN = 'pen'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.TouchEventType","title":"TouchEventType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.TouchEventType.TOUCH_START","title":"TOUCH_START  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TOUCH_START = 'touchStart'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.TouchEventType.TOUCH_MOVE","title":"TOUCH_MOVE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TOUCH_MOVE = 'touchMove'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.TouchEventType.TOUCH_END","title":"TOUCH_END  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TOUCH_END = 'touchEnd'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.TouchEventType.TOUCH_CANCEL","title":"TOUCH_CANCEL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TOUCH_CANCEL = 'touchCancel'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DragEventType","title":"DragEventType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.DragEventType.DRAG_ENTER","title":"DRAG_ENTER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DRAG_ENTER = 'dragEnter'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DragEventType.DRAG_OVER","title":"DRAG_OVER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DRAG_OVER = 'dragOver'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DragEventType.DROP","title":"DROP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DROP = 'drop'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DragEventType.DRAG_CANCEL","title":"DRAG_CANCEL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DRAG_CANCEL = 'dragCancel'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.GestureSourceType","title":"GestureSourceType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.GestureSourceType.TOUCH","title":"TOUCH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TOUCH = 'touch'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.GestureSourceType.MOUSE","title":"MOUSE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MOUSE = 'mouse'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.GestureSourceType.DEFAULT","title":"DEFAULT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFAULT = 'default'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.IncludeWhitespace","title":"IncludeWhitespace","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.IncludeWhitespace.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NONE = 'none'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.IncludeWhitespace.ALL","title":"ALL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ALL = 'all'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PhysicalAxes","title":"PhysicalAxes","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.PhysicalAxes.HORIZONTAL","title":"HORIZONTAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HORIZONTAL = 'Horizontal'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PhysicalAxes.VERTICAL","title":"VERTICAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VERTICAL = 'Vertical'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PhysicalAxes.BOTH","title":"BOTH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BOTH = 'Both'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.LogicalAxes","title":"LogicalAxes","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.LogicalAxes.INLINE","title":"INLINE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INLINE = 'Inline'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.LogicalAxes.BLOCK","title":"BLOCK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BLOCK = 'Block'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.LogicalAxes.BOTH","title":"BOTH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BOTH = 'Both'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType","title":"PseudoType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.FIRST_LINE","title":"FIRST_LINE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FIRST_LINE = 'first-line'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.FIRST_LETTER","title":"FIRST_LETTER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FIRST_LETTER = 'first-letter'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.CHECKMARK","title":"CHECKMARK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHECKMARK = 'checkmark'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.BEFORE","title":"BEFORE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BEFORE = 'before'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.AFTER","title":"AFTER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AFTER = 'after'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.PICKER_ICON","title":"PICKER_ICON  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PICKER_ICON = 'picker-icon'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.MARKER","title":"MARKER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MARKER = 'marker'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.BACKDROP","title":"BACKDROP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BACKDROP = 'backdrop'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.COLUMN","title":"COLUMN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>COLUMN = 'column'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.SELECTION","title":"SELECTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SELECTION = 'selection'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.SEARCH_TEXT","title":"SEARCH_TEXT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SEARCH_TEXT = 'search-text'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.TARGET_TEXT","title":"TARGET_TEXT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TARGET_TEXT = 'target-text'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.SPELLING_ERROR","title":"SPELLING_ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SPELLING_ERROR = 'spelling-error'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.GRAMMAR_ERROR","title":"GRAMMAR_ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GRAMMAR_ERROR = 'grammar-error'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.HIGHLIGHT","title":"HIGHLIGHT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HIGHLIGHT = 'highlight'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.FIRST_LINE_INHERITED","title":"FIRST_LINE_INHERITED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FIRST_LINE_INHERITED = 'first-line-inherited'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.SCROLL_MARKER","title":"SCROLL_MARKER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SCROLL_MARKER = 'scroll-marker'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.SCROLL_MARKER_GROUP","title":"SCROLL_MARKER_GROUP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SCROLL_MARKER_GROUP = 'scroll-marker-group'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.SCROLL_BUTTON","title":"SCROLL_BUTTON  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SCROLL_BUTTON = 'scroll-button'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.SCROLLBAR","title":"SCROLLBAR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SCROLLBAR = 'scrollbar'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.SCROLLBAR_THUMB","title":"SCROLLBAR_THUMB  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SCROLLBAR_THUMB = 'scrollbar-thumb'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.SCROLLBAR_BUTTON","title":"SCROLLBAR_BUTTON  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SCROLLBAR_BUTTON = 'scrollbar-button'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.SCROLLBAR_TRACK","title":"SCROLLBAR_TRACK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SCROLLBAR_TRACK = 'scrollbar-track'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.SCROLLBAR_TRACK_PIECE","title":"SCROLLBAR_TRACK_PIECE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SCROLLBAR_TRACK_PIECE = 'scrollbar-track-piece'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.SCROLLBAR_CORNER","title":"SCROLLBAR_CORNER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SCROLLBAR_CORNER = 'scrollbar-corner'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.RESIZER","title":"RESIZER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESIZER = 'resizer'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.INPUT_LIST_BUTTON","title":"INPUT_LIST_BUTTON  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INPUT_LIST_BUTTON = 'input-list-button'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.VIEW_TRANSITION","title":"VIEW_TRANSITION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VIEW_TRANSITION = 'view-transition'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.VIEW_TRANSITION_GROUP","title":"VIEW_TRANSITION_GROUP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VIEW_TRANSITION_GROUP = 'view-transition-group'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.VIEW_TRANSITION_IMAGE_PAIR","title":"VIEW_TRANSITION_IMAGE_PAIR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VIEW_TRANSITION_IMAGE_PAIR = 'view-transition-image-pair'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.VIEW_TRANSITION_OLD","title":"VIEW_TRANSITION_OLD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VIEW_TRANSITION_OLD = 'view-transition-old'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.VIEW_TRANSITION_NEW","title":"VIEW_TRANSITION_NEW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VIEW_TRANSITION_NEW = 'view-transition-new'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.PLACEHOLDER","title":"PLACEHOLDER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PLACEHOLDER = 'placeholder'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.FILE_SELECTOR_BUTTON","title":"FILE_SELECTOR_BUTTON  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FILE_SELECTOR_BUTTON = 'file-selector-button'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.DETAILS_CONTENT","title":"DETAILS_CONTENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DETAILS_CONTENT = 'details-content'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.PseudoType.PICKER","title":"PICKER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PICKER = 'picker'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ShadowRootType","title":"ShadowRootType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.ShadowRootType.OPEN","title":"OPEN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OPEN = 'open'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ShadowRootType.CLOSED","title":"CLOSED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CLOSED = 'closed'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ShadowRootType.USER_AGENT","title":"USER_AGENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>USER_AGENT = 'user-agent'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.CompatibilityMode","title":"CompatibilityMode","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.CompatibilityMode.QUIRKS_MODE","title":"QUIRKS_MODE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QUIRKS_MODE = 'QuirksMode'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.CompatibilityMode.LIMITED_QUIRKS_MODE","title":"LIMITED_QUIRKS_MODE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LIMITED_QUIRKS_MODE = 'LimitedQuirksMode'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.CompatibilityMode.NO_QUIRKS_MODE","title":"NO_QUIRKS_MODE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NO_QUIRKS_MODE = 'NoQuirksMode'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ElementRelation","title":"ElementRelation","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.ElementRelation.POPOVER_TARGET","title":"POPOVER_TARGET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POPOVER_TARGET = 'PopoverTarget'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ElementRelation.INTEREST_TARGET","title":"INTEREST_TARGET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INTEREST_TARGET = 'InterestTarget'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.MixedContentType","title":"MixedContentType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.MixedContentType.BLOCKABLE","title":"BLOCKABLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BLOCKABLE = 'blockable'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.MixedContentType.OPTIONALLY_BLOCKABLE","title":"OPTIONALLY_BLOCKABLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OPTIONALLY_BLOCKABLE = 'optionally-blockable'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.MixedContentType.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NONE = 'none'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ResourcePriority","title":"ResourcePriority","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.ResourcePriority.VERY_LOW","title":"VERY_LOW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VERY_LOW = 'VeryLow'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ResourcePriority.LOW","title":"LOW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LOW = 'Low'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ResourcePriority.MEDIUM","title":"MEDIUM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MEDIUM = 'Medium'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ResourcePriority.HIGH","title":"HIGH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HIGH = 'High'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.ResourcePriority.VERY_HIGH","title":"VERY_HIGH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VERY_HIGH = 'VeryHigh'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.TrustTokenOperationType","title":"TrustTokenOperationType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.TrustTokenOperationType.ISSUANCE","title":"ISSUANCE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ISSUANCE = 'Issuance'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.TrustTokenOperationType.REDEMPTION","title":"REDEMPTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REDEMPTION = 'Redemption'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.TrustTokenOperationType.SIGNING","title":"SIGNING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SIGNING = 'Signing'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RefreshPolicy","title":"RefreshPolicy","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.RefreshPolicy.USE_CACHED","title":"USE_CACHED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>USE_CACHED = 'UseCached'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.RefreshPolicy.REFRESH","title":"REFRESH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REFRESH = 'Refresh'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DialogType","title":"DialogType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.DialogType.ALERT","title":"ALERT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ALERT = 'alert'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DialogType.CONFIRM","title":"CONFIRM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CONFIRM = 'confirm'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DialogType.PROMPT","title":"PROMPT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROMPT = 'prompt'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.DialogType.BEFORE_UNLOAD","title":"BEFORE_UNLOAD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BEFORE_UNLOAD = 'beforeunload'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.InitiatorType","title":"InitiatorType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/core/constants/#pydoll.constants.InitiatorType.PARSER","title":"PARSER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PARSER = 'parser'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.InitiatorType.SCRIPT","title":"SCRIPT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SCRIPT = 'script'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.InitiatorType.PRELOAD","title":"PRELOAD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PRELOAD = 'preload'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.InitiatorType.SIGNED_EXCHANGE","title":"SIGNED_EXCHANGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SIGNED_EXCHANGE = 'SignedExchange'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.InitiatorType.PREFLIGHT","title":"PREFLIGHT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFLIGHT = 'preflight'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.InitiatorType.OTHER","title":"OTHER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OTHER = 'other'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.NetworkServiceWorkerRouterSourceType","title":"NetworkServiceWorkerRouterSourceType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Network service worker router source types.</p>"},{"location":"api/core/constants/#pydoll.constants.NetworkServiceWorkerRouterSourceType.NETWORK","title":"NETWORK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NETWORK = 'network'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.NetworkServiceWorkerRouterSourceType.CACHE","title":"CACHE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CACHE = 'cache'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.NetworkServiceWorkerRouterSourceType.FETCH_EVENT","title":"FETCH_EVENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FETCH_EVENT = 'fetch-event'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.NetworkServiceWorkerRouterSourceType.RACE_NETWORK","title":"RACE_NETWORK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RACE_NETWORK = 'race-network'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.NetworkServiceWorkerRouterSourceType.RACE_NETWORK_AND_FETCH_HANDLER","title":"RACE_NETWORK_AND_FETCH_HANDLER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RACE_NETWORK_AND_FETCH_HANDLER = 'race-network-and-fetch-handler'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.NetworkServiceWorkerRouterSourceType.RACE_NETWORK_AND_CACHE","title":"RACE_NETWORK_AND_CACHE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RACE_NETWORK_AND_CACHE = 'race-network-and-cache'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.NetworkServiceWorkerResponseSource","title":"NetworkServiceWorkerResponseSource","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Network service worker response source types.</p>"},{"location":"api/core/constants/#pydoll.constants.NetworkServiceWorkerResponseSource.CACHE_STORAGE","title":"CACHE_STORAGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CACHE_STORAGE = 'cache-storage'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.NetworkServiceWorkerResponseSource.HTTP_CACHE","title":"HTTP_CACHE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HTTP_CACHE = 'http-cache'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.NetworkServiceWorkerResponseSource.FALLBACK_CODE","title":"FALLBACK_CODE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FALLBACK_CODE = 'fallback-code'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.NetworkServiceWorkerResponseSource.NETWORK","title":"NETWORK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NETWORK = 'network'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.AlternateProtocolUsage","title":"AlternateProtocolUsage","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Alternate protocol usage types.</p>"},{"location":"api/core/constants/#pydoll.constants.AlternateProtocolUsage.ALTERNATIVE_JOB_WON_WITHOUT_RACE","title":"ALTERNATIVE_JOB_WON_WITHOUT_RACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ALTERNATIVE_JOB_WON_WITHOUT_RACE = 'alternativeJobWonWithoutRace'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.AlternateProtocolUsage.ALTERNATIVE_JOB_WON_RACE","title":"ALTERNATIVE_JOB_WON_RACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ALTERNATIVE_JOB_WON_RACE = 'alternativeJobWonRace'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.AlternateProtocolUsage.MAIN_JOB_WON_RACE","title":"MAIN_JOB_WON_RACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAIN_JOB_WON_RACE = 'mainJobWonRace'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.AlternateProtocolUsage.MAPPING_MISSING","title":"MAPPING_MISSING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAPPING_MISSING = 'mappingMissing'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.AlternateProtocolUsage.BROKEN","title":"BROKEN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BROKEN = 'broken'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.AlternateProtocolUsage.DNS_ALPN_H3_JOB_WON_WITHOUT_RACE","title":"DNS_ALPN_H3_JOB_WON_WITHOUT_RACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DNS_ALPN_H3_JOB_WON_WITHOUT_RACE = 'dnsAlpnH3JobWonWithoutRace'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.AlternateProtocolUsage.DNS_ALPN_H3_JOB_WON_RACE","title":"DNS_ALPN_H3_JOB_WON_RACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DNS_ALPN_H3_JOB_WON_RACE = 'dnsAlpnH3JobWonRace'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.AlternateProtocolUsage.UNSPECIFIED_REASON","title":"UNSPECIFIED_REASON  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED_REASON = 'unspecifiedReason'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.SecurityState","title":"SecurityState","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Security state types.</p>"},{"location":"api/core/constants/#pydoll.constants.SecurityState.UNKNOWN","title":"UNKNOWN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNKNOWN = 'unknown'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.SecurityState.NEUTRAL","title":"NEUTRAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NEUTRAL = 'neutral'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.SecurityState.INSECURE","title":"INSECURE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INSECURE = 'insecure'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.SecurityState.INFO","title":"INFO  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFO = 'info'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.SecurityState.INSECURE_BROKEN","title":"INSECURE_BROKEN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INSECURE_BROKEN = 'insecure-broken'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.CertificateTransparencyCompliance","title":"CertificateTransparencyCompliance","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Certificate transparency compliance types.</p>"},{"location":"api/core/constants/#pydoll.constants.CertificateTransparencyCompliance.UNKNOWN","title":"UNKNOWN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNKNOWN = 'unknown'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.CertificateTransparencyCompliance.NOT_COMPLIANT","title":"NOT_COMPLIANT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NOT_COMPLIANT = 'not-compliant'\n</code></pre>"},{"location":"api/core/constants/#pydoll.constants.CertificateTransparencyCompliance.COMPLIANT","title":"COMPLIANT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>COMPLIANT = 'compliant'\n</code></pre>"},{"location":"api/core/exceptions/","title":"Exceptions","text":"<p>This section documents all custom exceptions that can be raised by Pydoll operations.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions","title":"pydoll.exceptions","text":"<p>Pydoll Exception Classes</p> <p>This module contains all exception classes used throughout the Pydoll library, organized into logical categories based on their function and usage patterns. Each category uses a base class to provide common functionality for related exceptions.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.PydollException","title":"PydollException","text":"<pre><code>PydollException(message='')\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Base class for all Pydoll exceptions.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.PydollException.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = message or message\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.ConnectionException","title":"ConnectionException","text":"<pre><code>ConnectionException(message='')\n</code></pre> <p>               Bases: <code>PydollException</code></p> <p>Base class for exceptions related to browser connection.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.ConnectionException.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'A connection error occurred'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.ConnectionFailed","title":"ConnectionFailed","text":"<pre><code>ConnectionFailed(message='')\n</code></pre> <p>               Bases: <code>ConnectionException</code></p> <p>Raised when connection to the browser cannot be established.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.ConnectionFailed.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'Failed to connect to the browser'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.ReconnectionFailed","title":"ReconnectionFailed","text":"<pre><code>ReconnectionFailed(message='')\n</code></pre> <p>               Bases: <code>ConnectionException</code></p> <p>Raised when an attempt to reconnect to the browser fails.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.ReconnectionFailed.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'Failed to reconnect to the browser'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.WebSocketConnectionClosed","title":"WebSocketConnectionClosed","text":"<pre><code>WebSocketConnectionClosed(message='')\n</code></pre> <p>               Bases: <code>ConnectionException</code></p> <p>Raised when the WebSocket connection to the browser is closed unexpectedly.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.WebSocketConnectionClosed.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'The WebSocket connection is closed'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.NetworkError","title":"NetworkError","text":"<pre><code>NetworkError(message='')\n</code></pre> <p>               Bases: <code>ConnectionException</code></p> <p>Raised when a general network error occurs during browser communication.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.NetworkError.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'A network error occurred'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.BrowserException","title":"BrowserException","text":"<pre><code>BrowserException(message='')\n</code></pre> <p>               Bases: <code>PydollException</code></p> <p>Base class for exceptions related to browser process management.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.BrowserException.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'A browser error occurred'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.BrowserNotRunning","title":"BrowserNotRunning","text":"<pre><code>BrowserNotRunning(message='')\n</code></pre> <p>               Bases: <code>BrowserException</code></p> <p>Raised when attempting to interact with a browser that is not running.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.BrowserNotRunning.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'The browser is not running'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.FailedToStartBrowser","title":"FailedToStartBrowser","text":"<pre><code>FailedToStartBrowser(message='')\n</code></pre> <p>               Bases: <code>BrowserException</code></p> <p>Raised when the browser process cannot be started.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.FailedToStartBrowser.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'Failed to start the browser'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.UnsupportedOS","title":"UnsupportedOS","text":"<pre><code>UnsupportedOS(message='')\n</code></pre> <p>               Bases: <code>BrowserException</code></p> <p>Raised when attempting to run on an unsupported operating system.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.UnsupportedOS.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'Unsupported OS'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.NoValidTabFound","title":"NoValidTabFound","text":"<pre><code>NoValidTabFound(message='')\n</code></pre> <p>               Bases: <code>BrowserException</code></p> <p>Raised when no valid browser tab can be found or created.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.NoValidTabFound.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'No valid attached tab found'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.ProtocolException","title":"ProtocolException","text":"<pre><code>ProtocolException(message='')\n</code></pre> <p>               Bases: <code>PydollException</code></p> <p>Base class for exceptions related to CDP protocol communication.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.ProtocolException.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'A protocol error occurred'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.InvalidCommand","title":"InvalidCommand","text":"<pre><code>InvalidCommand(message='')\n</code></pre> <p>               Bases: <code>ProtocolException</code></p> <p>Raised when an invalid command is sent to the browser.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.InvalidCommand.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'The command provided is invalid'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.InvalidResponse","title":"InvalidResponse","text":"<pre><code>InvalidResponse(message='')\n</code></pre> <p>               Bases: <code>ProtocolException</code></p> <p>Raised when an invalid response is received from the browser.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.InvalidResponse.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'The response received is invalid'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.ResendCommandFailed","title":"ResendCommandFailed","text":"<pre><code>ResendCommandFailed(message='')\n</code></pre> <p>               Bases: <code>ProtocolException</code></p> <p>Raised when an attempt to resend a failed command fails.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.ResendCommandFailed.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'Failed to resend the command'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.CommandExecutionTimeout","title":"CommandExecutionTimeout","text":"<pre><code>CommandExecutionTimeout(message='')\n</code></pre> <p>               Bases: <code>ProtocolException</code></p> <p>Raised when a command execution times out.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.CommandExecutionTimeout.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'The command execution timed out'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.InvalidCallback","title":"InvalidCallback","text":"<pre><code>InvalidCallback(message='')\n</code></pre> <p>               Bases: <code>ProtocolException</code></p> <p>Raised when an invalid callback is provided for an event.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.InvalidCallback.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'The callback provided is invalid'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.EventNotSupported","title":"EventNotSupported","text":"<pre><code>EventNotSupported(message='')\n</code></pre> <p>               Bases: <code>ProtocolException</code></p> <p>Raised when an attempt is made to subscribe to an unsupported event.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.EventNotSupported.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'The event is not supported'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.ElementException","title":"ElementException","text":"<pre><code>ElementException(message='')\n</code></pre> <p>               Bases: <code>PydollException</code></p> <p>Base class for exceptions related to element interactions.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.ElementException.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'An element interaction error occurred'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.ElementNotFound","title":"ElementNotFound","text":"<pre><code>ElementNotFound(message='')\n</code></pre> <p>               Bases: <code>ElementException</code></p> <p>Raised when an element cannot be found in the DOM.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.ElementNotFound.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'The specified element was not found'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.ElementNotVisible","title":"ElementNotVisible","text":"<pre><code>ElementNotVisible(message='')\n</code></pre> <p>               Bases: <code>ElementException</code></p> <p>Raised when attempting to interact with an element that is not visible.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.ElementNotVisible.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'The element is not visible'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.ElementNotInteractable","title":"ElementNotInteractable","text":"<pre><code>ElementNotInteractable(message='')\n</code></pre> <p>               Bases: <code>ElementException</code></p> <p>Raised when attempting to interact with an element that cannot receive interaction.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.ElementNotInteractable.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'The element is not interactable'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.ClickIntercepted","title":"ClickIntercepted","text":"<pre><code>ClickIntercepted(message='')\n</code></pre> <p>               Bases: <code>ElementException</code></p> <p>Raised when a click operation is intercepted by another element.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.ClickIntercepted.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'The click was intercepted'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.ElementNotAFileInput","title":"ElementNotAFileInput","text":"<pre><code>ElementNotAFileInput(message='')\n</code></pre> <p>               Bases: <code>ElementException</code></p> <p>Raised when attempting to use file input methods on a non-file input element.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.ElementNotAFileInput.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'The element is not a file input'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.TimeoutException","title":"TimeoutException","text":"<pre><code>TimeoutException(message='')\n</code></pre> <p>               Bases: <code>PydollException</code></p> <p>Base class for exceptions related to timeouts.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.TimeoutException.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'A timeout occurred'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.PageLoadTimeout","title":"PageLoadTimeout","text":"<pre><code>PageLoadTimeout(message='')\n</code></pre> <p>               Bases: <code>TimeoutException</code></p> <p>Raised when a page load operation times out.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.PageLoadTimeout.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'Page load timed out'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.WaitElementTimeout","title":"WaitElementTimeout","text":"<pre><code>WaitElementTimeout(message='')\n</code></pre> <p>               Bases: <code>TimeoutException</code></p> <p>Raised when waiting for an element times out.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.WaitElementTimeout.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'Timed out waiting for element to appear'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.ConfigurationException","title":"ConfigurationException","text":"<pre><code>ConfigurationException(message='')\n</code></pre> <p>               Bases: <code>PydollException</code></p> <p>Base class for exceptions related to configuration and options.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.ConfigurationException.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'A configuration error occurred'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.InvalidOptionsObject","title":"InvalidOptionsObject","text":"<pre><code>InvalidOptionsObject(message='')\n</code></pre> <p>               Bases: <code>ConfigurationException</code></p> <p>Raised when an invalid options object is provided.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.InvalidOptionsObject.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'The options object provided is invalid'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.InvalidBrowserPath","title":"InvalidBrowserPath","text":"<pre><code>InvalidBrowserPath(message='')\n</code></pre> <p>               Bases: <code>ConfigurationException</code></p> <p>Raised when an invalid browser executable path is provided.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.InvalidBrowserPath.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'The browser path provided is invalid'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.ArgumentAlreadyExistsInOptions","title":"ArgumentAlreadyExistsInOptions","text":"<pre><code>ArgumentAlreadyExistsInOptions(message='')\n</code></pre> <p>               Bases: <code>ConfigurationException</code></p> <p>Raised when attempting to add a duplicate argument to browser options.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.ArgumentAlreadyExistsInOptions.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'The argument already exists in the options'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.InvalidFileExtension","title":"InvalidFileExtension","text":"<pre><code>InvalidFileExtension(message='')\n</code></pre> <p>               Bases: <code>ConfigurationException</code></p> <p>Raised when an unsupported file extension is provided.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.InvalidFileExtension.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'The file extension provided is not supported'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.DialogException","title":"DialogException","text":"<pre><code>DialogException(message='')\n</code></pre> <p>               Bases: <code>PydollException</code></p> <p>Base class for exceptions related to browser dialogs.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.DialogException.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'A dialog error occurred'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.NoDialogPresent","title":"NoDialogPresent","text":"<pre><code>NoDialogPresent(message='')\n</code></pre> <p>               Bases: <code>DialogException</code></p> <p>Raised when attempting to interact with a dialog that doesn't exist.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.NoDialogPresent.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'No dialog present on the page'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.NotAnIFrame","title":"NotAnIFrame","text":"<pre><code>NotAnIFrame(message='')\n</code></pre> <p>               Bases: <code>PydollException</code></p> <p>Raised when an element is not an iframe.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.NotAnIFrame.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'The element is not an iframe'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.InvalidIFrame","title":"InvalidIFrame","text":"<pre><code>InvalidIFrame(message='')\n</code></pre> <p>               Bases: <code>PydollException</code></p> <p>Raised when an iframe is not valid.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.InvalidIFrame.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'The iframe is not valid'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.IFrameNotFound","title":"IFrameNotFound","text":"<pre><code>IFrameNotFound(message='')\n</code></pre> <p>               Bases: <code>PydollException</code></p> <p>Raised when an iframe is not found.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.IFrameNotFound.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'The iframe was not found'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.NetworkEventsNotEnabled","title":"NetworkEventsNotEnabled","text":"<pre><code>NetworkEventsNotEnabled(message='')\n</code></pre> <p>               Bases: <code>PydollException</code></p> <p>Raised when network events are not enabled.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.NetworkEventsNotEnabled.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'Network events not enabled'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.ScriptException","title":"ScriptException","text":"<pre><code>ScriptException(message='')\n</code></pre> <p>               Bases: <code>PydollException</code></p> <p>Base class for exceptions related to JavaScript execution.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.ScriptException.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'A script execution error occurred'\n</code></pre>"},{"location":"api/core/exceptions/#pydoll.exceptions.InvalidScriptWithElement","title":"InvalidScriptWithElement","text":"<pre><code>InvalidScriptWithElement(message='')\n</code></pre> <p>               Bases: <code>ScriptException</code></p> <p>Raised when a script contains 'argument' but no element is provided.</p>"},{"location":"api/core/exceptions/#pydoll.exceptions.InvalidScriptWithElement.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = 'Script contains \"argument\" but no element was provided'\n</code></pre>"},{"location":"api/core/utils/","title":"Utilities","text":"<p>This section documents utility functions and helper classes used throughout Pydoll.</p>"},{"location":"api/core/utils/#pydoll.utils","title":"pydoll.utils","text":""},{"location":"api/core/utils/#pydoll.utils.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"api/core/utils/#pydoll.utils.TextExtractor","title":"TextExtractor","text":"<pre><code>TextExtractor()\n</code></pre> <p>               Bases: <code>HTMLParser</code></p> <p>HTML parser for text extraction.</p> <p>Extracts visible text content from an HTML string, excluding the contents of tags specified in _skip_tags.</p>"},{"location":"api/core/utils/#pydoll.utils.TextExtractor.handle_starttag","title":"handle_starttag","text":"<pre><code>handle_starttag(tag, attrs)\n</code></pre> <p>Marks the parser to skip content inside tags specified in _skip_tags.</p> PARAMETER DESCRIPTION <code>tag</code> <p>The tag name.</p> <p> TYPE: <code>str</code> </p> <code>attrs</code> <p>A list of (attribute, value) pairs.</p> <p> TYPE: <code>list</code> </p>"},{"location":"api/core/utils/#pydoll.utils.TextExtractor.handle_endtag","title":"handle_endtag","text":"<pre><code>handle_endtag(tag)\n</code></pre> <p>Marks the parser the end of skip tags.</p> PARAMETER DESCRIPTION <code>tag</code> <p>The tag name.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/core/utils/#pydoll.utils.TextExtractor.handle_data","title":"handle_data","text":"<pre><code>handle_data(data)\n</code></pre> <p>Handles text nodes. Adds them to the result unless they are within a skip tag.</p> PARAMETER DESCRIPTION <code>data</code> <p>The text data.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/core/utils/#pydoll.utils.TextExtractor.get_strings","title":"get_strings","text":"<pre><code>get_strings(strip)\n</code></pre> <p>Yields all collected visible text fragments.</p> PARAMETER DESCRIPTION <code>strip</code> <p>Whether to strip leading/trailing whitespace from each fragment.</p> <p> TYPE: <code>bool</code> </p> YIELDS DESCRIPTION <code>str</code> <p>Visible text fragments.</p>"},{"location":"api/core/utils/#pydoll.utils.TextExtractor.get_text","title":"get_text","text":"<pre><code>get_text(separator, strip)\n</code></pre> <p>Returns all visible text.</p> PARAMETER DESCRIPTION <code>separator</code> <p>String inserted between extracted text fragments.</p> <p> TYPE: <code>str</code> </p> <code>strip</code> <p>Whether to strip whitespace from each fragment.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The visible text.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/core/utils/#pydoll.utils.extract_text_from_html","title":"extract_text_from_html","text":"<pre><code>extract_text_from_html(html, separator='', strip=False)\n</code></pre> <p>Extracts visible text content from an HTML string.</p> PARAMETER DESCRIPTION <code>html</code> <p>The HTML string to extract text from.</p> <p> TYPE: <code>str</code> </p> <code>separator</code> <p>String inserted between extracted text fragments. Defaults to ''.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>strip</code> <p>Whether to strip whitespace from text fragments. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The extracted visible text.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/core/utils/#pydoll.utils.decode_base64_to_bytes","title":"decode_base64_to_bytes","text":"<pre><code>decode_base64_to_bytes(image)\n</code></pre> <p>Decodes a base64 image string to bytes.</p> PARAMETER DESCRIPTION <code>image</code> <p>The base64 image string to decode.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bytes</code> <p>The decoded image as bytes.</p> <p> TYPE: <code>bytes</code> </p>"},{"location":"api/core/utils/#pydoll.utils.get_browser_ws_address","title":"get_browser_ws_address  <code>async</code>","text":"<pre><code>get_browser_ws_address(port)\n</code></pre> <p>Fetches the WebSocket address for the browser instance.</p> RETURNS DESCRIPTION <code>str</code> <p>The WebSocket address for the browser.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>NetworkError</code> <p>If the address cannot be fetched due to network errors or missing data.</p> <code>InvalidResponse</code> <p>If the response is not valid JSON.</p>"},{"location":"api/core/utils/#pydoll.utils.validate_browser_paths","title":"validate_browser_paths","text":"<pre><code>validate_browser_paths(paths)\n</code></pre> <p>Validates potential browser executable paths and returns the first valid one.</p> <p>Checks a list of possible browser binary locations to find an existing, executable browser. This is used by browser-specific subclasses to locate the browser executable when no explicit binary path is provided.</p> PARAMETER DESCRIPTION <code>paths</code> <p>List of potential file paths to check for the browser executable. These should be absolute paths appropriate for the current OS.</p> <p> TYPE: <code>list[str]</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The first valid browser executable path found.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>InvalidBrowserPath</code> <p>If the browser executable is not found at the path.</p>"},{"location":"api/core/utils/#pydoll.utils.clean_script_for_analysis","title":"clean_script_for_analysis","text":"<pre><code>clean_script_for_analysis(script)\n</code></pre> <p>Clean JavaScript code by removing comments and string literals.</p> <p>This helps avoid false positives when analyzing script structure.</p> PARAMETER DESCRIPTION <code>script</code> <p>JavaScript code to clean.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Cleaned script with comments and strings removed.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/core/utils/#pydoll.utils.is_script_already_function","title":"is_script_already_function","text":"<pre><code>is_script_already_function(script)\n</code></pre> <p>Check if a JavaScript script is already wrapped in a function.</p> PARAMETER DESCRIPTION <code>script</code> <p>JavaScript code to analyze.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if script is already a function, False otherwise.</p> <p> TYPE: <code>bool</code> </p>"},{"location":"api/core/utils/#pydoll.utils.has_return_outside_function","title":"has_return_outside_function","text":"<pre><code>has_return_outside_function(script)\n</code></pre> <p>Check if a JavaScript script has return statements outside of functions.</p> PARAMETER DESCRIPTION <code>script</code> <p>JavaScript code to analyze.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if script has return outside function, False otherwise.</p> <p> TYPE: <code>bool</code> </p>"},{"location":"api/elements/mixins/","title":"Element Mixins","text":"<p>The mixins module provides reusable functionality that can be mixed into element classes to extend their capabilities.</p>"},{"location":"api/elements/mixins/#find-elements-mixin","title":"Find Elements Mixin","text":"<p>The <code>FindElementsMixin</code> provides element finding capabilities to classes that include it.</p>"},{"location":"api/elements/mixins/#pydoll.elements.mixins.find_elements_mixin","title":"pydoll.elements.mixins.find_elements_mixin","text":""},{"location":"api/elements/mixins/#pydoll.elements.mixins.find_elements_mixin.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T')\n</code></pre>"},{"location":"api/elements/mixins/#pydoll.elements.mixins.find_elements_mixin.FindElementsMixin","title":"FindElementsMixin","text":"<p>Mixin providing comprehensive element finding and waiting capabilities.</p> <p>Implements DOM element location using various selector strategies (CSS, XPath, etc.) with support for single/multiple element finding and configurable waiting. Classes using this mixin gain powerful element discovery without implementing complex location logic themselves.</p>"},{"location":"api/elements/mixins/#pydoll.elements.mixins.find_elements_mixin.FindElementsMixin.find","title":"find  <code>async</code>","text":"<pre><code>find(id=None, class_name=None, name=None, tag_name=None, text=None, timeout=0, find_all=False, raise_exc=True, **attributes)\n</code></pre> <p>Find element(s) using combination of common HTML attributes.</p> <p>Flexible element location using standard attributes. Multiple attributes can be combined for specific selectors (builds XPath when multiple specified).</p> PARAMETER DESCRIPTION <code>id</code> <p>Element ID attribute value.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>class_name</code> <p>CSS class name to match.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>name</code> <p>Element name attribute value.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>tag_name</code> <p>HTML tag name (e.g., \"div\", \"input\").</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>text</code> <p>Text content to match within element.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>Maximum seconds to wait for elements to appear.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>find_all</code> <p>If True, returns all matches; if False, first match only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>raise_exc</code> <p>Whether to raise exception if no elements found.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>**attributes</code> <p>Additional HTML attributes to match.</p> <p> TYPE: <code>dict[str, str]</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Union[WebElement, list[WebElement], None]</code> <p>WebElement, list[WebElement], or None based on find_all and raise_exc.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If no search criteria provided.</p> <code>ElementNotFound</code> <p>If no elements found and raise_exc=True.</p> <code>WaitElementTimeout</code> <p>If timeout specified and no elements appear in time.</p>"},{"location":"api/elements/mixins/#pydoll.elements.mixins.find_elements_mixin.FindElementsMixin.query","title":"query  <code>async</code>","text":"<pre><code>query(expression, timeout=0, find_all=False, raise_exc=True)\n</code></pre> <p>Find element(s) using raw CSS selector or XPath expression.</p> <p>Direct access using CSS or XPath syntax. Selector type automatically determined based on expression pattern.</p> PARAMETER DESCRIPTION <code>expression</code> <p>Selector expression (CSS, XPath, ID with #, class with .).</p> <p> TYPE: <code>str</code> </p> <code>timeout</code> <p>Maximum seconds to wait for elements to appear.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>find_all</code> <p>If True, returns all matches; if False, first match only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>raise_exc</code> <p>Whether to raise exception if no elements found.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Union[WebElement, list[WebElement], None]</code> <p>WebElement, list[WebElement], or None based on find_all and raise_exc.</p> RAISES DESCRIPTION <code>ElementNotFound</code> <p>If no elements found and raise_exc=True.</p> <code>WaitElementTimeout</code> <p>If timeout specified and no elements appear in time.</p>"},{"location":"api/elements/mixins/#pydoll.elements.mixins.find_elements_mixin.FindElementsMixin.find_or_wait_element","title":"find_or_wait_element  <code>async</code>","text":"<pre><code>find_or_wait_element(by, value, timeout=0, find_all=False, raise_exc=True)\n</code></pre> <p>Core element finding method with optional waiting capability.</p> <p>Searches for elements with flexible waiting. If timeout specified, repeatedly attempts to find elements with 0.5s delays until success or timeout. Used by higher-level find() and query() methods.</p> PARAMETER DESCRIPTION <code>by</code> <p>Selector strategy (CSS_SELECTOR, XPATH, ID, etc.).</p> <p> TYPE: <code>By</code> </p> <code>value</code> <p>Selector value to locate element(s).</p> <p> TYPE: <code>str</code> </p> <code>timeout</code> <p>Maximum seconds to wait (0 = no waiting).</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>find_all</code> <p>If True, returns all matches; if False, first match only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>raise_exc</code> <p>Whether to raise exception if no elements found.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Union[WebElement, list[WebElement], None]</code> <p>WebElement, list[WebElement], or None based on find_all and raise_exc.</p> RAISES DESCRIPTION <code>ElementNotFound</code> <p>If no elements found with timeout=0 and raise_exc=True.</p> <code>WaitElementTimeout</code> <p>If elements not found within timeout and raise_exc=True.</p>"},{"location":"api/elements/mixins/#pydoll.elements.mixins.find_elements_mixin.create_web_element","title":"create_web_element","text":"<pre><code>create_web_element(*args, **kwargs)\n</code></pre> <p>Create WebElement instance avoiding circular imports.</p> <p>Factory method that dynamically imports WebElement at runtime to prevent circular import dependencies.</p>"},{"location":"api/elements/mixins/#usage","title":"Usage","text":"<p>Mixins are typically used internally by the library to compose functionality. The <code>FindElementsMixin</code> is used by classes like <code>Tab</code> and <code>WebElement</code> to provide element finding methods:</p> <pre><code># These methods come from FindElementsMixin\nelement = await tab.find(id=\"username\")\nelements = await tab.find(class_name=\"item\", find_all=True)\nelement = await tab.query(\"#submit-button\")\n</code></pre>"},{"location":"api/elements/mixins/#available-methods","title":"Available Methods","text":"<p>The <code>FindElementsMixin</code> provides several methods for finding elements:</p> <ul> <li><code>find()</code> - Modern element finding with keyword arguments</li> <li><code>query()</code> - CSS selector and XPath queries</li> <li><code>find_element()</code> - Legacy element finding method</li> <li><code>find_elements()</code> - Legacy method for finding multiple elements</li> </ul> <p>Modern vs Legacy</p> <p>The <code>find()</code> method is the modern, recommended approach for finding elements. The <code>find_element()</code> and <code>find_elements()</code> methods are maintained for backward compatibility. </p>"},{"location":"api/elements/web_element/","title":"WebElement","text":""},{"location":"api/elements/web_element/#pydoll.elements.web_element.WebElement","title":"pydoll.elements.web_element.WebElement","text":"<pre><code>WebElement(object_id, connection_handler, method=None, selector=None, attributes_list=[])\n</code></pre> <p>               Bases: <code>FindElementsMixin</code></p> <p>DOM element wrapper for browser automation.</p> <p>Provides comprehensive functionality for element interaction, inspection, and manipulation using Chrome DevTools Protocol commands.</p> <p>Initialize WebElement wrapper.</p> PARAMETER DESCRIPTION <code>object_id</code> <p>Unique CDP object identifier for this DOM element.</p> <p> TYPE: <code>str</code> </p> <code>connection_handler</code> <p>Connection instance for browser communication.</p> <p> TYPE: <code>ConnectionHandler</code> </p> <code>method</code> <p>Search method used to find this element (for debugging).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>selector</code> <p>Selector string used to find this element (for debugging).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>attributes_list</code> <p>Flat list of alternating attribute names and values.</p> <p> TYPE: <code>list[str]</code> DEFAULT: <code>[]</code> </p>"},{"location":"api/elements/web_element/#pydoll.elements.web_element.WebElement.value","title":"value  <code>property</code>","text":"<pre><code>value\n</code></pre> <p>Element's value attribute (for form elements).</p>"},{"location":"api/elements/web_element/#pydoll.elements.web_element.WebElement.class_name","title":"class_name  <code>property</code>","text":"<pre><code>class_name\n</code></pre> <p>Element's CSS class name(s).</p>"},{"location":"api/elements/web_element/#pydoll.elements.web_element.WebElement.id","title":"id  <code>property</code>","text":"<pre><code>id\n</code></pre> <p>Element's ID attribute.</p>"},{"location":"api/elements/web_element/#pydoll.elements.web_element.WebElement.tag_name","title":"tag_name  <code>property</code>","text":"<pre><code>tag_name\n</code></pre> <p>Element's HTML tag name.</p>"},{"location":"api/elements/web_element/#pydoll.elements.web_element.WebElement.is_enabled","title":"is_enabled  <code>property</code>","text":"<pre><code>is_enabled\n</code></pre> <p>Whether element is enabled (not disabled).</p>"},{"location":"api/elements/web_element/#pydoll.elements.web_element.WebElement.text","title":"text  <code>async</code> <code>property</code>","text":"<pre><code>text\n</code></pre> <p>Visible text content of the element.</p>"},{"location":"api/elements/web_element/#pydoll.elements.web_element.WebElement.bounds","title":"bounds  <code>async</code> <code>property</code>","text":"<pre><code>bounds\n</code></pre> <p>Element's bounding box coordinates.</p> <p>Returns coordinates in CSS pixels relative to document origin.</p>"},{"location":"api/elements/web_element/#pydoll.elements.web_element.WebElement.inner_html","title":"inner_html  <code>async</code> <code>property</code>","text":"<pre><code>inner_html\n</code></pre> <p>Element's HTML content (actually returns outerHTML).</p>"},{"location":"api/elements/web_element/#pydoll.elements.web_element.WebElement.get_bounds_using_js","title":"get_bounds_using_js  <code>async</code>","text":"<pre><code>get_bounds_using_js()\n</code></pre> <p>Get element bounds using JavaScript getBoundingClientRect().</p> <p>Returns coordinates relative to viewport (alternative to bounds property).</p>"},{"location":"api/elements/web_element/#pydoll.elements.web_element.WebElement.take_screenshot","title":"take_screenshot  <code>async</code>","text":"<pre><code>take_screenshot(path, quality=100)\n</code></pre> <p>Capture screenshot of this element only.</p> <p>Automatically scrolls element into view before capturing.</p>"},{"location":"api/elements/web_element/#pydoll.elements.web_element.WebElement.get_attribute","title":"get_attribute","text":"<pre><code>get_attribute(name)\n</code></pre> <p>Get element attribute value.</p> Note <p>Only provides attributes available when element was located. For dynamic attributes, consider using JavaScript execution.</p>"},{"location":"api/elements/web_element/#pydoll.elements.web_element.WebElement.scroll_into_view","title":"scroll_into_view  <code>async</code>","text":"<pre><code>scroll_into_view()\n</code></pre> <p>Scroll element into visible viewport.</p>"},{"location":"api/elements/web_element/#pydoll.elements.web_element.WebElement.click_using_js","title":"click_using_js  <code>async</code>","text":"<pre><code>click_using_js()\n</code></pre> <p>Click element using JavaScript click() method.</p> RAISES DESCRIPTION <code>ElementNotVisible</code> <p>If element is not visible.</p> <code>ElementNotInteractable</code> <p>If element couldn't be clicked.</p> Note <p>For  elements, uses specialized selection approach. Element is automatically scrolled into view."},{"location":"api/elements/web_element/#pydoll.elements.web_element.WebElement.click","title":"click  <code>async</code>","text":"<pre><code>click(x_offset=0, y_offset=0, hold_time=0.1)\n</code></pre> <p>Click element using simulated mouse events.</p> PARAMETER DESCRIPTION <code>x_offset</code> <p>Horizontal offset from element center.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>y_offset</code> <p>Vertical offset from element center.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>hold_time</code> <p>Duration to hold mouse button down.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.1</code> </p> RAISES DESCRIPTION <code>ElementNotVisible</code> <p>If element is not visible.</p> Note <p>For  elements, delegates to specialized JavaScript approach. Element is automatically scrolled into view."},{"location":"api/elements/web_element/#pydoll.elements.web_element.WebElement.insert_text","title":"insert_text  <code>async</code>","text":"<pre><code>insert_text(text)\n</code></pre> <p>Insert text in single operation (faster but less realistic than typing).</p> Note <p>Element should already be focused for text to be inserted correctly.</p>"},{"location":"api/elements/web_element/#pydoll.elements.web_element.WebElement.set_input_files","title":"set_input_files  <code>async</code>","text":"<pre><code>set_input_files(files)\n</code></pre> <p>Set file paths for file input element.</p> PARAMETER DESCRIPTION <code>files</code> <p>list of absolute file paths to existing files.</p> <p> TYPE: <code>list[str]</code> </p> RAISES DESCRIPTION <code>ElementNotAFileInput</code> <p>If element is not a file input.</p>"},{"location":"api/elements/web_element/#pydoll.elements.web_element.WebElement.type_text","title":"type_text  <code>async</code>","text":"<pre><code>type_text(text, interval=0.1)\n</code></pre> <p>Type text character by character with realistic timing.</p> <p>More realistic than insert_text() but slower.</p>"},{"location":"api/elements/web_element/#pydoll.elements.web_element.WebElement.key_down","title":"key_down  <code>async</code>","text":"<pre><code>key_down(key, modifiers=None)\n</code></pre> <p>Send key down event.</p> Note <p>Only sends key down without release. Pair with key_up() for complete keypress.</p>"},{"location":"api/elements/web_element/#pydoll.elements.web_element.WebElement.key_up","title":"key_up  <code>async</code>","text":"<pre><code>key_up(key)\n</code></pre> <p>Send key up event (should follow corresponding key_down()).</p>"},{"location":"api/elements/web_element/#pydoll.elements.web_element.WebElement.press_keyboard_key","title":"press_keyboard_key  <code>async</code>","text":"<pre><code>press_keyboard_key(key, modifiers=None, interval=0.1)\n</code></pre> <p>Press and release keyboard key with configurable timing.</p> <p>Better for special keys (Enter, Tab, etc.) than type_text().</p>"},{"location":"api/elements/web_element/#pydoll.elements.web_element.WebElement.find","title":"find  <code>async</code>","text":"<pre><code>find(id=None, class_name=None, name=None, tag_name=None, text=None, timeout=0, find_all=False, raise_exc=True, **attributes)\n</code></pre> <p>Find element(s) using combination of common HTML attributes.</p> <p>Flexible element location using standard attributes. Multiple attributes can be combined for specific selectors (builds XPath when multiple specified).</p> PARAMETER DESCRIPTION <code>id</code> <p>Element ID attribute value.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>class_name</code> <p>CSS class name to match.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>name</code> <p>Element name attribute value.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>tag_name</code> <p>HTML tag name (e.g., \"div\", \"input\").</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>text</code> <p>Text content to match within element.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>Maximum seconds to wait for elements to appear.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>find_all</code> <p>If True, returns all matches; if False, first match only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>raise_exc</code> <p>Whether to raise exception if no elements found.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>**attributes</code> <p>Additional HTML attributes to match.</p> <p> TYPE: <code>dict[str, str]</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Union[WebElement, list[WebElement], None]</code> <p>WebElement, list[WebElement], or None based on find_all and raise_exc.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If no search criteria provided.</p> <code>ElementNotFound</code> <p>If no elements found and raise_exc=True.</p> <code>WaitElementTimeout</code> <p>If timeout specified and no elements appear in time.</p>"},{"location":"api/elements/web_element/#pydoll.elements.web_element.WebElement.query","title":"query  <code>async</code>","text":"<pre><code>query(expression, timeout=0, find_all=False, raise_exc=True)\n</code></pre> <p>Find element(s) using raw CSS selector or XPath expression.</p> <p>Direct access using CSS or XPath syntax. Selector type automatically determined based on expression pattern.</p> PARAMETER DESCRIPTION <code>expression</code> <p>Selector expression (CSS, XPath, ID with #, class with .).</p> <p> TYPE: <code>str</code> </p> <code>timeout</code> <p>Maximum seconds to wait for elements to appear.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>find_all</code> <p>If True, returns all matches; if False, first match only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>raise_exc</code> <p>Whether to raise exception if no elements found.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Union[WebElement, list[WebElement], None]</code> <p>WebElement, list[WebElement], or None based on find_all and raise_exc.</p> RAISES DESCRIPTION <code>ElementNotFound</code> <p>If no elements found and raise_exc=True.</p> <code>WaitElementTimeout</code> <p>If timeout specified and no elements appear in time.</p>"},{"location":"api/elements/web_element/#pydoll.elements.web_element.WebElement.find_or_wait_element","title":"find_or_wait_element  <code>async</code>","text":"<pre><code>find_or_wait_element(by, value, timeout=0, find_all=False, raise_exc=True)\n</code></pre> <p>Core element finding method with optional waiting capability.</p> <p>Searches for elements with flexible waiting. If timeout specified, repeatedly attempts to find elements with 0.5s delays until success or timeout. Used by higher-level find() and query() methods.</p> PARAMETER DESCRIPTION <code>by</code> <p>Selector strategy (CSS_SELECTOR, XPATH, ID, etc.).</p> <p> TYPE: <code>By</code> </p> <code>value</code> <p>Selector value to locate element(s).</p> <p> TYPE: <code>str</code> </p> <code>timeout</code> <p>Maximum seconds to wait (0 = no waiting).</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>find_all</code> <p>If True, returns all matches; if False, first match only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>raise_exc</code> <p>Whether to raise exception if no elements found.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Union[WebElement, list[WebElement], None]</code> <p>WebElement, list[WebElement], or None based on find_all and raise_exc.</p> RAISES DESCRIPTION <code>ElementNotFound</code> <p>If no elements found with timeout=0 and raise_exc=True.</p> <code>WaitElementTimeout</code> <p>If elements not found within timeout and raise_exc=True.</p>"},{"location":"api/protocol/commands/","title":"Protocol Commands","text":"<p>This section documents the Chrome DevTools Protocol command implementations used by Pydoll.</p>"},{"location":"api/protocol/commands/#page-commands","title":"Page Commands","text":""},{"location":"api/protocol/commands/#pydoll.commands.page_commands","title":"pydoll.commands.page_commands","text":""},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands","title":"PageCommands","text":"<p>This class encapsulates the page commands of the Chrome DevTools Protocol (CDP).</p> <p>CDP's Page domain allows for interacting with browser pages, including navigation, content manipulation, and page state monitoring. These commands provide powerful capabilities for web automation, testing, and debugging.</p> <p>The commands defined in this class provide functionality for: - Navigating to URLs and managing page history - Capturing screenshots and generating PDFs - Handling JavaScript dialogs - Enabling and controlling page events - Managing download behavior - Manipulating page content and state</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.add_script_to_evaluate_on_new_document","title":"add_script_to_evaluate_on_new_document  <code>staticmethod</code>","text":"<pre><code>add_script_to_evaluate_on_new_document(source, world_name=None, include_command_line_api=None, run_immediately=None)\n</code></pre> <p>Creates a command to add a script that will be evaluated when a new document is created.</p> PARAMETER DESCRIPTION <code>source</code> <p>Script source to be evaluated when a new document is created.</p> <p> TYPE: <code>str</code> </p> <code>world_name</code> <p>If specified, creates an isolated world with the given name.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>include_command_line_api</code> <p>Whether to include command line API.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>run_immediately</code> <p>Whether to run the script immediately on existing contexts.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[AddScriptToEvaluateOnNewDocumentResponse]</code> <p>Command[AddScriptToEvaluateOnNewDocumentResponse]: Command object with the identifier of the added script.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.bring_to_front","title":"bring_to_front  <code>staticmethod</code>","text":"<pre><code>bring_to_front()\n</code></pre> <p>Brings the page to front.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.capture_screenshot","title":"capture_screenshot  <code>staticmethod</code>","text":"<pre><code>capture_screenshot(format=None, quality=None, clip=None, from_surface=None, capture_beyond_viewport=None, optimize_for_speed=None)\n</code></pre> <p>Creates a command to capture a screenshot of the current page.</p> PARAMETER DESCRIPTION <code>format</code> <p>Image compression format (jpeg, png, or webp).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>quality</code> <p>Compression quality from 0-100 (jpeg only).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>clip</code> <p>Region of the page to capture.</p> <p> TYPE: <code>Optional[Viewport]</code> DEFAULT: <code>None</code> </p> <code>from_surface</code> <p>Capture from the surface, not the view.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>capture_beyond_viewport</code> <p>Capture beyond the viewport.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>optimize_for_speed</code> <p>Optimize for speed, not for size.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[CaptureScreenshotResponse]</code> <p>Command[CaptureScreenshotResponse]: Command object with base64-encoded image data.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.close","title":"close  <code>staticmethod</code>","text":"<pre><code>close()\n</code></pre> <p>Creates a command to close the current page.</p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to close the page.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.create_isolated_world","title":"create_isolated_world  <code>staticmethod</code>","text":"<pre><code>create_isolated_world(frame_id, world_name=None, grant_universal_access=None)\n</code></pre> <p>Creates a command to create an isolated world for the given frame.</p> PARAMETER DESCRIPTION <code>frame_id</code> <p>ID of the frame in which to create the isolated world.</p> <p> TYPE: <code>str</code> </p> <code>world_name</code> <p>Name to be reported in the Execution Context.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>grant_universal_access</code> <p>Whether to grant universal access.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[CreateIsolatedWorldResponse]</code> <p>Command[CreateIsolatedWorldResponse]: Command object with the execution context ID.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.disable","title":"disable  <code>staticmethod</code>","text":"<pre><code>disable()\n</code></pre> <p>Creates a command to disable page domain notifications.</p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to disable the Page domain.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.enable","title":"enable  <code>staticmethod</code>","text":"<pre><code>enable(enable_file_chooser_opened_event=None)\n</code></pre> <p>Creates a command to enable page domain notifications.</p> PARAMETER DESCRIPTION <code>enable_file_chooser_opened_event</code> <p>Whether to emit Page.fileChooserOpened event.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to enable the Page domain.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.get_app_manifest","title":"get_app_manifest  <code>staticmethod</code>","text":"<pre><code>get_app_manifest(manifest_id=None)\n</code></pre> <p>Creates a command to get the manifest for the current document.</p> RETURNS DESCRIPTION <code>Command[GetAppManifestResponse]</code> <p>Command[GetAppManifestResponse]: Command object with manifest information.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.get_frame_tree","title":"get_frame_tree  <code>staticmethod</code>","text":"<pre><code>get_frame_tree()\n</code></pre> <p>Creates a command to get the frame tree for the current page.</p> RETURNS DESCRIPTION <code>Command[GetFrameTreeResponse]</code> <p>Command[GetFrameTreeResponse]: Command object with frame tree information.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.get_layout_metrics","title":"get_layout_metrics  <code>staticmethod</code>","text":"<pre><code>get_layout_metrics()\n</code></pre> <p>Creates a command to get layout metrics for the page.</p> RETURNS DESCRIPTION <code>Command[GetLayoutMetricsResponse]</code> <p>Command[GetLayoutMetricsResponse]: Command object with layout metrics.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.get_navigation_history","title":"get_navigation_history  <code>staticmethod</code>","text":"<pre><code>get_navigation_history()\n</code></pre> <p>Creates a command to get the navigation history for the current page.</p> RETURNS DESCRIPTION <code>Command[GetNavigationHistoryResponse]</code> <p>Command[GetNavigationHistoryResponse]: Command object with navigation history.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.handle_javascript_dialog","title":"handle_javascript_dialog  <code>staticmethod</code>","text":"<pre><code>handle_javascript_dialog(accept, prompt_text=None)\n</code></pre> <p>Creates a command to handle a JavaScript dialog.</p> PARAMETER DESCRIPTION <code>accept</code> <p>Whether to accept or dismiss the dialog.</p> <p> TYPE: <code>bool</code> </p> <code>prompt_text</code> <p>Text to enter in prompt dialogs.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to handle a JavaScript dialog.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.navigate","title":"navigate  <code>staticmethod</code>","text":"<pre><code>navigate(url, referrer=None, transition_type=None, frame_id=None, referrer_policy=None)\n</code></pre> <p>Creates a command to navigate to a specific URL.</p> PARAMETER DESCRIPTION <code>url</code> <p>URL to navigate to.</p> <p> TYPE: <code>str</code> </p> <code>referrer</code> <p>Referrer URL.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>transition_type</code> <p>Intended transition type.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>frame_id</code> <p>Frame ID to navigate.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>referrer_policy</code> <p>Referrer policy.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[NavigateResponse]</code> <p>Command[NavigateResponse]: Command object to navigate to a URL.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.navigate_to_history_entry","title":"navigate_to_history_entry  <code>staticmethod</code>","text":"<pre><code>navigate_to_history_entry(entry_id)\n</code></pre> <p>Creates a command to navigate to a specific history entry.</p> PARAMETER DESCRIPTION <code>entry_id</code> <p>ID of the history entry to navigate to.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to navigate to a history entry.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.print_to_pdf","title":"print_to_pdf  <code>staticmethod</code>","text":"<pre><code>print_to_pdf(landscape=None, display_header_footer=None, print_background=None, scale=None, paper_width=None, paper_height=None, margin_top=None, margin_bottom=None, margin_left=None, margin_right=None, page_ranges=None, header_template=None, footer_template=None, prefer_css_page_size=None, transfer_mode=None, generate_tagged_pdf=None, generate_document_outline=None)\n</code></pre> <p>Creates a command to print the current page to PDF.</p> PARAMETER DESCRIPTION <code>landscape</code> <p>Paper orientation.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>display_header_footer</code> <p>Display header and footer.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>print_background</code> <p>Print background graphics.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>scale</code> <p>Scale of the webpage rendering.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>paper_width</code> <p>Paper width in inches.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>paper_height</code> <p>Paper height in inches.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>margin_top</code> <p>Top margin in inches.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>margin_bottom</code> <p>Bottom margin in inches.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>margin_left</code> <p>Left margin in inches.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>margin_right</code> <p>Right margin in inches.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>page_ranges</code> <p>Paper ranges to print, e.g., '1-5, 8, 11-13'.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>header_template</code> <p>HTML template for the print header.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>footer_template</code> <p>HTML template for the print footer.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>prefer_css_page_size</code> <p>Whether to prefer page size as defined by CSS.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>transfer_mode</code> <p>Transfer mode.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[PrintToPDFResponse]</code> <p>Command[PrintToPDFResponse]: Command object to print the page to PDF.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.reload","title":"reload  <code>staticmethod</code>","text":"<pre><code>reload(ignore_cache=None, script_to_evaluate_on_load=None, loader_id=None)\n</code></pre> <p>Creates a command to reload the current page.</p> PARAMETER DESCRIPTION <code>ignore_cache</code> <p>If true, browser cache is ignored.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>script_to_evaluate_on_load</code> <p>Script to be injected into the page on load.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to reload the page.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.reset_navigation_history","title":"reset_navigation_history  <code>staticmethod</code>","text":"<pre><code>reset_navigation_history()\n</code></pre> <p>Creates a command to reset the navigation history.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.remove_script_to_evaluate_on_new_document","title":"remove_script_to_evaluate_on_new_document  <code>staticmethod</code>","text":"<pre><code>remove_script_to_evaluate_on_new_document(identifier)\n</code></pre> <p>Creates a command to remove a script that was added to be evaluated on new documents.</p> PARAMETER DESCRIPTION <code>identifier</code> <p>Identifier of the script to remove.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to remove a script.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.set_bypass_csp","title":"set_bypass_csp  <code>staticmethod</code>","text":"<pre><code>set_bypass_csp(enabled)\n</code></pre> <p>Creates a command to toggle bypassing page CSP.</p> PARAMETER DESCRIPTION <code>enabled</code> <p>Whether to bypass page CSP.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to toggle bypassing page CSP.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.set_document_content","title":"set_document_content  <code>staticmethod</code>","text":"<pre><code>set_document_content(frame_id, html)\n</code></pre> <p>Creates a command to set the document content of a frame.</p> PARAMETER DESCRIPTION <code>frame_id</code> <p>Frame ID to set the document content for.</p> <p> TYPE: <code>str</code> </p> <code>html</code> <p>HTML content to set.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to set the document content.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.set_intercept_file_chooser_dialog","title":"set_intercept_file_chooser_dialog  <code>staticmethod</code>","text":"<pre><code>set_intercept_file_chooser_dialog(enabled)\n</code></pre> <p>Creates a command to set whether to intercept file chooser dialogs.</p> PARAMETER DESCRIPTION <code>enabled</code> <p>Whether to intercept file chooser dialogs.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to set file chooser dialog interception.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.set_lifecycle_events_enabled","title":"set_lifecycle_events_enabled  <code>staticmethod</code>","text":"<pre><code>set_lifecycle_events_enabled(enabled)\n</code></pre> <p>Creates a command to enable/disable lifecycle events.</p> PARAMETER DESCRIPTION <code>enabled</code> <p>Whether to enable lifecycle events.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to enable/disable lifecycle events.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.stop_loading","title":"stop_loading  <code>staticmethod</code>","text":"<pre><code>stop_loading()\n</code></pre> <p>Creates a command to stop loading the page.</p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to stop loading the page.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.add_compilation_cache","title":"add_compilation_cache  <code>staticmethod</code>","text":"<pre><code>add_compilation_cache(url, data)\n</code></pre> <p>Creates a command to add a compilation cache entry.</p> <p>Experimental: This method is experimental and may be subject to change.</p> PARAMETER DESCRIPTION <code>url</code> <p>URL for which to add the compilation cache entry.</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>Base64-encoded data.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to add a compilation cache entry.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.capture_snapshot","title":"capture_snapshot  <code>staticmethod</code>","text":"<pre><code>capture_snapshot(format='mhtml')\n</code></pre> <p>Creates a command to capture a snapshot of the page.</p> <p>Experimental: This method is experimental and may be subject to change.</p> PARAMETER DESCRIPTION <code>format</code> <p>Format of the snapshot (only 'mhtml' is supported).</p> <p> TYPE: <code>Literal['mhtml']</code> DEFAULT: <code>'mhtml'</code> </p> RETURNS DESCRIPTION <code>Command[CaptureSnapshotResponse]</code> <p>Command[CaptureSnapshotResponse]: Command object to capture a snapshot.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.clear_compilation_cache","title":"clear_compilation_cache  <code>staticmethod</code>","text":"<pre><code>clear_compilation_cache()\n</code></pre> <p>Creates a command to clear the compilation cache.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.crash","title":"crash  <code>staticmethod</code>","text":"<pre><code>crash()\n</code></pre> <p>Creates a command to crash the page.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.generate_test_report","title":"generate_test_report  <code>staticmethod</code>","text":"<pre><code>generate_test_report(message, group=None)\n</code></pre> <p>Creates a command to generate a test report.</p> <p>Experimental: This method is experimental and may be subject to change.</p> PARAMETER DESCRIPTION <code>message</code> <p>Message to be displayed in the report.</p> <p> TYPE: <code>str</code> </p> <code>group</code> <p>Group label for the report.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to generate a test report.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.get_ad_script_ancestry_ids","title":"get_ad_script_ancestry_ids  <code>staticmethod</code>","text":"<pre><code>get_ad_script_ancestry_ids(frame_id)\n</code></pre> <p>Creates a command to get the ad script ancestry IDs for a given frame.</p> <p>Experimental: This method is experimental and may be subject to change.</p> PARAMETER DESCRIPTION <code>frame_id</code> <p>ID of the frame to get ad script ancestry IDs for.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command[GetAdScriptAncestryIdsResponse]</code> <p>Command[GetAdScriptAncestryIdsResponse]: Command object to get ad script ancestry IDs.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.get_app_id","title":"get_app_id  <code>staticmethod</code>","text":"<pre><code>get_app_id(app_id=None, recommended_id=None)\n</code></pre> <p>Creates a command to get the app ID.</p> <p>Experimental: This method is experimental and may be subject to change.</p> PARAMETER DESCRIPTION <code>app_id</code> <p>App ID for verification.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>recommended_id</code> <p>Recommended app ID.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[GetAppIdResponse]</code> <p>Command[GetAppIdResponse]: Command object to get the app ID.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.get_installability_errors","title":"get_installability_errors  <code>staticmethod</code>","text":"<pre><code>get_installability_errors()\n</code></pre> <p>Creates a command to get the installability errors.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.get_origin_trials","title":"get_origin_trials  <code>staticmethod</code>","text":"<pre><code>get_origin_trials(frame_id)\n</code></pre> <p>Creates a command to get origin trials for a given origin.</p> <p>Experimental: This method is experimental and may be subject to change.</p> PARAMETER DESCRIPTION <code>frame_id</code> <p>Frame ID to get trials for.</p> <p> TYPE: <code>Optional[str]</code> </p> RETURNS DESCRIPTION <code>Command[GetOriginTrialsResponse]</code> <p>Command[GetOriginTrialsResponse]: Command object to get origin trials.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.get_permissions_policy_state","title":"get_permissions_policy_state  <code>staticmethod</code>","text":"<pre><code>get_permissions_policy_state(frame_id)\n</code></pre> <p>Creates a command to get the permissions policy state.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.get_resource_content","title":"get_resource_content  <code>staticmethod</code>","text":"<pre><code>get_resource_content(frame_id, url)\n</code></pre> <p>Creates a command to get the resource content.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.get_resource_tree","title":"get_resource_tree  <code>staticmethod</code>","text":"<pre><code>get_resource_tree()\n</code></pre> <p>Creates a command to get the resource tree.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.produce_compilation_cache","title":"produce_compilation_cache  <code>staticmethod</code>","text":"<pre><code>produce_compilation_cache(scripts)\n</code></pre> <p>Creates a command to produce a compilation cache entry.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.screencast_frame_ack","title":"screencast_frame_ack  <code>staticmethod</code>","text":"<pre><code>screencast_frame_ack(session_id)\n</code></pre> <p>Creates a command to acknowledge a screencast frame.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.search_in_resource","title":"search_in_resource  <code>staticmethod</code>","text":"<pre><code>search_in_resource(frame_id, url, query, case_sensitive=None, is_regex=None)\n</code></pre> <p>Creates a command to search for a string in a resource.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.set_ad_blocking_enabled","title":"set_ad_blocking_enabled  <code>staticmethod</code>","text":"<pre><code>set_ad_blocking_enabled(enabled)\n</code></pre> <p>Creates a command to set ad blocking enabled.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.set_font_families","title":"set_font_families  <code>staticmethod</code>","text":"<pre><code>set_font_families(font_families, for_scripts)\n</code></pre> <p>Creates a command to set font families.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.set_font_sizes","title":"set_font_sizes  <code>staticmethod</code>","text":"<pre><code>set_font_sizes(font_sizes)\n</code></pre> <p>Creates a command to set font sizes.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.set_prerendering_allowed","title":"set_prerendering_allowed  <code>staticmethod</code>","text":"<pre><code>set_prerendering_allowed(allowed)\n</code></pre> <p>Creates a command to set prerendering allowed.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.set_rph_registration_mode","title":"set_rph_registration_mode  <code>staticmethod</code>","text":"<pre><code>set_rph_registration_mode(mode)\n</code></pre> <p>Creates a command to set the RPH registration mode.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.set_spc_transaction_mode","title":"set_spc_transaction_mode  <code>staticmethod</code>","text":"<pre><code>set_spc_transaction_mode(mode)\n</code></pre> <p>Creates a command to set the SPC transaction mode.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.set_web_lifecycle_state","title":"set_web_lifecycle_state  <code>staticmethod</code>","text":"<pre><code>set_web_lifecycle_state(state)\n</code></pre> <p>Creates a command to set the web lifecycle state.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.start_screencast","title":"start_screencast  <code>staticmethod</code>","text":"<pre><code>start_screencast(format, quality=None, max_width=None, max_height=None, every_nth_frame=None)\n</code></pre> <p>Creates a command to start a screencast.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.stop_screencast","title":"stop_screencast  <code>staticmethod</code>","text":"<pre><code>stop_screencast()\n</code></pre> <p>Creates a command to stop a screencast.</p>"},{"location":"api/protocol/commands/#pydoll.commands.page_commands.PageCommands.wait_for_debugger","title":"wait_for_debugger  <code>staticmethod</code>","text":"<pre><code>wait_for_debugger()\n</code></pre> <p>Creates a command to wait for a debugger.</p>"},{"location":"api/protocol/commands/#runtime-commands","title":"Runtime Commands","text":""},{"location":"api/protocol/commands/#pydoll.commands.runtime_commands","title":"pydoll.commands.runtime_commands","text":""},{"location":"api/protocol/commands/#pydoll.commands.runtime_commands.RuntimeCommands","title":"RuntimeCommands","text":"<p>A class for interacting with the JavaScript runtime using Chrome DevTools Protocol.</p> <p>This class provides methods to create commands for evaluating JavaScript expressions, calling functions on JavaScript objects, and retrieving object properties through CDP.</p> ATTRIBUTE DESCRIPTION <code>EVALUATE_TEMPLATE</code> <p>Template for the Runtime.evaluate command.</p> <p> TYPE: <code>dict</code> </p> <code>CALL_FUNCTION_ON_TEMPLATE</code> <p>Template for the Runtime.callFunctionOn command.</p> <p> TYPE: <code>dict</code> </p> <code>GET_PROPERTIES</code> <p>Template for the Runtime.getProperties command.</p> <p> TYPE: <code>dict</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.runtime_commands.RuntimeCommands.add_binding","title":"add_binding  <code>staticmethod</code>","text":"<pre><code>add_binding(name, execution_context_name=None)\n</code></pre> <p>Creates a command to add a JavaScript binding.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the binding to add.</p> <p> TYPE: <code>str</code> </p> <code>execution_context_name</code> <p>Name of the execution context to bind to.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to add a JavaScript binding.</p>"},{"location":"api/protocol/commands/#pydoll.commands.runtime_commands.RuntimeCommands.await_promise","title":"await_promise  <code>staticmethod</code>","text":"<pre><code>await_promise(promise_object_id, return_by_value=None, generate_preview=None)\n</code></pre> <p>Creates a command to await a JavaScript promise and return its result.</p> PARAMETER DESCRIPTION <code>promise_object_id</code> <p>ID of the promise to await.</p> <p> TYPE: <code>str</code> </p> <code>return_by_value</code> <p>Whether to return the result by value instead of reference.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>generate_preview</code> <p>Whether to generate a preview for the result.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[AwaitPromiseResponse]</code> <p>Command[AwaitPromiseResponse]: Command object to await a promise.</p>"},{"location":"api/protocol/commands/#pydoll.commands.runtime_commands.RuntimeCommands.call_function_on","title":"call_function_on  <code>staticmethod</code>","text":"<pre><code>call_function_on(function_declaration, object_id=None, arguments=None, silent=None, return_by_value=None, generate_preview=None, user_gesture=None, await_promise=None, execution_context_id=None, object_group=None, throw_on_side_effect=None, unique_context_id=None, serialization_options=None)\n</code></pre> <p>Creates a command to call a function with a given declaration on a specific object.</p> PARAMETER DESCRIPTION <code>function_declaration</code> <p>Declaration of the function to call.</p> <p> TYPE: <code>str</code> </p> <code>object_id</code> <p>ID of the object to call the function on.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>arguments</code> <p>Arguments to pass to the function.</p> <p> TYPE: <code>Optional[list[CallArgument]]</code> DEFAULT: <code>None</code> </p> <code>silent</code> <p>Whether to silence exceptions.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>return_by_value</code> <p>Whether to return the result by value instead of reference.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>generate_preview</code> <p>Whether to generate a preview for the result.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>user_gesture</code> <p>Whether to treat the call as initiated by user gesture.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>await_promise</code> <p>Whether to await promise result.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>execution_context_id</code> <p>ID of the execution context to call the function in.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>object_group</code> <p>Symbolic group name for the result.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>throw_on_side_effect</code> <p>Whether to throw if side effect cannot be ruled out.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>unique_context_id</code> <p>Unique context ID for the function call.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>serialization_options</code> <p>Serialization options for the result.</p> <p> TYPE: <code>Optional[SerializationOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[CallFunctionOnResponse]</code> <p>Command[CallFunctionOnResponse]: Command object to call a function on an object.</p>"},{"location":"api/protocol/commands/#pydoll.commands.runtime_commands.RuntimeCommands.compile_script","title":"compile_script  <code>staticmethod</code>","text":"<pre><code>compile_script(expression, source_url=None, persist_script=None, execution_context_id=None)\n</code></pre> <p>Creates a command to compile a JavaScript expression.</p> PARAMETER DESCRIPTION <code>expression</code> <p>JavaScript expression to compile.</p> <p> TYPE: <code>str</code> </p> <code>source_url</code> <p>URL of the source file for the script.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>persist_script</code> <p>Whether to persist the compiled script.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>execution_context_id</code> <p>ID of the execution context to compile the script in.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[CompileScriptResponse]</code> <p>Command[CompileScriptResponse]: Command object to compile a script.</p>"},{"location":"api/protocol/commands/#pydoll.commands.runtime_commands.RuntimeCommands.disable","title":"disable  <code>staticmethod</code>","text":"<pre><code>disable()\n</code></pre> <p>Disables the runtime domain.</p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to disable the runtime domain.</p>"},{"location":"api/protocol/commands/#pydoll.commands.runtime_commands.RuntimeCommands.enable","title":"enable  <code>staticmethod</code>","text":"<pre><code>enable()\n</code></pre> <p>Enables the runtime domain.</p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to enable the runtime domain.</p>"},{"location":"api/protocol/commands/#pydoll.commands.runtime_commands.RuntimeCommands.evaluate","title":"evaluate  <code>staticmethod</code>","text":"<pre><code>evaluate(expression, object_group=None, include_command_line_api=None, silent=None, context_id=None, return_by_value=None, generate_preview=None, user_gesture=None, await_promise=None, throw_on_side_effect=None, timeout=None, disable_breaks=None, repl_mode=None, allow_unsafe_eval_blocked_by_csp=None, unique_context_id=None, serialization_options=None)\n</code></pre> <p>Creates a command to evaluate a JavaScript expression in the global context.</p> PARAMETER DESCRIPTION <code>expression</code> <p>JavaScript expression to evaluate.</p> <p> TYPE: <code>str</code> </p> <code>object_group</code> <p>Symbolic group name for the result.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>include_command_line_api</code> <p>Whether to include command line API.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>silent</code> <p>Whether to silence exceptions.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>context_id</code> <p>ID of the execution context to evaluate in.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>return_by_value</code> <p>Whether to return the result by value instead of reference.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>generate_preview</code> <p>Whether to generate a preview for the result.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>user_gesture</code> <p>Whether to treat evaluation as initiated by user gesture.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>await_promise</code> <p>Whether to await promise result.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>throw_on_side_effect</code> <p>Whether to throw if side effect cannot be ruled out.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>Timeout in milliseconds.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>disable_breaks</code> <p>Whether to disable breakpoints during evaluation.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>repl_mode</code> <p>Whether to execute in REPL mode.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>allow_unsafe_eval_blocked_by_csp</code> <p>Allow unsafe evaluation.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>unique_context_id</code> <p>Unique context ID for evaluation.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>serialization_options</code> <p>Serialization for the result.</p> <p> TYPE: <code>Optional[SerializationOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[EvaluateResponse]</code> <p>Command[EvaluateResponse]: Command object to evaluate JavaScript.</p>"},{"location":"api/protocol/commands/#pydoll.commands.runtime_commands.RuntimeCommands.get_properties","title":"get_properties  <code>staticmethod</code>","text":"<pre><code>get_properties(object_id, own_properties=None, accessor_properties_only=None, generate_preview=None, non_indexed_properties_only=None)\n</code></pre> <p>Creates a command to get properties of a JavaScript object.</p> PARAMETER DESCRIPTION <code>object_id</code> <p>ID of the object to get properties for.</p> <p> TYPE: <code>str</code> </p> <code>own_properties</code> <p>Whether to return only own properties.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>accessor_properties_only</code> <p>Whether to return only accessor properties.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>generate_preview</code> <p>Whether to generate previews for property values.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>non_indexed_properties_only</code> <p>Whether to return only non-indexed properties.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[GetPropertiesResponse]</code> <p>Command[GetPropertiesResponse]: Command object to get object properties.</p>"},{"location":"api/protocol/commands/#pydoll.commands.runtime_commands.RuntimeCommands.global_lexical_scope_names","title":"global_lexical_scope_names  <code>staticmethod</code>","text":"<pre><code>global_lexical_scope_names(execution_context_id=None)\n</code></pre> <p>Creates a command to retrieve names of variables from global lexical scope.</p> PARAMETER DESCRIPTION <code>execution_context_id</code> <p>ID of the execution context to get scope names from.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[GlobalLexicalScopeNamesResponse]</code> <p>Command[GlobalLexicalScopeNamesResponse]: Command object to get global lexical scope names.</p>"},{"location":"api/protocol/commands/#pydoll.commands.runtime_commands.RuntimeCommands.query_objects","title":"query_objects  <code>staticmethod</code>","text":"<pre><code>query_objects(prototype_object_id, object_group=None)\n</code></pre> <p>Creates a command to query objects with a given prototype.</p> PARAMETER DESCRIPTION <code>prototype_object_id</code> <p>ID of the prototype object.</p> <p> TYPE: <code>str</code> </p> <code>object_group</code> <p>Symbolic group name for the results.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[QueryObjectsResponse]</code> <p>Command[QueryObjectsResponse]: Command object to query objects.</p>"},{"location":"api/protocol/commands/#pydoll.commands.runtime_commands.RuntimeCommands.release_object","title":"release_object  <code>staticmethod</code>","text":"<pre><code>release_object(object_id)\n</code></pre> <p>Creates a command to release a JavaScript object.</p> PARAMETER DESCRIPTION <code>object_id</code> <p>ID of the object to release.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to release an object.</p>"},{"location":"api/protocol/commands/#pydoll.commands.runtime_commands.RuntimeCommands.release_object_group","title":"release_object_group  <code>staticmethod</code>","text":"<pre><code>release_object_group(object_group)\n</code></pre> <p>Creates a command to release all objects in a group.</p> PARAMETER DESCRIPTION <code>object_group</code> <p>Name of the object group to release.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to release an object group.</p>"},{"location":"api/protocol/commands/#pydoll.commands.runtime_commands.RuntimeCommands.remove_binding","title":"remove_binding  <code>staticmethod</code>","text":"<pre><code>remove_binding(name)\n</code></pre> <p>Creates a command to remove a JavaScript binding.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the binding to remove.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to remove a JavaScript binding.</p>"},{"location":"api/protocol/commands/#pydoll.commands.runtime_commands.RuntimeCommands.run_script","title":"run_script  <code>staticmethod</code>","text":"<pre><code>run_script(script_id, execution_context_id=None, object_group=None, silent=None, include_command_line_api=None, return_by_value=None, generate_preview=None, await_promise=None)\n</code></pre> <p>Creates a command to run a compiled script.</p> PARAMETER DESCRIPTION <code>script_id</code> <p>ID of the compiled script to run.</p> <p> TYPE: <code>str</code> </p> <code>execution_context_id</code> <p>ID of the execution context to run the script in.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>object_group</code> <p>Symbolic group name for the result.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>silent</code> <p>Whether to silence exceptions.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>include_command_line_api</code> <p>Whether to include command line API.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>return_by_value</code> <p>Whether to return the result by value instead of reference.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>generate_preview</code> <p>Whether to generate a preview for the result.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>await_promise</code> <p>Whether to await promise result.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[RunScriptResponse]</code> <p>Command[RunScriptResponse]: Command object to run a script.</p>"},{"location":"api/protocol/commands/#pydoll.commands.runtime_commands.RuntimeCommands.set_async_call_stack_depth","title":"set_async_call_stack_depth  <code>staticmethod</code>","text":"<pre><code>set_async_call_stack_depth(max_depth)\n</code></pre> <p>Creates a command to set the async call stack depth.</p> PARAMETER DESCRIPTION <code>max_depth</code> <p>Maximum depth of async call stacks.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to set async call stack depth.</p>"},{"location":"api/protocol/commands/#pydoll.commands.runtime_commands.RuntimeCommands.set_custom_object_formatter_enabled","title":"set_custom_object_formatter_enabled  <code>staticmethod</code>","text":"<pre><code>set_custom_object_formatter_enabled(enabled)\n</code></pre> <p>Creates a command to enable or disable custom object formatters.</p> PARAMETER DESCRIPTION <code>enabled</code> <p>Whether to enable custom object formatters.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to enable/disable custom object formatters.</p>"},{"location":"api/protocol/commands/#pydoll.commands.runtime_commands.RuntimeCommands.set_max_call_stack_size_to_capture","title":"set_max_call_stack_size_to_capture  <code>staticmethod</code>","text":"<pre><code>set_max_call_stack_size_to_capture(size)\n</code></pre> <p>Creates a command to set the maximum call stack size to capture.</p> PARAMETER DESCRIPTION <code>size</code> <p>Maximum call stack size to capture.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: Command object to set max call stack size.</p>"},{"location":"api/protocol/commands/#dom-commands","title":"DOM Commands","text":""},{"location":"api/protocol/commands/#pydoll.commands.dom_commands","title":"pydoll.commands.dom_commands","text":""},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands","title":"DomCommands","text":"<p>Implementation of Chrome DevTools Protocol for the DOM domain.</p> <p>This class provides commands for interacting with the Document Object Model (DOM) in the browser, enabling access and manipulation of the element structure in a web page. The DOM domain in Chrome DevTools Protocol exposes operations for reading and writing to the DOM, which is fundamental for browser automation, testing, and debugging.</p> <p>Each DOM element is represented by a mirror object with a unique ID. This ID can be used to gather additional information about the node, resolve it into JavaScript object wrappers, manipulate attributes, and perform various other operations on the DOM structure.</p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.describe_node","title":"describe_node  <code>staticmethod</code>","text":"<pre><code>describe_node(node_id=None, backend_node_id=None, object_id=None, depth=None, pierce=None)\n</code></pre> <p>Describes a DOM node identified by its ID without requiring domain to be enabled.</p> <p>The describe_node command is particularly useful in scenarios where you need to quickly gather information about a specific element without subscribing to DOM change events, making it more lightweight for isolated element inspection operations.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Identifier of the node known to the client.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>backend_node_id</code> <p>Identifier of the backend node used internally by the browser.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>object_id</code> <p>JavaScript object id of the node wrapper.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>depth</code> <p>Maximum depth at which children should be retrieved (default is 1).   Use -1 for the entire subtree or provide an integer greater than 0.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>pierce</code> <p>Whether iframes and shadow roots should be traversed when returning    the subtree (default is false).</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns detailed information about the requested node.</p> <p> TYPE: <code>Command[DescribeNodeResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.disable","title":"disable  <code>staticmethod</code>","text":"<pre><code>disable()\n</code></pre> <p>Disables DOM agent for the current page.</p> <p>Disabling the DOM domain stops the CDP from sending DOM-related events and prevents further DOM manipulation operations until the domain is enabled again. This can be important for optimizing performance when you're done with DOM operations and want to minimize background processing.</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to disable the DOM domain.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.enable","title":"enable  <code>staticmethod</code>","text":"<pre><code>enable(include_whitespace=None)\n</code></pre> <p>Enables DOM agent for the current page.</p> <p>Enabling the DOM domain is a prerequisite for receiving DOM events and using most DOM manipulation methods. The DOM events include changes to the DOM tree structure, attribute modifications, and many others. Without enabling this domain first, many DOM operations would fail or provide incomplete information.</p> PARAMETER DESCRIPTION <code>include_whitespace</code> <p>Whether to include whitespace-only text nodes in the                children array of returned Nodes. Allowed values: \"none\", \"all\".</p> <p> TYPE: <code>Optional[IncludeWhitespace]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to enable the DOM domain.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.focus","title":"focus  <code>staticmethod</code>","text":"<pre><code>focus(node_id=None, backend_node_id=None, object_id=None)\n</code></pre> <p>Focuses the given element.</p> <p>The focus command is crucial for simulating realistic user interactions, as many events (like keyboard input) require that an element has focus first. It's also important for testing proper tab order and keyboard accessibility of web pages.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Identifier of the node to focus.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>backend_node_id</code> <p>Identifier of the backend node to focus.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>object_id</code> <p>JavaScript object id of the node wrapper.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to focus on the specified element.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.get_attributes","title":"get_attributes  <code>staticmethod</code>","text":"<pre><code>get_attributes(node_id)\n</code></pre> <p>Returns attributes for the specified node.</p> <p>Attribute information is essential in web testing and automation because attributes often contain crucial information about element state, behavior, and metadata. This command provides an efficient way to access all attributes of an element without parsing HTML or using JavaScript evaluation.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to retrieve attributes for.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns an interleaved array of node attribute     names and values [name1, value1, name2, value2, ...].</p> <p> TYPE: <code>Command[GetAttributesResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.get_box_model","title":"get_box_model  <code>staticmethod</code>","text":"<pre><code>get_box_model(node_id=None, backend_node_id=None, object_id=None)\n</code></pre> <p>Returns box model information for the specified node.</p> <p>The box model is a fundamental concept in CSS that describes how elements are rendered with content, padding, borders, and margins. This command provides detailed information about these dimensions and coordinates, which is invaluable for spatial analysis and precision interactions with elements on the page.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Identifier of the node.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>backend_node_id</code> <p>Identifier of the backend node.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>object_id</code> <p>JavaScript object id of the node wrapper.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the box model for the node, including     coordinates for content, padding, border, and margin boxes.</p> <p> TYPE: <code>Command[GetBoxModelResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.get_document","title":"get_document  <code>staticmethod</code>","text":"<pre><code>get_document(depth=None, pierce=None)\n</code></pre> <p>Returns the root DOM node (and optionally the subtree) to the caller.</p> <p>This is typically the first command called when interacting with the DOM, as it provides access to the document's root node. From this root, you can traverse to any other element on the page. This command implicitly enables DOM domain events for the current target, making it a good starting point for DOM interaction.</p> PARAMETER DESCRIPTION <code>depth</code> <p>Maximum depth at which children should be retrieved (default is 1).   Use -1 for the entire subtree or provide an integer greater than 0.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>pierce</code> <p>Whether iframes and shadow roots should be traversed when returning   the subtree (default is false).</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the root DOM node.</p> <p> TYPE: <code>Command[GetDocumentResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.get_node_for_location","title":"get_node_for_location  <code>staticmethod</code>","text":"<pre><code>get_node_for_location(x, y, include_user_agent_shadow_dom=None, ignore_pointer_events_none=None)\n</code></pre> <p>Returns node id at given location on the page.</p> <p>This command is particularly useful for bridging the gap between visual/pixel-based information and the DOM structure. It allows you to convert screen coordinates to actual DOM elements, which is essential for creating inspection tools or for testing spatially-oriented interactions.</p> PARAMETER DESCRIPTION <code>x</code> <p>X coordinate relative to the main frame's viewport.</p> <p> TYPE: <code>int</code> </p> <code>y</code> <p>Y coordinate relative to the main frame's viewport.</p> <p> TYPE: <code>int</code> </p> <code>include_user_agent_shadow_dom</code> <p>Whether to include nodes in user agent shadow roots.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>ignore_pointer_events_none</code> <p>Whether to ignore pointer-events:none and test elements                        underneath them.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the node at the given location, including    frame information when available.</p> <p> TYPE: <code>Command[GetNodeForLocationResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.get_outer_html","title":"get_outer_html  <code>staticmethod</code>","text":"<pre><code>get_outer_html(node_id=None, backend_node_id=None, object_id=None)\n</code></pre> <p>Returns node's HTML markup, including the node itself and all its children.</p> <p>This command provides a way to access the complete HTML representation of an element, making it valuable for when you need to extract, analyze, or verify HTML content. It's more comprehensive than just getting text content as it preserves the full markup structure including tags, attributes, and child elements.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Identifier of the node.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>backend_node_id</code> <p>Identifier of the backend node.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>object_id</code> <p>JavaScript object id of the node wrapper.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the outer HTML markup of the node.</p> <p> TYPE: <code>Command[GetOuterHTMLResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.hide_highlight","title":"hide_highlight  <code>staticmethod</code>","text":"<pre><code>hide_highlight()\n</code></pre> <p>Hides any DOM element highlight.</p> <p>This command is particularly useful in automation workflows where multiple elements are highlighted in sequence, and you need to clear previous highlights before proceeding to the next element to avoid visual clutter or interference.</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to hide DOM element highlights.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.highlight_node","title":"highlight_node  <code>staticmethod</code>","text":"<pre><code>highlight_node()\n</code></pre> <p>Highlights DOM node.</p> <p>Highlighting nodes is especially valuable during development and debugging sessions to visually confirm which elements are being selected by selectors or coordinates.</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to highlight a DOM node.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.highlight_rect","title":"highlight_rect  <code>staticmethod</code>","text":"<pre><code>highlight_rect()\n</code></pre> <p>Highlights given rectangle.</p> <p>Unlike node highlighting, rectangle highlighting allows highlighting arbitrary regions of the page, which is useful for highlighting computed areas or regions that don't correspond directly to DOM elements.</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to highlight a rectangular area.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.move_to","title":"move_to  <code>staticmethod</code>","text":"<pre><code>move_to(node_id, target_node_id, insert_before_node_id=None)\n</code></pre> <p>Moves node into the new container, placing it before the given anchor.</p> <p>This command allows for more complex DOM restructuring than simple attribute or content changes. It's particularly useful when testing applications that involve rearranging elements, such as sortable lists, kanban boards, or drag-and-drop interfaces.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to move.</p> <p> TYPE: <code>int</code> </p> <code>target_node_id</code> <p>Id of the element to drop the moved node into.</p> <p> TYPE: <code>int</code> </p> <code>insert_before_node_id</code> <p>Drop node before this one (if absent, the moved node                  becomes the last child of target_node_id).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to move a node, returning the new id of the moved node.</p> <p> TYPE: <code>Command[MoveToResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.query_selector","title":"query_selector  <code>staticmethod</code>","text":"<pre><code>query_selector(node_id, selector)\n</code></pre> <p>Executes querySelector on a given node.</p> <p>This method is one of the most fundamental tools for element location, allowing the use of standard CSS selectors to find elements in the DOM. Unlike JavaScript's querySelector, this can be executed on any node (not just document), enabling scoped searches within specific sections of the page.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to query upon.</p> <p> TYPE: <code>int</code> </p> <code>selector</code> <p>CSS selector string.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the first element matching the selector.</p> <p> TYPE: <code>Command[QuerySelectorResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.query_selector_all","title":"query_selector_all  <code>staticmethod</code>","text":"<pre><code>query_selector_all(node_id, selector)\n</code></pre> <p>Executes querySelectorAll on a given node.</p> <p>This method extends querySelector by returning all matching elements rather than just the first one. This is essential for operations that need to process multiple elements, such as extracting data from tables, lists, or grids, or verifying that the correct number of elements are present.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to query upon.</p> <p> TYPE: <code>int</code> </p> <code>selector</code> <p>CSS selector string.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns all elements matching the selector.</p> <p> TYPE: <code>Command[QuerySelectorAllResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.remove_attribute","title":"remove_attribute  <code>staticmethod</code>","text":"<pre><code>remove_attribute(node_id, name)\n</code></pre> <p>Removes attribute with given name from an element with given id.</p> <p>This command allows direct manipulation of element attributes without using JavaScript in the page context. It's useful for testing how elements behave when specific attributes are removed or for preparing elements for specific test conditions.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the element to remove attribute from.</p> <p> TYPE: <code>int</code> </p> <code>name</code> <p>Name of the attribute to remove.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to remove the specified attribute.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.remove_node","title":"remove_node  <code>staticmethod</code>","text":"<pre><code>remove_node(node_id)\n</code></pre> <p>Removes node with given id.</p> <p>This command allows direct removal of DOM elements, which can be useful when testing how an application responds to missing elements or when simplifying a page for focused testing scenarios.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to remove.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to remove the specified node.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.request_child_nodes","title":"request_child_nodes  <code>staticmethod</code>","text":"<pre><code>request_child_nodes(node_id, depth=None, pierce=None)\n</code></pre> <p>Requests that children of the node with given id are returned to the caller.</p> <p>This method is particularly useful when dealing with large DOM trees, as it allows for more efficient exploration by loading children on demand rather than loading the entire tree at once. Child nodes are returned as setChildNodes events.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to get children for.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>The maximum depth at which children should be retrieved,   defaults to 1. Use -1 for the entire subtree.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>pierce</code> <p>Whether or not iframes and shadow roots should be traversed.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to request child nodes.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.request_node","title":"request_node  <code>staticmethod</code>","text":"<pre><code>request_node(object_id)\n</code></pre> <p>Requests that the node is sent to the caller given the JavaScript node object reference.</p> <p>This method bridges the gap between JavaScript objects in the page context and the CDP's node representation system, allowing automation to work with elements that might only be available as JavaScript references (e.g., from event handlers).</p> PARAMETER DESCRIPTION <code>object_id</code> <p>JavaScript object id to convert into a Node.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the Node id for the given object.</p> <p> TYPE: <code>Command[RequestNodeResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.resolve_node","title":"resolve_node  <code>staticmethod</code>","text":"<pre><code>resolve_node(node_id=None, backend_node_id=None, object_group=None, execution_context_id=None)\n</code></pre> <p>Resolves the JavaScript node object for a given NodeId or BackendNodeId.</p> <p>This method provides the opposite functionality of requestNode - instead of getting a CDP node from a JavaScript object, it gets a JavaScript object from a CDP node. This enables executing JavaScript operations on nodes identified through CDP.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to resolve.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>backend_node_id</code> <p>Backend id of the node to resolve.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>object_group</code> <p>Symbolic group name that can be used to release multiple objects.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>execution_context_id</code> <p>Execution context in which to resolve the node.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns a JavaScript object wrapper for the node.</p> <p> TYPE: <code>Command[ResolveNodeResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.scroll_into_view_if_needed","title":"scroll_into_view_if_needed  <code>staticmethod</code>","text":"<pre><code>scroll_into_view_if_needed(node_id=None, backend_node_id=None, object_id=None, rect=None)\n</code></pre> <p>Scrolls the specified node into view if not already visible.</p> <p>This command is crucial for reliable web automation, as it ensures elements are actually visible in the viewport before attempting interactions. Modern websites often use lazy loading and have long scrollable areas, making this command essential for working with elements that may not be initially visible.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Identifier of the node.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>backend_node_id</code> <p>Identifier of the backend node.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>object_id</code> <p>JavaScript object id of the node wrapper.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>rect</code> <p>Optional rect to scroll into view, relative to the node bounds.</p> <p> TYPE: <code>Optional[Rect]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to scroll the element into view.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.set_attributes_as_text","title":"set_attributes_as_text  <code>staticmethod</code>","text":"<pre><code>set_attributes_as_text(node_id, text, name=None)\n</code></pre> <p>Sets attribute for an element with given id, using text representation.</p> <p>This command allows for more complex attribute manipulation than set_attribute_value, as it accepts a text representation that can potentially define multiple attributes or include special formatting. It's particularly useful when trying to replicate exactly how attributes would be defined in HTML source code.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the element to set attribute for.</p> <p> TYPE: <code>int</code> </p> <code>text</code> <p>Text with a new attribute value.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Attribute name to replace with new text value.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to set an attribute as text.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.set_attribute_value","title":"set_attribute_value  <code>staticmethod</code>","text":"<pre><code>set_attribute_value(node_id, name, value)\n</code></pre> <p>Sets attribute for element with given id.</p> <p>This command provides direct control over element attributes without using JavaScript, which is essential for testing how applications respond to attribute changes or for setting up specific test conditions by controlling element attributes directly.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the element to set attribute for.</p> <p> TYPE: <code>int</code> </p> <code>name</code> <p>Attribute name.</p> <p> TYPE: <code>str</code> </p> <code>value</code> <p>Attribute value.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to set an attribute value.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.set_file_input_files","title":"set_file_input_files  <code>staticmethod</code>","text":"<pre><code>set_file_input_files(files, node_id=None, backend_node_id=None, object_id=None)\n</code></pre> <p>Sets files for the given file input element.</p> <p>This command solves one of the most challenging automation problems: working with file inputs. It bypasses the OS-level file dialog that normally appears when clicking a file input, allowing automated tests to provide files programmatically.</p> PARAMETER DESCRIPTION <code>files</code> <p>list of file paths to set.</p> <p> TYPE: <code>list[str]</code> </p> <code>node_id</code> <p>Identifier of the node.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>backend_node_id</code> <p>Identifier of the backend node.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>object_id</code> <p>JavaScript object id of the node wrapper.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to set files for a file input element.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.set_node_name","title":"set_node_name  <code>staticmethod</code>","text":"<pre><code>set_node_name(node_id, name)\n</code></pre> <p>Sets node name for a node with given id.</p> <p>This command allows changing the actual tag name of an element, which can be useful for testing how applications handle different types of elements or for testing the impact of semantic HTML choices on accessibility and behavior.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to set name for.</p> <p> TYPE: <code>int</code> </p> <code>name</code> <p>New node name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the new node id after the name change.</p> <p> TYPE: <code>Command[SetNodeNameResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.set_node_value","title":"set_node_value  <code>staticmethod</code>","text":"<pre><code>set_node_value(node_id, value)\n</code></pre> <p>Sets node value for a node with given id.</p> <p>This command is particularly useful for updating the content of text nodes and comments, allowing direct manipulation of text content without changing the surrounding HTML structure.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to set value for.</p> <p> TYPE: <code>int</code> </p> <code>value</code> <p>New node value.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to set a node's value.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.set_outer_html","title":"set_outer_html  <code>staticmethod</code>","text":"<pre><code>set_outer_html(node_id, outer_html)\n</code></pre> <p>Sets node HTML markup, replacing existing one.</p> <p>This is one of the most powerful DOM manipulation commands, as it allows completely replacing an element and all its children with new HTML. This is useful for making major structural changes to the page or for testing how applications handle dynamically inserted content.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to set outer HTML for.</p> <p> TYPE: <code>int</code> </p> <code>outer_html</code> <p>HTML markup to set.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to set the outer HTML of a node.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.collect_class_names_from_subtree","title":"collect_class_names_from_subtree  <code>staticmethod</code>","text":"<pre><code>collect_class_names_from_subtree(node_id)\n</code></pre> <p>Collects class names for the node with given id and all of its children.</p> <p>This method is valuable for understanding the styling landscape of a page, especially in complex applications where multiple CSS frameworks might be in use or where classes are dynamically applied.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to collect class names for.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns a list of all unique class names in the subtree.</p> <p> TYPE: <code>Command[CollectClassNamesFromSubtreeResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.copy_to","title":"copy_to  <code>staticmethod</code>","text":"<pre><code>copy_to(node_id, target_node_id, insert_before_node_id=None)\n</code></pre> <p>Creates a deep copy of the specified node and places it into the target container.</p> <p>Unlike move_to, this command creates a copy of the node, leaving the original intact. This is useful when you want to duplicate content rather than move it, such as when testing how multiple instances of the same component behave.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to copy.</p> <p> TYPE: <code>int</code> </p> <code>target_node_id</code> <p>Id of the element to drop the copy into.</p> <p> TYPE: <code>int</code> </p> <code>insert_before_node_id</code> <p>Drop the copy before this node (if absent, the copy becomes                  the last child of target_node_id).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the id of the new copy.</p> <p> TYPE: <code>Command[CopyToResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.discard_search_results","title":"discard_search_results  <code>staticmethod</code>","text":"<pre><code>discard_search_results(search_id)\n</code></pre> <p>Discards search results from the session with the given id.</p> <p>This method helps manage resources when performing multiple searches during a session, allowing explicit cleanup of search results that are no longer needed.</p> PARAMETER DESCRIPTION <code>search_id</code> <p>Unique search session identifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to discard search results.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.get_anchor_element","title":"get_anchor_element  <code>staticmethod</code>","text":"<pre><code>get_anchor_element(node_id, anchor_specifier=None)\n</code></pre> <p>Finds the closest ancestor node that is an anchor element for the given node.</p> <p>This method is useful when working with content inside links or when you need to find the enclosing link element for text or other elements. This helps in cases where you might locate text but need to find the actual link around it.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to search for an anchor around.</p> <p> TYPE: <code>int</code> </p> <code>anchor_specifier</code> <p>Optional specifier for anchor tag properties.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the anchor element node information.</p> <p> TYPE: <code>Command[GetAnchorElementResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.get_container_for_node","title":"get_container_for_node  <code>staticmethod</code>","text":"<pre><code>get_container_for_node(node_id, container_name=None, physical_axes=None, logical_axes=None, queries_scroll_state=None)\n</code></pre> <p>Finds a containing element for the given node based on specified parameters.</p> <p>This method helps in understanding the structural and layout context of elements, particularly in complex layouts using CSS features like flexbox, grid, or when dealing with scrollable containers.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to find the container for.</p> <p> TYPE: <code>int</code> </p> <code>container_name</code> <p>Name of the container to look for (e.g., 'scrollable', 'flex').</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>physical_axes</code> <p>Physical axes to consider (Horizontal, Vertical, Both).</p> <p> TYPE: <code>Optional[PhysicalAxes]</code> DEFAULT: <code>None</code> </p> <code>logical_axes</code> <p>Logical axes to consider (Inline, Block, Both).</p> <p> TYPE: <code>Optional[LogicalAxes]</code> DEFAULT: <code>None</code> </p> <code>queries_scroll_state</code> <p>Whether to query scroll state or not.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns information about the containing element.</p> <p> TYPE: <code>Command[GetContainerForNodeResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.get_content_quads","title":"get_content_quads  <code>staticmethod</code>","text":"<pre><code>get_content_quads(node_id=None, backend_node_id=None, object_id=None)\n</code></pre> <p>Returns quads that describe node position on the page.</p> <p>This method provides detailed geometric information about an element's position on the page, accounting for any transformations, rotations, or other CSS effects. This is more precise than getBoxModel for complex layouts.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Identifier of the node.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>backend_node_id</code> <p>Identifier of the backend node.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>object_id</code> <p>JavaScript object id of the node wrapper.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the quads describing the node position.</p> <p> TYPE: <code>Command[GetContentQuadsResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.get_detached_dom_nodes","title":"get_detached_dom_nodes  <code>staticmethod</code>","text":"<pre><code>get_detached_dom_nodes()\n</code></pre> <p>Returns information about detached DOM tree elements.</p> <p>This method is primarily useful for debugging memory issues related to the DOM, as detached DOM nodes (nodes no longer in the document but still referenced in JavaScript) are a common cause of memory leaks in web applications.</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns information about detached DOM nodes.</p> <p> TYPE: <code>Command[GetDetachedDomNodesResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.get_element_by_relation","title":"get_element_by_relation  <code>staticmethod</code>","text":"<pre><code>get_element_by_relation(node_id, relation)\n</code></pre> <p>Retrieves an element related to the given one in a specified way.</p> <p>This method provides a way to find elements based on their relationships to other elements, such as finding the next focusable element after a given one. This is useful for simulating keyboard navigation or for analyzing element relationships.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the reference node.</p> <p> TYPE: <code>int</code> </p> <code>relation</code> <p>Type of relationship (e.g., nextSibling, previousSibling, firstChild).</p> <p> TYPE: <code>ElementRelation</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the related element node.</p> <p> TYPE: <code>Command[GetElementByRelationResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.get_file_info","title":"get_file_info  <code>staticmethod</code>","text":"<pre><code>get_file_info(object_id)\n</code></pre> <p>Returns file information for the given File object.</p> <p>This method is useful when working with file inputs and the File API, providing access to file metadata like name, size, and MIME type for files selected in file input elements or created programmatically.</p> PARAMETER DESCRIPTION <code>object_id</code> <p>JavaScript object id of the File object to get info for.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns file information.</p> <p> TYPE: <code>Command[GetFileInfoResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.get_frame_owner","title":"get_frame_owner  <code>staticmethod</code>","text":"<pre><code>get_frame_owner(frame_id)\n</code></pre> <p>Returns iframe element that owns the given frame.</p> <p>This method is essential when working with pages that contain iframes, as it allows mapping between frame IDs (used in CDP) and the actual iframe elements in the parent document.</p> PARAMETER DESCRIPTION <code>frame_id</code> <p>Id of the frame to get the owner element for.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the frame owner element.</p> <p> TYPE: <code>Command[GetFrameOwnerResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.get_nodes_for_subtree_by_style","title":"get_nodes_for_subtree_by_style  <code>staticmethod</code>","text":"<pre><code>get_nodes_for_subtree_by_style(node_id, computed_styles, pierce=None)\n</code></pre> <p>Finds nodes with a given computed style in a subtree.</p> <p>This method allows finding elements based on their computed styles rather than just structure or attributes. This is powerful for testing visual aspects of a page or for finding elements that match specific visual criteria.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Node to start the search from.</p> <p> TYPE: <code>int</code> </p> <code>computed_styles</code> <p>list of computed style properties to match against.</p> <p> TYPE: <code>list[CSSComputedStyleProperty]</code> </p> <code>pierce</code> <p>Whether or not iframes and shadow roots should be traversed.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns nodes matching the specified styles.</p> <p> TYPE: <code>Command[GetNodesForSubtreeByStyleResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.get_node_stack_traces","title":"get_node_stack_traces  <code>staticmethod</code>","text":"<pre><code>get_node_stack_traces(node_id)\n</code></pre> <p>Gets stack traces associated with a specific node.</p> <p>This method is powerful for debugging, as it reveals the JavaScript execution paths that led to the creation of specific DOM elements, helping developers understand the relationship between their code and the resulting DOM structure.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to get stack traces for.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns stack traces related to the node.</p> <p> TYPE: <code>Command[GetNodeStackTracesResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.get_querying_descendants_for_container","title":"get_querying_descendants_for_container  <code>staticmethod</code>","text":"<pre><code>get_querying_descendants_for_container(node_id)\n</code></pre> <p>Returns the querying descendants for container.</p> <p>This method is particularly useful for working with CSS Container Queries, helping to identify which descendant elements are affected by or querying a particular container element.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the container node to find querying descendants for.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns querying descendant information.</p> <p> TYPE: <code>Command[GetQueryingDescendantForContainerResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.get_relayout_boundary","title":"get_relayout_boundary  <code>staticmethod</code>","text":"<pre><code>get_relayout_boundary(node_id)\n</code></pre> <p>Returns the root of the relayout boundary for the given node.</p> <p>This method helps in understanding layout performance by identifying the boundary of layout recalculations when a particular element changes. This is valuable for optimizing rendering performance.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Id of the node to find relayout boundary for.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the relayout boundary node.</p> <p> TYPE: <code>Command[GetRelayoutBoundaryResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.get_search_results","title":"get_search_results  <code>staticmethod</code>","text":"<pre><code>get_search_results(search_id, from_index, to_index)\n</code></pre> <p>Returns search results from given <code>fromIndex</code> to given <code>toIndex</code> from a search.</p> <p>This method is used in conjunction with performSearch to retrieve search results in batches, which is essential when dealing with large result sets that might be inefficient to transfer all at once.</p> PARAMETER DESCRIPTION <code>search_id</code> <p>Unique search session identifier from performSearch.</p> <p> TYPE: <code>str</code> </p> <code>from_index</code> <p>Start index to retrieve results from.</p> <p> TYPE: <code>int</code> </p> <code>to_index</code> <p>End index to retrieve results to (exclusive).</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the requested search results.</p> <p> TYPE: <code>Command[GetSearchResultsResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.get_top_layer_elements","title":"get_top_layer_elements  <code>staticmethod</code>","text":"<pre><code>get_top_layer_elements()\n</code></pre> <p>Returns all top layer elements in the document.</p> <p>This method is valuable for working with modern web UIs that make extensive use of overlays, modals, dropdowns, and other elements that need to appear above the normal document flow.</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the top layer element information.</p> <p> TYPE: <code>Command[GetTopLayerElementsResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.mark_undoable_state","title":"mark_undoable_state  <code>staticmethod</code>","text":"<pre><code>mark_undoable_state()\n</code></pre> <p>Marks last undoable state.</p> <p>This method helps in managing DOM manipulation state, allowing the creation of savepoints that can be reverted to with the undo command. This is useful for complex sequences of DOM operations that should be treated as a unit.</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to mark the current state as undoable.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.perform_search","title":"perform_search  <code>staticmethod</code>","text":"<pre><code>perform_search(query, include_user_agent_shadow_dom=None)\n</code></pre> <p>Searches for a given string in the DOM tree.</p> <p>This method initiates a search across the DOM tree, supporting plain text, CSS selectors, or XPath expressions. It's a powerful way to find elements or content across the entire document without knowing the exact structure.</p> PARAMETER DESCRIPTION <code>query</code> <p>Plain text or query selector or XPath search query.</p> <p> TYPE: <code>str</code> </p> <code>include_user_agent_shadow_dom</code> <p>True to include user agent shadow DOM in the search.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns search results identifier and count.</p> <p> TYPE: <code>Command[PerformSearchResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.push_node_by_path_to_frontend","title":"push_node_by_path_to_frontend  <code>staticmethod</code>","text":"<pre><code>push_node_by_path_to_frontend(path)\n</code></pre> <p>Requests that the node is sent to the caller given its path.</p> <p>This method provides an alternative way to reference nodes when node IDs aren't available, using path expressions instead. This can be useful when integrating with systems that identify elements by path rather than by ID.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to node in the proprietary format.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns the node id for the node.</p> <p> TYPE: <code>Command[PushNodeByPathToFrontendResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.push_nodes_by_backend_ids_to_frontend","title":"push_nodes_by_backend_ids_to_frontend  <code>staticmethod</code>","text":"<pre><code>push_nodes_by_backend_ids_to_frontend(backend_node_ids)\n</code></pre> <p>Requests that a batch of nodes is sent to the caller given their backend node ids.</p> <p>This method allows for efficient batch processing when you have multiple backend node IDs and need to convert them to frontend node IDs for further operations.</p> PARAMETER DESCRIPTION <code>backend_node_ids</code> <p>The array of backend node ids.</p> <p> TYPE: <code>list[int]</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns an array of node ids.</p> <p> TYPE: <code>Command[PushNodesByBackendIdsToFrontendResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.redo","title":"redo  <code>staticmethod</code>","text":"<pre><code>redo()\n</code></pre> <p>Re-does the last undone action.</p> <p>This method works in conjunction with undo and markUndoableState to provide a transactional approach to DOM manipulations, allowing for stepping back and forth through a sequence of changes.</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to redo the last undone action.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.set_inspected_node","title":"set_inspected_node  <code>staticmethod</code>","text":"<pre><code>set_inspected_node(node_id)\n</code></pre> <p>Enables console to refer to the node with given id via $x command line API.</p> <p>This method creates a bridge between automated testing/scripting and manual console interaction, making it easy to reference specific nodes in the console for debugging or experimentation.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>DOM node id to be accessible by means of $x command line API.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to set the inspected node.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.set_node_stack_traces_enabled","title":"set_node_stack_traces_enabled  <code>staticmethod</code>","text":"<pre><code>set_node_stack_traces_enabled(enable)\n</code></pre> <p>Sets if stack traces should be captured for Nodes.</p> <p>This method enables or disables the collection of stack traces when DOM nodes are created, which can be extremely valuable for debugging complex applications to understand where and why specific DOM elements are being created.</p> PARAMETER DESCRIPTION <code>enable</code> <p>Enable or disable stack trace collection.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to enable or disable node stack traces.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.dom_commands.DomCommands.undo","title":"undo  <code>staticmethod</code>","text":"<pre><code>undo()\n</code></pre> <p>Undoes the last performed action.</p> <p>This method works in conjunction with redo and markUndoableState to provide transactional control over DOM manipulations, allowing for reverting changes when needed.</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to undo the last performed action.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#network-commands","title":"Network Commands","text":""},{"location":"api/protocol/commands/#pydoll.commands.network_commands","title":"pydoll.commands.network_commands","text":""},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands","title":"NetworkCommands","text":"<p>Implementation of Chrome DevTools Protocol for the Network domain.</p> <p>This class provides commands for monitoring and manipulating network activities, enabling detailed inspection and control over HTTP requests and responses. The Network domain exposes comprehensive network-related information including: - Request/response headers and bodies - Resource timing and caching behavior - Cookie management and security details - Network conditions emulation - Traffic interception and modification</p> <p>The commands allow developers to analyze performance, debug network issues, and test application behavior under various network conditions.</p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.clear_browser_cache","title":"clear_browser_cache  <code>staticmethod</code>","text":"<pre><code>clear_browser_cache()\n</code></pre> <p>Clears browser cache storage.</p> <p>This command is essential for testing cache behavior and ensuring fresh resource loading. It affects all cached resources including: - CSS/JavaScript files - Images and media assets - API response caching</p> <p>Use cases: - Testing cache invalidation strategies - Reproducing issues with stale content - Performance benchmarking without cache influence</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to clear the entire browser cache</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.clear_browser_cookies","title":"clear_browser_cookies  <code>staticmethod</code>","text":"<pre><code>clear_browser_cookies()\n</code></pre> <p>Command to clear all cookies stored in the browser.</p> <p>This can be beneficial for testing scenarios where you need to simulate a fresh user session without any previously stored cookies that might affect the application's behavior.</p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: A command to clear all cookies in the browser.</p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.delete_cookies","title":"delete_cookies  <code>staticmethod</code>","text":"<pre><code>delete_cookies(name, url=None, domain=None, path=None, partition_key=None)\n</code></pre> <p>Deletes browser cookies with matching criteria.</p> <p>Provides granular control over cookie removal through multiple parameters: - Delete by name only (affects all matching cookies) - Scope deletion using URL, domain, or path - Handle partitioned cookies for privacy-aware applications</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the cookies to remove (required)</p> <p> TYPE: <code>str</code> </p> <code>url</code> <p>Delete cookies for specific URL (domain/path must match)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>domain</code> <p>Exact domain for cookie deletion</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>path</code> <p>Exact path for cookie deletion</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>partition_key</code> <p>Partition key attributes for cookie isolation</p> <p> TYPE: <code>Optional[CookiePartitionKey]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to execute selective cookie deletion</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.disable","title":"disable  <code>staticmethod</code>","text":"<pre><code>disable()\n</code></pre> <p>Stops network monitoring and event reporting.</p> <p>Preserves network state but stops: - Request/response events - WebSocket message tracking - Loading progress notifications</p> <p>Use when: - Reducing overhead during non-network operations - Pausing monitoring temporarily - Finalizing network-related tests</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to disable network monitoring</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.enable","title":"enable  <code>staticmethod</code>","text":"<pre><code>enable(max_total_buffer_size=None, max_resource_buffer_size=None, max_post_data_size=None)\n</code></pre> <p>Enables network monitoring with configurable buffers.</p> PARAMETER DESCRIPTION <code>max_total_buffer_size</code> <p>Total memory buffer for network data (bytes)</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>max_resource_buffer_size</code> <p>Per-resource buffer limit (bytes)</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>max_post_data_size</code> <p>Maximum POST payload to capture (bytes)</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <p>Recommended settings: - Increase buffers for long-running sessions - Adjust post size for API testing - Monitor memory usage with large buffers</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to enable network monitoring</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.get_cookies","title":"get_cookies  <code>staticmethod</code>","text":"<pre><code>get_cookies(urls=None)\n</code></pre> <p>Retrieves cookies matching specified URLs.</p> PARAMETER DESCRIPTION <code>urls</code> <p>list of URLs to scope cookie retrieval</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command returning cookie details including: - Name, value, and attributes - Security and scope parameters - Expiration and size information</p> <p> TYPE: <code>Command[GetCookiesResponse]</code> </p> <p>Usage notes: - Empty URL list returns all cookies - Includes HTTP-only and secure cookies - Shows partitioned cookie status</p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.get_request_post_data","title":"get_request_post_data  <code>staticmethod</code>","text":"<pre><code>get_request_post_data(request_id)\n</code></pre> <p>Retrieves POST data from a specific network request.</p> <p>Essential for: - Form submission analysis - API request debugging - File upload monitoring - Security testing</p> PARAMETER DESCRIPTION <code>request_id</code> <p>Unique identifier for the network request</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns: - Raw POST data content - Multipart form data (excluding file contents) - Content encoding information</p> <p> TYPE: <code>Command[GetRequestPostDataResponse]</code> </p> <p>Note: Large POST bodies may be truncated based on buffer settings</p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.get_response_body","title":"get_response_body  <code>staticmethod</code>","text":"<pre><code>get_response_body(request_id)\n</code></pre> <p>Retrieves the full content of a network response.</p> <p>Supports various content types: - Text-based resources (HTML, CSS, JSON) - Base64-encoded binary content (images, media) - Gzip/deflate compressed responses</p> PARAMETER DESCRIPTION <code>request_id</code> <p>Unique network request identifier</p> <p> TYPE: <code>str</code> </p> <p>Important considerations: - Response must be available in browser memory - Large responses may require streaming approaches - Sensitive data should be handled securely</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command returning response body and encoding details</p> <p> TYPE: <code>Command[GetResponseBodyResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.set_cache_disabled","title":"set_cache_disabled  <code>staticmethod</code>","text":"<pre><code>set_cache_disabled(cache_disabled)\n</code></pre> <p>Controls browser's cache mechanism.</p> <p>Use cases: - Testing resource update behavior - Forcing fresh content loading - Performance impact analysis - Cache-busting scenarios</p> PARAMETER DESCRIPTION <code>cache_disabled</code> <p>True to disable caching, False to enable</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to modify cache behavior</p> <p> TYPE: <code>Command[Response]</code> </p> <p>Note: Affects all requests until re-enabled</p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.set_cookie","title":"set_cookie  <code>staticmethod</code>","text":"<pre><code>set_cookie(name, value, url=None, domain=None, path=None, secure=None, http_only=None, same_site=None, expires=None, priority=None, same_party=None, source_scheme=None, source_port=None, partition_key=None)\n</code></pre> <p>Creates or updates a cookie with specified attributes.</p> <p>Comprehensive cookie control supporting: - Session and persistent cookies - Security attributes (Secure, HttpOnly) - SameSite policies - Cookie partitioning - Priority levels</p> PARAMETER DESCRIPTION <code>name</code> <p>Cookie name</p> <p> TYPE: <code>str</code> </p> <code>value</code> <p>Cookie value</p> <p> TYPE: <code>str</code> </p> <code>url</code> <p>Target URL for the cookie</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>domain</code> <p>Cookie domain scope</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>path</code> <p>Cookie path scope</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>secure</code> <p>Require HTTPS</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>http_only</code> <p>Prevent JavaScript access</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>same_site</code> <p>Cross-site access policy</p> <p> TYPE: <code>Optional[CookieSameSite]</code> DEFAULT: <code>None</code> </p> <code>expires</code> <p>Expiration timestamp</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>priority</code> <p>Cookie priority level</p> <p> TYPE: <code>Optional[CookiePriority]</code> DEFAULT: <code>None</code> </p> <code>same_party</code> <p>First-Party Sets flag</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>source_scheme</code> <p>Cookie source context</p> <p> TYPE: <code>Optional[CookieSourceScheme]</code> DEFAULT: <code>None</code> </p> <code>source_port</code> <p>Source port restriction</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>partition_key</code> <p>Storage partition key</p> <p> TYPE: <code>Optional[CookiePartitionKey]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command that returns success status</p> <p> TYPE: <code>Command[SetCookieResponse]</code> </p> <p>Security considerations: - Use secure flag for sensitive data - Consider SameSite policies - Be aware of cross-site implications</p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.set_cookies","title":"set_cookies  <code>staticmethod</code>","text":"<pre><code>set_cookies(cookies)\n</code></pre> <p>Sets multiple cookies in a single operation.</p> <p>Efficient for: - Batch cookie operations - Session state restoration - Testing multiple authentication states - Cross-domain cookie setup</p> PARAMETER DESCRIPTION <code>cookies</code> <p>list of cookie parameters including     name, value, and attributes</p> <p> TYPE: <code>list[SetCookieParams]</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command for bulk cookie setting</p> <p> TYPE: <code>Command[Response]</code> </p> <p>Performance note: - More efficient than multiple set_cookie calls - Consider memory impact with large batches</p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.set_extra_http_headers","title":"set_extra_http_headers  <code>staticmethod</code>","text":"<pre><code>set_extra_http_headers(headers)\n</code></pre> <p>Applies custom HTTP headers to all subsequent requests.</p> <p>Enables advanced scenarios: - A/B testing with custom headers - Authentication bypass for testing - Content negotiation simulations - Security header validation</p> PARAMETER DESCRIPTION <code>headers</code> <p>list of key-value header pairs</p> <p> TYPE: <code>list[HeaderEntry]</code> </p> <p>Security notes: - Headers are applied browser-wide - Sensitive headers (e.g., Authorization) persist until cleared - Use with caution in shared environments</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to set global HTTP headers</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.set_useragent_override","title":"set_useragent_override  <code>staticmethod</code>","text":"<pre><code>set_useragent_override(user_agent, accept_language=None, platform=None, user_agent_metadata=None)\n</code></pre> <p>Overrides the browser's User-Agent string.</p> <p>Use cases: - Device/browser simulation - Compatibility testing - Content negotiation - Bot detection bypass</p> PARAMETER DESCRIPTION <code>user_agent</code> <p>Complete User-Agent string</p> <p> TYPE: <code>str</code> </p> <code>accept_language</code> <p>Language preference header</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>platform</code> <p>Platform identifier</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>user_agent_metadata</code> <p>Detailed UA metadata</p> <p> TYPE: <code>Optional[UserAgentMetadata]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to override user agent</p> <p> TYPE: <code>Command[Response]</code> </p> <p>Testing considerations: - Affects all subsequent requests - May impact server-side behavior - Consider mobile/desktop differences</p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.clear_accepted_encodings_override","title":"clear_accepted_encodings_override  <code>staticmethod</code>","text":"<pre><code>clear_accepted_encodings_override()\n</code></pre> <p>Restores default content encoding acceptance.</p> <p>Effects: - Resets compression preferences - Restores default Accept-Encoding header - Allows server-chosen encoding</p> <p>Use when: - Testing encoding fallbacks - Debugging compression issues - Resetting after encoding tests</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to clear encoding overrides</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.enable_reporting_api","title":"enable_reporting_api  <code>staticmethod</code>","text":"<pre><code>enable_reporting_api(enabled)\n</code></pre> <p>Controls the Reporting API functionality.</p> <p>Features: - Network error reporting - Deprecation notices - CSP violation reports - CORS issues</p> PARAMETER DESCRIPTION <code>enabled</code> <p>True to enable, False to disable</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to configure Reporting API</p> <p> TYPE: <code>Command[Response]</code> </p> <p>Note: Requires browser support for Reporting API</p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.search_in_response_body","title":"search_in_response_body  <code>staticmethod</code>","text":"<pre><code>search_in_response_body(request_id, query, case_sensitive=False, is_regex=False)\n</code></pre> <p>Searches for content within response bodies.</p> <p>Powerful for: - Content verification - Security scanning - Data extraction - Response validation</p> PARAMETER DESCRIPTION <code>request_id</code> <p>Target response identifier</p> <p> TYPE: <code>str</code> </p> <code>query</code> <p>Search string or pattern</p> <p> TYPE: <code>str</code> </p> <code>case_sensitive</code> <p>Match case sensitivity</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>is_regex</code> <p>Use regular expression matching</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command returning match results</p> <p> TYPE: <code>Command[SearchInResponseBodyResponse]</code> </p> <p>Performance tip: - Use specific queries for large responses - Consider regex complexity</p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.set_blocked_urls","title":"set_blocked_urls  <code>staticmethod</code>","text":"<pre><code>set_blocked_urls(urls)\n</code></pre> <p>Blocks specified URLs from loading.</p> <p>Key features: - Pattern-based URL blocking - Resource type filtering - Network request prevention - Error simulation</p> PARAMETER DESCRIPTION <code>urls</code> <p>list of URL patterns to block  Supports wildcards and pattern matching</p> <p> TYPE: <code>list[str]</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to set URL blocking rules</p> <p> TYPE: <code>Command[Response]</code> </p> <p>Common applications: - Ad/tracker blocking simulation - Resource loading control - Error handling testing - Network isolation testing</p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.set_bypass_service_worker","title":"set_bypass_service_worker  <code>staticmethod</code>","text":"<pre><code>set_bypass_service_worker(bypass)\n</code></pre> <p>Controls Service Worker interception of network requests.</p> <p>Use cases: - Testing direct network behavior - Bypassing offline functionality - Debug caching issues - Performance comparison</p> PARAMETER DESCRIPTION <code>bypass</code> <p>True to skip Service Worker, False to allow</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to configure Service Worker behavior</p> <p> TYPE: <code>Command[Response]</code> </p> <p>Impact: - Affects offline capabilities - Changes caching behavior - Modifies push notifications</p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.get_certificate","title":"get_certificate  <code>staticmethod</code>","text":"<pre><code>get_certificate(origin)\n</code></pre> <p>Retrieves SSL/TLS certificate information for a domain.</p> <p>Provides: - Certificate chain details - Validation status - Expiration information - Issuer details</p> PARAMETER DESCRIPTION <code>origin</code> <p>Target domain for certificate inspection</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command returning certificate data</p> <p> TYPE: <code>Command[GetCertificateResponse]</code> </p> <p>Security applications: - Certificate validation - SSL/TLS verification - Security assessment - Chain of trust verification</p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.get_response_body_for_interception","title":"get_response_body_for_interception  <code>staticmethod</code>","text":"<pre><code>get_response_body_for_interception(interception_id)\n</code></pre> <p>Retrieves response body from an intercepted request.</p> <p>Essential for: - Response modification - Content inspection - Security testing - API response validation</p> PARAMETER DESCRIPTION <code>interception_id</code> <p>Identifier for intercepted request</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command providing intercepted response content</p> <p> TYPE: <code>Command[GetResponseBodyForInterceptionResponse]</code> </p> <p>Note: - Must be used with interception enabled - Supports streaming responses - Handles various content types</p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.set_accepted_encodings","title":"set_accepted_encodings  <code>staticmethod</code>","text":"<pre><code>set_accepted_encodings(encodings)\n</code></pre> <p>Specifies accepted content encodings for requests.</p> <p>Controls: - Compression algorithms - Transfer encoding - Content optimization</p> PARAMETER DESCRIPTION <code>encodings</code> <p>list of accepted encoding methods      (gzip, deflate, br, etc.)</p> <p> TYPE: <code>list[ContentEncoding]</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to set encoding preferences</p> <p> TYPE: <code>Command[Response]</code> </p> <p>Performance implications: - Affects bandwidth usage - Impacts response time - Changes server behavior</p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.set_attach_debug_stack","title":"set_attach_debug_stack  <code>staticmethod</code>","text":"<pre><code>set_attach_debug_stack(enabled)\n</code></pre> <p>Enables/disables debug stack attachment to requests.</p> <p>Debug features: - Stack trace collection - Request origin tracking - Initialization context - Call site identification</p> PARAMETER DESCRIPTION <code>enabled</code> <p>True to attach debug info, False to disable</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to configure debug stack attachment</p> <p> TYPE: <code>Command[Response]</code> </p> <p>Performance note: - May impact performance when enabled - Useful for development/debugging - Consider memory usage</p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.set_cookie_controls","title":"set_cookie_controls  <code>staticmethod</code>","text":"<pre><code>set_cookie_controls(enable_third_party_cookie_restriction, disable_third_party_cookie_metadata=None, disable_third_party_cookie_heuristics=None)\n</code></pre> <p>Configures third-party cookie handling policies.</p> <p>Privacy features: - Cookie access control - Third-party restrictions - Tracking prevention - Privacy policy enforcement</p> PARAMETER DESCRIPTION <code>enable_third_party_cookie_restriction</code> <p>Enable restrictions</p> <p> TYPE: <code>bool</code> </p> <code>disable_third_party_cookie_metadata</code> <p>Skip metadata checks</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>disable_third_party_cookie_heuristics</code> <p>Disable detection logic</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to set cookie control policies</p> <p> TYPE: <code>Command[Response]</code> </p> <p>Security implications: - Affects cross-site tracking - Changes authentication behavior - Impacts embedded content</p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.stream_resource_content","title":"stream_resource_content  <code>staticmethod</code>","text":"<pre><code>stream_resource_content(request_id)\n</code></pre> <p>Enables streaming of response content.</p> <p>Useful for: - Large file downloads - Progressive loading - Memory optimization - Real-time processing</p> PARAMETER DESCRIPTION <code>request_id</code> <p>Target request identifier</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to initiate content streaming</p> <p> TYPE: <code>Command[StreamResourceContentResponse]</code> </p> <p>Best practices: - Monitor memory usage - Handle stream chunks efficiently - Consider error recovery</p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.take_response_body_for_interception_as_stream","title":"take_response_body_for_interception_as_stream  <code>staticmethod</code>","text":"<pre><code>take_response_body_for_interception_as_stream(interception_id)\n</code></pre> <p>Creates a stream for intercepted response body.</p> <p>Applications: - Large response handling - Content modification - Bandwidth optimization - Progressive processing</p> PARAMETER DESCRIPTION <code>interception_id</code> <p>Intercepted response identifier</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command returning stream handle</p> <p> TYPE: <code>Command[TakeResponseBodyForInterceptionAsStreamResponse]</code> </p> <p>Stream handling: - Supports chunked transfer - Manages memory efficiently - Enables real-time processing</p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.emulate_network_conditions","title":"emulate_network_conditions  <code>staticmethod</code>","text":"<pre><code>emulate_network_conditions(offline, latency, download_throughput, upload_throughput, connection_type=None, packet_loss=None, packet_queue_length=None, packet_reordering=None)\n</code></pre> <p>Emulates custom network conditions for realistic testing scenarios.</p> <p>Simulates various network profiles including: - Offline mode - High-latency connections - Bandwidth throttling - Unreliable network characteristics</p> PARAMETER DESCRIPTION <code>offline</code> <p>Simulate complete network disconnection</p> <p> TYPE: <code>bool</code> </p> <code>latency</code> <p>Minimum latency in milliseconds (round-trip time)</p> <p> TYPE: <code>float</code> </p> <code>download_throughput</code> <p>Max download speed (bytes/sec, -1 to disable)</p> <p> TYPE: <code>float</code> </p> <code>upload_throughput</code> <p>Max upload speed (bytes/sec, -1 to disable)</p> <p> TYPE: <code>float</code> </p> <code>connection_type</code> <p>Network connection type (cellular, wifi, etc.)</p> <p> TYPE: <code>Optional[ConnectionType]</code> DEFAULT: <code>None</code> </p> <code>packet_loss</code> <p>Simulated packet loss percentage (0-100)</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>packet_queue_length</code> <p>Network buffer size simulation</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>packet_reordering</code> <p>Enable packet order randomization</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <p>Typical use cases: - Testing progressive loading states - Validating offline-first functionality - Performance optimization under constrained networks</p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to activate network emulation</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.get_security_isolation_status","title":"get_security_isolation_status  <code>staticmethod</code>","text":"<pre><code>get_security_isolation_status(frame_id=None)\n</code></pre> <p>Retrieves security isolation information.</p> <p>Provides: - CORS status - Cross-origin isolation - Security context - Frame isolation</p> PARAMETER DESCRIPTION <code>frame_id</code> <p>Optional frame to check</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command returning isolation status</p> <p> TYPE: <code>Command[GetSecurityIsolationStatusResponse]</code> </p> <p>Security aspects: - Cross-origin policies - Iframe security - Site isolation - Content protection</p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.load_network_resource","title":"load_network_resource  <code>staticmethod</code>","text":"<pre><code>load_network_resource(url, options, frame_id=None)\n</code></pre> <p>Loads a network resource with specific options.</p> <p>Features: - Custom request configuration - Resource loading control - Frame-specific loading - Error handling</p> PARAMETER DESCRIPTION <code>url</code> <p>Resource URL to load</p> <p> TYPE: <code>str</code> </p> <code>options</code> <p>Loading configuration</p> <p> TYPE: <code>LoadNetworkResourceOptions</code> </p> <code>frame_id</code> <p>Target frame context</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to load resource</p> <p> TYPE: <code>Command[LoadNetworkResourceResponse]</code> </p> <p>Usage considerations: - Respects CORS policies - Handles authentication - Manages redirects - Supports streaming</p>"},{"location":"api/protocol/commands/#pydoll.commands.network_commands.NetworkCommands.replay_xhr","title":"replay_xhr  <code>staticmethod</code>","text":"<pre><code>replay_xhr(request_id)\n</code></pre> <p>Replays an XHR request.</p> <p>Applications: - Request debugging - Response testing - Race condition analysis - API verification</p> PARAMETER DESCRIPTION <code>request_id</code> <p>XHR request to replay</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>CDP command to replay XHR</p> <p> TYPE: <code>Command[Response]</code> </p> <p>Note: - Maintains original headers - Preserves request body - Updates timestamps - Creates new request ID</p>"},{"location":"api/protocol/commands/#input-commands","title":"Input Commands","text":""},{"location":"api/protocol/commands/#pydoll.commands.input_commands","title":"pydoll.commands.input_commands","text":""},{"location":"api/protocol/commands/#pydoll.commands.input_commands.InputCommands","title":"InputCommands","text":"<p>A class for simulating user input events using Chrome DevTools Protocol.</p> <p>The Input domain provides methods for simulating user input, including: - Keyboard events (key presses, releases) - Mouse events (clicks, movements, wheel) - Touch events (taps, multi-touch gestures) - Drag and drop events - Synthetic gestures (pinch, scroll, tap)</p> <p>These methods allow for programmatic control of input events without requiring actual user interaction, making it useful for testing and automation.</p>"},{"location":"api/protocol/commands/#pydoll.commands.input_commands.InputCommands.cancel_dragging","title":"cancel_dragging  <code>staticmethod</code>","text":"<pre><code>cancel_dragging()\n</code></pre> <p>Generates a command to cancel any active dragging in the page.</p> <p>This is useful when you need to interrupt an ongoing drag operation that might have been started with dispatchDragEvent or by other means.</p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to cancel dragging.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.input_commands.InputCommands.dispatch_key_event","title":"dispatch_key_event  <code>staticmethod</code>","text":"<pre><code>dispatch_key_event(type, modifiers=None, timestamp=None, text=None, unmodified_text=None, key_identifier=None, code=None, key=None, windows_virtual_key_code=None, native_virtual_key_code=None, auto_repeat=None, is_keypad=None, is_system_key=None, location=None, commands=None)\n</code></pre> <p>Generates a command to dispatch a key event to the page.</p> <p>This method can simulate various types of keyboard events such as key presses, key releases, and character inputs.</p> PARAMETER DESCRIPTION <code>type</code> <p>Type of the key event. Allowed values: keyDown, keyUp, rawKeyDown, char.  - keyDown: Corresponds to a user pressing a key  - keyUp: Corresponds to a user releasing a key  - rawKeyDown: A physical key press, without the text processing  - char: Generates a character without explicit key events</p> <p> TYPE: <code>KeyEventType</code> </p> <code>modifiers</code> <p>Bit field representing pressed modifier keys. Values:       Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).       For example, to simulate Ctrl+Shift, use 10.</p> <p> TYPE: <code>Optional[KeyModifier]</code> DEFAULT: <code>None</code> </p> <code>timestamp</code> <p>Time at which the event occurred, in seconds since epoch.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>text</code> <p>Text as generated by processing a virtual key code with a keyboard layout.  Not needed for 'keyUp' and 'rawKeyDown' events (default: \"\").</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>unmodified_text</code> <p>Text that would have been generated by the keyboard without modifiers            (except for shift). Useful for shortcut key handling (default: \"\").</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>key_identifier</code> <p>Unique key identifier (e.g., 'U+0041') (default: \"\").</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>code</code> <p>Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: \"\").</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>key</code> <p>Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc. (e.g., 'AltGr') (default: \"\").</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>windows_virtual_key_code</code> <p>Windows virtual key code (default: 0).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>native_virtual_key_code</code> <p>Native virtual key code (default: 0).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>auto_repeat</code> <p>Whether the event was generated from auto repeat (default: false).</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>is_keypad</code> <p>Whether the event was generated from the keypad (default: false).</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>is_system_key</code> <p>Whether the event was a system key event (default: false).</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>location</code> <p>Whether the event was from the left or right side of the keyboard:      0=Default, 1=Left, 2=Right (default: 0).</p> <p> TYPE: <code>Optional[KeyLocation]</code> DEFAULT: <code>None</code> </p> <code>commands</code> <p>Editing commands to send with the key event (e.g., 'selectAll')      (default: []). These are related to but not equal to the command names      used in <code>document.execCommand</code> and NSStandardKeyBindingResponding.</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to dispatch the key event.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.input_commands.InputCommands.dispatch_mouse_event","title":"dispatch_mouse_event  <code>staticmethod</code>","text":"<pre><code>dispatch_mouse_event(type, x, y, modifiers=None, timestamp=None, button=None, click_count=None, force=None, tangential_pressure=None, tilt_x=None, tilt_y=None, twist=None, delta_x=None, delta_y=None, pointer_type=None)\n</code></pre> <p>Generates a command to dispatch a mouse event to the page.</p> <p>This method allows simulating various mouse interactions such as clicks, movements, and wheel scrolling.</p> PARAMETER DESCRIPTION <code>type</code> <p>Type of the mouse event. Allowed values:  - mousePressed: Mouse button pressed  - mouseReleased: Mouse button released  - mouseMoved: Mouse moved  - mouseWheel: Mouse wheel rotated</p> <p> TYPE: <code>MouseEventType</code> </p> <code>x</code> <p>X coordinate of the event relative to the main frame's viewport in CSS pixels.</p> <p> TYPE: <code>int</code> </p> <code>y</code> <p>Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport, and Y increases going down.</p> <p> TYPE: <code>int</code> </p> <code>modifiers</code> <p>Bit field representing pressed modifier keys. Values: Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).</p> <p> TYPE: <code>Optional[KeyModifier]</code> DEFAULT: <code>None</code> </p> <code>timestamp</code> <p>Time at which the event occurred, in seconds since epoch.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>button</code> <p>Mouse button being pressed/released. Default is \"none\". Allowed values: \"none\", \"left\", \"middle\", \"right\", \"back\", \"forward\".</p> <p> TYPE: <code>Optional[MouseButton]</code> DEFAULT: <code>None</code> </p> <code>click_count</code> <p>Number of times the mouse button was clicked (default: 0). For example, 2 for a double-click.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>force</code> <p>The normalized pressure, which has a range of [0,1] (default: 0). Used primarily for pressure-sensitive inputs.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>tangential_pressure</code> <p>The normalized tangential pressure, which has a range of [-1,1] (default: 0). Used for stylus input.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>tilt_x</code> <p>The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90]. A positive tiltX is to the right (default: 0).</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>tilt_y</code> <p>The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90]. A positive tiltY is towards the user (default: 0).</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>twist</code> <p>The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>delta_x</code> <p>X delta in CSS pixels for mouse wheel event (default: 0). Positive values scroll right.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>delta_y</code> <p>Y delta in CSS pixels for mouse wheel event (default: 0). Positive values scroll up.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>pointer_type</code> <p>Pointer type (default: \"mouse\"). Allowed values: \"mouse\", \"pen\".</p> <p> TYPE: <code>Optional[PointerType]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to dispatch the mouse event.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.input_commands.InputCommands.dispatch_touch_event","title":"dispatch_touch_event  <code>staticmethod</code>","text":"<pre><code>dispatch_touch_event(type, touch_points=None, modifiers=None, timestamp=None)\n</code></pre> <p>Generates a command to dispatch a touch event to the page.</p> <p>This method allows simulating touch interactions on touch-enabled devices or emulated touch environments.</p> PARAMETER DESCRIPTION <code>type</code> <p>Type of the touch event. Allowed values:  - touchStart: Touch started - at least one point must be specified  - touchEnd: Touch ended - points that are no longer pressed should be removed  - touchMove: Touch moved - active points should be updated  - touchCancel: Touch canceled - clears all touch points  Touch end and cancel events must not contain any touch points,  while touch start and move must contain at least one.</p> <p> TYPE: <code>TouchEventType</code> </p> <code>touch_points</code> <p>list of active touch points. One event per any changed point         (compared to previous event) is generated, emulating         pressing/moving/releasing points one by one.         Each point includes coordinates and other properties.</p> <p> TYPE: <code>Optional[list[TouchPoint]]</code> DEFAULT: <code>None</code> </p> <code>modifiers</code> <p>Bit field representing pressed modifier keys. Values:       Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).</p> <p> TYPE: <code>Optional[KeyModifier]</code> DEFAULT: <code>None</code> </p> <code>timestamp</code> <p>Time at which the event occurred, in seconds since epoch.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to dispatch the touch event.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.input_commands.InputCommands.set_ignore_input_events","title":"set_ignore_input_events  <code>staticmethod</code>","text":"<pre><code>set_ignore_input_events(enabled)\n</code></pre> <p>Generates a command to ignore input events (useful while auditing page).</p> <p>When enabled, all input events will be ignored, which can be useful during automated tests or when you want to prevent user interaction while performing certain operations.</p> PARAMETER DESCRIPTION <code>enabled</code> <p>If true, input events processing will be ignored.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set ignore input events.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.input_commands.InputCommands.dispatch_drag_event","title":"dispatch_drag_event  <code>staticmethod</code>","text":"<pre><code>dispatch_drag_event(type, x, y, data=None, modifiers=None)\n</code></pre> <p>Generates a command to dispatch a drag event into the page.</p> <p>This experimental method allows simulating drag and drop operations by dispatching drag events at specific coordinates.</p> PARAMETER DESCRIPTION <code>type</code> <p>Type of the drag event. Allowed values:  - dragEnter: Fired when a dragged item enters a valid drop target  - dragOver: Fired when a dragged item is being dragged over a valid drop target  - drop: Fired when an item is dropped on a valid drop target  - dragCancel: Fired when a drag operation is being canceled</p> <p> TYPE: <code>DragEventType</code> </p> <code>x</code> <p>X coordinate of the event relative to the main frame's viewport in CSS pixels.</p> <p> TYPE: <code>int</code> </p> <code>y</code> <p>Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport, and Y increases going down.</p> <p> TYPE: <code>int</code> </p> <code>data</code> <p>Drag data containing items being dragged, their MIME types, and other information.</p> <p> TYPE: <code>Optional[DragData]</code> DEFAULT: <code>None</code> </p> <code>modifiers</code> <p>Bit field representing pressed modifier keys. Values:       Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).</p> <p> TYPE: <code>Optional[KeyModifier]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to dispatch the drag event.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.input_commands.InputCommands.emulate_touch_from_mouse_event","title":"emulate_touch_from_mouse_event  <code>staticmethod</code>","text":"<pre><code>emulate_touch_from_mouse_event(type, x, y, button, timestamp=None, delta_x=None, delta_y=None, modifiers=None, click_count=None)\n</code></pre> <p>Generates a command to emulate touch event from the mouse event parameters.</p> <p>This experimental method allows converting mouse events into touch events, useful for testing touch interactions in environments where touch is not available.</p> PARAMETER DESCRIPTION <code>type</code> <p>Type of the mouse event to convert. Allowed values:  - mousePressed: Converted to touchStart  - mouseReleased: Converted to touchEnd  - mouseMoved: Converted to touchMove  - mouseWheel: May trigger scrolling</p> <p> TYPE: <code>MouseEventType</code> </p> <code>x</code> <p>X coordinate of the mouse pointer in device-independent pixels (DIP).</p> <p> TYPE: <code>int</code> </p> <code>y</code> <p>Y coordinate of the mouse pointer in DIP.</p> <p> TYPE: <code>int</code> </p> <code>button</code> <p>Mouse button. Only \"none\", \"left\", \"right\" are supported.</p> <p> TYPE: <code>MouseButton</code> </p> <code>timestamp</code> <p>Time at which the event occurred, in seconds since epoch.       Default is current time.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>delta_x</code> <p>X delta in DIP for mouse wheel event (default: 0). Used for scrolling.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>delta_y</code> <p>Y delta in DIP for mouse wheel event (default: 0). Used for scrolling.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>modifiers</code> <p>Bit field representing pressed modifier keys. Values:       Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).</p> <p> TYPE: <code>Optional[KeyModifier]</code> DEFAULT: <code>None</code> </p> <code>click_count</code> <p>Number of times the mouse button was clicked (default: 0).        For example, 2 for a double-click.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to emulate touch from mouse event.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.input_commands.InputCommands.ime_set_composition","title":"ime_set_composition  <code>staticmethod</code>","text":"<pre><code>ime_set_composition(text, selection_start, selection_end, replacement_start=None, replacement_end=None)\n</code></pre> <p>Generates a command to set the current candidate text for IME.</p> <p>This experimental method sets the text for Input Method Editors (IME), which are used for entering characters in languages that require more keystrokes than the number of characters (like Chinese, Japanese, Korean).</p> <p>Use imeCommitComposition to commit the final text. Use imeSetComposition with empty string as text to cancel composition.</p> PARAMETER DESCRIPTION <code>text</code> <p>The text to insert as the IME composition.</p> <p> TYPE: <code>str</code> </p> <code>selection_start</code> <p>Start position of the selection within the composition text.</p> <p> TYPE: <code>int</code> </p> <code>selection_end</code> <p>End position of the selection within the composition text.</p> <p> TYPE: <code>int</code> </p> <code>replacement_start</code> <p>Start position of the text to be replaced (default: same as selection_start).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>replacement_end</code> <p>End position of the text to be replaced (default: same as selection_end).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set IME composition.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.input_commands.InputCommands.insert_text","title":"insert_text  <code>staticmethod</code>","text":"<pre><code>insert_text(text)\n</code></pre> <p>Generates a command to emulate inserting text that doesn't come from a key press.</p> <p>This experimental method is useful for inserting text that would normally come from sources other than keyboard, such as emoji pickers, IMEs, or clipboard pastes.</p> PARAMETER DESCRIPTION <code>text</code> <p>The text to insert.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to insert text.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.input_commands.InputCommands.set_intercept_drags","title":"set_intercept_drags  <code>staticmethod</code>","text":"<pre><code>set_intercept_drags(enabled)\n</code></pre> <p>Generates a command to control interception of drag and drop events.</p> <p>This experimental method prevents default drag and drop behavior and instead emits Input.dragIntercepted events. Drag and drop behavior can then be directly controlled via Input.dispatchDragEvent.</p> <p>This is useful for implementing custom drag and drop logic or for testing drag and drop behavior in automated tests.</p> PARAMETER DESCRIPTION <code>enabled</code> <p>If true, drag events will be intercepted and reported as     dragIntercepted events, preventing the default behavior.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set drag interception.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.input_commands.InputCommands.synthesize_pinch_gesture","title":"synthesize_pinch_gesture  <code>staticmethod</code>","text":"<pre><code>synthesize_pinch_gesture(x, y, scale_factor, relative_speed=None, gesture_source_type=None)\n</code></pre> <p>Generates a command to synthesize a pinch gesture over a time period.</p> <p>This experimental method creates a synthetic pinch gesture (zoom in/out) by issuing appropriate touch events over time. This is useful for testing pinch-to-zoom functionality in web applications.</p> PARAMETER DESCRIPTION <code>x</code> <p>X coordinate of the start of the gesture in CSS pixels.</p> <p> TYPE: <code>int</code> </p> <code>y</code> <p>Y coordinate of the start of the gesture in CSS pixels.</p> <p> TYPE: <code>int</code> </p> <code>scale_factor</code> <p>Relative scale factor after zooming:         - &gt;1.0 zooms in (fingers moving apart)         - &lt;1.0 zooms out (fingers moving together)</p> <p> TYPE: <code>float</code> </p> <code>relative_speed</code> <p>Relative pointer speed in pixels per second (default: 800).           Controls how fast the gesture happens.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>gesture_source_type</code> <p>Which type of input events to be generated:               - 'default': Platform's preferred input type               - 'touch': Touch input               - 'mouse': Mouse input</p> <p> TYPE: <code>Optional[GestureSourceType]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to synthesize a pinch gesture.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.input_commands.InputCommands.synthesize_scroll_gesture","title":"synthesize_scroll_gesture  <code>staticmethod</code>","text":"<pre><code>synthesize_scroll_gesture(x, y, x_distance=None, y_distance=None, x_overscroll=None, y_overscroll=None, prevent_fling=None, speed=None, gesture_source_type=None, repeat_count=None, repeat_delay_ms=None, interaction_marker_name=None)\n</code></pre> <p>Generates a command to synthesize a scroll gesture over a time period.</p> <p>This experimental method creates a synthetic scroll gesture by issuing appropriate touch events over time. This is useful for testing scrolling behavior in web applications.</p> PARAMETER DESCRIPTION <code>x</code> <p>X coordinate of the start of the gesture in CSS pixels.</p> <p> TYPE: <code>int</code> </p> <code>y</code> <p>Y coordinate of the start of the gesture in CSS pixels.</p> <p> TYPE: <code>int</code> </p> <code>x_distance</code> <p>The distance to scroll along the X axis (positive to scroll left).</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>y_distance</code> <p>The distance to scroll along the Y axis (positive to scroll up).</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>x_overscroll</code> <p>The number of additional pixels to scroll back along the X axis,         in addition to the given distance. This creates an overscroll         effect (rubber-banding).</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>y_overscroll</code> <p>The number of additional pixels to scroll back along the Y axis,         in addition to the given distance. This creates an overscroll         effect (rubber-banding).</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>prevent_fling</code> <p>Prevent fling (default: true). If false, a fling animation might          continue after the gesture.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>speed</code> <p>Swipe speed in pixels per second (default: 800).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>gesture_source_type</code> <p>Which type of input events to be generated:               - 'default': Platform's preferred input type               - 'touch': Touch input               - 'mouse': Mouse input</p> <p> TYPE: <code>Optional[GestureSourceType]</code> DEFAULT: <code>None</code> </p> <code>repeat_count</code> <p>The number of times to repeat the gesture (default: 0).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>repeat_delay_ms</code> <p>The number of milliseconds delay between each repeat (default: 250).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>interaction_marker_name</code> <p>The name of the interaction markers to generate, if not empty.                   Used for tracking gesture timing in performance measurements.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to synthesize a scroll gesture.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.input_commands.InputCommands.synthesize_tap_gesture","title":"synthesize_tap_gesture  <code>staticmethod</code>","text":"<pre><code>synthesize_tap_gesture(x, y, duration=None, tap_count=None, gesture_source_type=None)\n</code></pre> <p>Generates a command to synthesize a tap gesture over a time period.</p> <p>This experimental method creates a synthetic tap gesture by issuing appropriate touch events over time. This is useful for testing touch interaction in web applications.</p> PARAMETER DESCRIPTION <code>x</code> <p>X coordinate of the start of the gesture in CSS pixels.</p> <p> TYPE: <code>int</code> </p> <code>y</code> <p>Y coordinate of the start of the gesture in CSS pixels.</p> <p> TYPE: <code>int</code> </p> <code>duration</code> <p>Duration between touchdown and touchup events in milliseconds (default: 50).      Controls how long the tap gesture takes.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>tap_count</code> <p>Number of times to perform the tap (e.g., 2 for a double tap, default: 1).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>gesture_source_type</code> <p>Which type of input events to be generated:               - 'default': Platform's preferred input type               - 'touch': Touch input               - 'mouse': Mouse input</p> <p> TYPE: <code>Optional[GestureSourceType]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to synthesize a tap gesture.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#fetch-commands","title":"Fetch Commands","text":""},{"location":"api/protocol/commands/#pydoll.commands.fetch_commands","title":"pydoll.commands.fetch_commands","text":""},{"location":"api/protocol/commands/#pydoll.commands.fetch_commands.FetchCommands","title":"FetchCommands","text":"<p>This class encapsulates the fetch commands of the Chrome DevTools Protocol (CDP).</p> <p>CDP's Fetch domain allows interception and modification of network requests at the application layer. This enables developers to examine, modify, and control network traffic, which is particularly useful for testing, debugging, and advanced automation scenarios.</p> <p>The commands defined in this class provide functionality for: - Enabling and disabling fetch request interception - Continuing, fulfilling, or failing intercepted requests - Handling authentication challenges - Retrieving and modifying response bodies - Processing response data as streams</p>"},{"location":"api/protocol/commands/#pydoll.commands.fetch_commands.FetchCommands.continue_request","title":"continue_request  <code>staticmethod</code>","text":"<pre><code>continue_request(request_id, url=None, method=None, post_data=None, headers=None, intercept_response=None)\n</code></pre> <p>Creates a command to continue a paused fetch request.</p> <p>This command allows the browser to resume a fetch operation that has been intercepted. You can modify the fetch request URL, method, headers, and body before continuing.</p> PARAMETER DESCRIPTION <code>request_id</code> <p>The ID of the fetch request to continue.</p> <p> TYPE: <code>str</code> </p> <code>url</code> <p>The new URL for the fetch request. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>method</code> <p>The HTTP method to use (e.g., 'GET', 'POST'). Defaults to None.</p> <p> TYPE: <code>Optional[RequestMethod]</code> DEFAULT: <code>None</code> </p> <code>post_data</code> <p>The body data to send with the fetch request. Defaults to None.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>A list of HTTP headers to include in the fetch request. Defaults to None.</p> <p> TYPE: <code>Optional[list[HeaderEntry]]</code> DEFAULT: <code>None</code> </p> <code>intercept_response</code> <p>Indicates if the response should be intercepted. Defaults to None.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: A command for continuing the fetch request.</p>"},{"location":"api/protocol/commands/#pydoll.commands.fetch_commands.FetchCommands.continue_request_with_auth","title":"continue_request_with_auth  <code>staticmethod</code>","text":"<pre><code>continue_request_with_auth(request_id, auth_challenge_response, proxy_username=None, proxy_password=None)\n</code></pre> <p>Creates a command to continue a paused fetch request with authentication.</p> <p>This command is used when the fetch operation requires authentication. It provides the necessary credentials to continue the request.</p> PARAMETER DESCRIPTION <code>request_id</code> <p>The ID of the fetch request to continue.</p> <p> TYPE: <code>str</code> </p> <code>auth_challenge_response</code> <p>The authentication challenge response type.</p> <p> TYPE: <code>AuthChallengeResponseValues</code> </p> <code>proxy_username</code> <p>The username for proxy authentication. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>proxy_password</code> <p>The password for proxy authentication. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: A command for continuing the fetch request with authentication.</p>"},{"location":"api/protocol/commands/#pydoll.commands.fetch_commands.FetchCommands.disable","title":"disable  <code>staticmethod</code>","text":"<pre><code>disable()\n</code></pre> <p>Creates a command to disable fetch interception.</p> <p>This command stops the browser from intercepting fetch requests.</p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: A command for disabling fetch interception.</p>"},{"location":"api/protocol/commands/#pydoll.commands.fetch_commands.FetchCommands.enable","title":"enable  <code>staticmethod</code>","text":"<pre><code>enable(handle_auth_requests, url_pattern='*', resource_type=None, request_stage=None)\n</code></pre> <p>Creates a command to enable fetch interception.</p> <p>This command allows the browser to start intercepting fetch requests. You can specify whether to handle authentication challenges and the types of resources to intercept.</p> PARAMETER DESCRIPTION <code>handle_auth_requests</code> <p>Indicates if authentication requests should be handled.</p> <p> TYPE: <code>bool</code> </p> <code>url_pattern</code> <p>Pattern to match URLs for interception. Defaults to '*'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'*'</code> </p> <code>resource_type</code> <p>The type of resource to intercept. Defaults to None.</p> <p> TYPE: <code>Optional[ResourceType]</code> DEFAULT: <code>None</code> </p> <code>request_stage</code> <p>The stage of the request to intercept. Defaults to None.</p> <p> TYPE: <code>Optional[RequestStage]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: A command for enabling fetch interception.</p>"},{"location":"api/protocol/commands/#pydoll.commands.fetch_commands.FetchCommands.fail_request","title":"fail_request  <code>staticmethod</code>","text":"<pre><code>fail_request(request_id, error_reason)\n</code></pre> <p>Creates a command to simulate a failure in a fetch request.</p> <p>This command allows you to simulate a failure for a specific fetch operation, providing a reason for the failure.</p> PARAMETER DESCRIPTION <code>request_id</code> <p>The ID of the fetch request to fail.</p> <p> TYPE: <code>str</code> </p> <code>error_reason</code> <p>The reason for the failure.</p> <p> TYPE: <code>NetworkErrorReason</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: A command for failing the fetch request.</p>"},{"location":"api/protocol/commands/#pydoll.commands.fetch_commands.FetchCommands.fulfill_request","title":"fulfill_request  <code>staticmethod</code>","text":"<pre><code>fulfill_request(request_id, response_code, response_headers=None, body=None, response_phrase=None)\n</code></pre> <p>Creates a command to fulfill a fetch request with a custom response.</p> <p>This command allows you to provide a custom response for a fetch operation, including the HTTP status code, headers, and body content.</p> PARAMETER DESCRIPTION <code>request_id</code> <p>The ID of the fetch request to fulfill.</p> <p> TYPE: <code>str</code> </p> <code>response_code</code> <p>The HTTP status code to return.</p> <p> TYPE: <code>int</code> </p> <code>response_headers</code> <p>A list of response headers. Defaults to None.</p> <p> TYPE: <code>Optional[list[HeaderEntry]]</code> DEFAULT: <code>None</code> </p> <code>body</code> <p>The body content of the response. Defaults to None.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>response_phrase</code> <p>The response phrase (e.g., 'OK', 'Not Found'). Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: A command for fulfilling the fetch request.</p>"},{"location":"api/protocol/commands/#pydoll.commands.fetch_commands.FetchCommands.get_response_body","title":"get_response_body  <code>staticmethod</code>","text":"<pre><code>get_response_body(request_id)\n</code></pre> <p>Creates a command to retrieve the response body of a fetch request.</p> <p>This command allows you to access the body of a completed fetch operation, which can be useful for analyzing the response data.</p> PARAMETER DESCRIPTION <code>request_id</code> <p>The ID of the fetch request to retrieve the body from.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command[GetResponseBodyResponse]</code> <p>Command[GetResponseBodyResponse]: A command for getting the response body.</p>"},{"location":"api/protocol/commands/#pydoll.commands.fetch_commands.FetchCommands.continue_response","title":"continue_response  <code>staticmethod</code>","text":"<pre><code>continue_response(request_id, response_code=None, response_headers=None, response_phrase=None)\n</code></pre> <p>Creates a command to continue a fetch response for an intercepted request.</p> <p>This command allows the browser to continue the response flow for a specific fetch request, including customizing the HTTP status code, headers, and response phrase.</p> PARAMETER DESCRIPTION <code>request_id</code> <p>The ID of the fetch request to continue the response for.</p> <p> TYPE: <code>str</code> </p> <code>response_code</code> <p>The HTTP status code to send. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>response_headers</code> <p>A list of response headers. Defaults to None.</p> <p> TYPE: <code>Optional[list[HeaderEntry]]</code> DEFAULT: <code>None</code> </p> <code>response_phrase</code> <p>The response phrase (e.g., 'OK'). Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: A command for continuing the fetch response.</p>"},{"location":"api/protocol/commands/#pydoll.commands.fetch_commands.FetchCommands.take_response_body_as_stream","title":"take_response_body_as_stream  <code>staticmethod</code>","text":"<pre><code>take_response_body_as_stream(request_id)\n</code></pre> <p>Creates a command to take the response body as a stream.</p> <p>This command allows you to receive the response body as a stream which can be useful for handling large responses.</p> PARAMETER DESCRIPTION <code>request_id</code> <p>The ID of the fetch request to take the response body stream from.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command[TakeResponseBodyAsStreamResponse]</code> <p>Command[TakeResponseBodyAsStreamResponse]: A command for taking the response body as a stream.</p>"},{"location":"api/protocol/commands/#browser-commands","title":"Browser Commands","text":""},{"location":"api/protocol/commands/#pydoll.commands.browser_commands","title":"pydoll.commands.browser_commands","text":""},{"location":"api/protocol/commands/#pydoll.commands.browser_commands.BrowserCommands","title":"BrowserCommands","text":"<p>BrowserCommands class provides a set of commands to interact with the browser's main functionality based on CDP. These commands allow for managing browser windows, such as closing windows, retrieving window IDs, and adjusting window bounds (size and state).</p> <p>The commands defined in this class provide functionality for: - Managing browser windows and targets. - Setting permissions and download behavior. - Controlling browser windows (size, state). - Retrieving browser information and versioning.</p>"},{"location":"api/protocol/commands/#pydoll.commands.browser_commands.BrowserCommands.get_version","title":"get_version  <code>staticmethod</code>","text":"<pre><code>get_version()\n</code></pre> <p>Generates a command to get browser version information.</p> RETURNS DESCRIPTION <code>Command[GetVersionResponse]</code> <p>Command[GetVersionResponse]: The CDP command that returns browser version details including protocol version, product name, revision, and user agent.</p>"},{"location":"api/protocol/commands/#pydoll.commands.browser_commands.BrowserCommands.reset_permissions","title":"reset_permissions  <code>staticmethod</code>","text":"<pre><code>reset_permissions(browser_context_id=None)\n</code></pre> <p>Generates a command to reset all permissions.</p> PARAMETER DESCRIPTION <code>browser_context_id</code> <p>The browser context to reset permissions for. If not specified, resets permissions for the default context.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: The CDP command that returns a basic success response.</p>"},{"location":"api/protocol/commands/#pydoll.commands.browser_commands.BrowserCommands.cancel_download","title":"cancel_download  <code>staticmethod</code>","text":"<pre><code>cancel_download(guid, browser_context_id=None)\n</code></pre> <p>Generates a command to cancel a download.</p> PARAMETER DESCRIPTION <code>guid</code> <p>Global unique identifier of the download.</p> <p> TYPE: <code>str</code> </p> <code>browser_context_id</code> <p>The browser context the download belongs to. If not specified, uses the default context.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: The CDP command that returns a basic success response.</p>"},{"location":"api/protocol/commands/#pydoll.commands.browser_commands.BrowserCommands.crash","title":"crash  <code>staticmethod</code>","text":"<pre><code>crash()\n</code></pre> <p>Generates a command to crash the browser main process.</p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: The CDP command that returns a basic success response before crashing the browser.</p>"},{"location":"api/protocol/commands/#pydoll.commands.browser_commands.BrowserCommands.crash_gpu_process","title":"crash_gpu_process  <code>staticmethod</code>","text":"<pre><code>crash_gpu_process()\n</code></pre> <p>Generates a command to crash the browser GPU process.</p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: The CDP command that returns a basic success response before crashing the GPU process.</p>"},{"location":"api/protocol/commands/#pydoll.commands.browser_commands.BrowserCommands.set_download_behavior","title":"set_download_behavior  <code>staticmethod</code>","text":"<pre><code>set_download_behavior(behavior, download_path=None, browser_context_id=None, events_enabled=True)\n</code></pre> <p>Generates a command to set the download behavior for the browser.</p> PARAMETER DESCRIPTION <code>behavior</code> <p>The behavior to set for downloads.</p> <p> TYPE: <code>DownloadBehavior</code> </p> <code>download_path</code> <p>The path to set for downloads.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: The CDP command that returns a basic success response after setting the download path.</p>"},{"location":"api/protocol/commands/#pydoll.commands.browser_commands.BrowserCommands.close","title":"close  <code>staticmethod</code>","text":"<pre><code>close()\n</code></pre> <p>Generates a command to close the browser.</p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: The CDP command that returns a basic success response before closing the browser.</p>"},{"location":"api/protocol/commands/#pydoll.commands.browser_commands.BrowserCommands.get_window_for_target","title":"get_window_for_target  <code>staticmethod</code>","text":"<pre><code>get_window_for_target(target_id)\n</code></pre> <p>Generates a command to get the window for a given target ID.</p> PARAMETER DESCRIPTION <code>target_id</code> <p>The target_id to get the window for.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command[GetWindowForTargetResponse]</code> <p>Command[GetWindowForTargetResponse]: The CDP command that returns window information including windowId and bounds.</p>"},{"location":"api/protocol/commands/#pydoll.commands.browser_commands.BrowserCommands.set_window_bounds","title":"set_window_bounds  <code>staticmethod</code>","text":"<pre><code>set_window_bounds(window_id, bounds)\n</code></pre> <p>Generates a command to set the bounds of a window.</p> PARAMETER DESCRIPTION <code>window_id</code> <p>The ID of the window to set the bounds for.</p> <p> TYPE: <code>int</code> </p> <code>bounds</code> <p>The bounds to set for the window, which should include windowState and optionally width, height, x, and y coordinates.</p> <p> TYPE: <code>WindowBoundsDict</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: The CDP command that returns a basic success response after setting the window bounds.</p>"},{"location":"api/protocol/commands/#pydoll.commands.browser_commands.BrowserCommands.set_window_maximized","title":"set_window_maximized  <code>staticmethod</code>","text":"<pre><code>set_window_maximized(window_id)\n</code></pre> <p>Generates a command to maximize a window.</p> PARAMETER DESCRIPTION <code>window_id</code> <p>The ID of the window to maximize.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: The CDP command that returns a basic success response after maximizing the window.</p>"},{"location":"api/protocol/commands/#pydoll.commands.browser_commands.BrowserCommands.set_window_minimized","title":"set_window_minimized  <code>staticmethod</code>","text":"<pre><code>set_window_minimized(window_id)\n</code></pre> <p>Generates a command to minimize a window.</p> PARAMETER DESCRIPTION <code>window_id</code> <p>The ID of the window to minimize.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: The CDP command that returns a basic success response after minimizing the window.</p>"},{"location":"api/protocol/commands/#pydoll.commands.browser_commands.BrowserCommands.grant_permissions","title":"grant_permissions  <code>staticmethod</code>","text":"<pre><code>grant_permissions(permissions, origin=None, browser_context_id=None)\n</code></pre> <p>Generates a command to grant specific permissions to the given origin.</p> PARAMETER DESCRIPTION <code>permissions</code> <p>list of permissions to grant. See PermissionType enum for available permissions.</p> <p> TYPE: <code>list[PermissionType]</code> </p> <code>origin</code> <p>The origin to grant permissions to. If not specified, grants for all origins.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>browser_context_id</code> <p>The browser context to grant permissions in. If not specified, uses the default context.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command[Response]</code> <p>Command[Response]: The CDP command that returns a basic success response after granting the specified permissions.</p>"},{"location":"api/protocol/commands/#target-commands","title":"Target Commands","text":""},{"location":"api/protocol/commands/#pydoll.commands.target_commands","title":"pydoll.commands.target_commands","text":""},{"location":"api/protocol/commands/#pydoll.commands.target_commands.TargetCommands","title":"TargetCommands","text":"<p>A class for managing browser targets using Chrome DevTools Protocol.</p> <p>The Target domain of CDP supports additional targets discovery and allows to attach to them. Targets can represent browser tabs, windows, frames, web workers, service workers, etc. The domain provides methods to create, discover, and control these targets.</p> <p>This class provides methods to create commands for interacting with browser targets, including creating, activating, attaching to, and closing targets through CDP commands.</p>"},{"location":"api/protocol/commands/#pydoll.commands.target_commands.TargetCommands.activate_target","title":"activate_target  <code>staticmethod</code>","text":"<pre><code>activate_target(target_id)\n</code></pre> <p>Generates a command to activate (focus) a target.</p> PARAMETER DESCRIPTION <code>target_id</code> <p>ID of the target to activate.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to activate the target.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.target_commands.TargetCommands.attach_to_target","title":"attach_to_target  <code>staticmethod</code>","text":"<pre><code>attach_to_target(target_id, flatten=None)\n</code></pre> <p>Generates a command to attach to a target with the given ID.</p> <p>When attached to a target, you can send commands to it and receive events from it. This is essential for controlling and automating targets like browser tabs.</p> PARAMETER DESCRIPTION <code>target_id</code> <p>ID of the target to attach to.</p> <p> TYPE: <code>str</code> </p> <code>flatten</code> <p>If true, enables \"flat\" access to the session via specifying sessionId     attribute in the commands. This is recommended as the non-flattened     mode is being deprecated. See https://crbug.com/991325</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to attach to the target, which will return a sessionId.</p> <p> TYPE: <code>Command[AttachToTargetResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.target_commands.TargetCommands.close_target","title":"close_target  <code>staticmethod</code>","text":"<pre><code>close_target(target_id)\n</code></pre> <p>Generates a command to close a target.</p> <p>If the target is a page or a tab, it will be closed. This is equivalent to clicking the close button on a browser tab.</p> PARAMETER DESCRIPTION <code>target_id</code> <p>ID of the target to close.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to close the target, which will return a success flag.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.target_commands.TargetCommands.create_browser_context","title":"create_browser_context  <code>staticmethod</code>","text":"<pre><code>create_browser_context(dispose_on_detach=None, proxy_server=None, proxy_bypass_list=None, origins_with_universal_network_access=None)\n</code></pre> <p>Generates a command to create a new empty browser context.</p> <p>A browser context is similar to an incognito profile but you can have more than one. Each context has its own set of cookies, local storage, and other browser data. This is useful for testing multiple users or isolating sessions.</p> PARAMETER DESCRIPTION <code>dispose_on_detach</code> <p>If specified, the context will be disposed when the               debugging session disconnects.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>proxy_server</code> <p>Proxy server string, similar to the one passed to --proxy-server          command line argument (e.g., \"socks5://192.168.1.100:1080\").</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>proxy_bypass_list</code> <p>Proxy bypass list, similar to the one passed to                --proxy-bypass-list command line argument                (e.g., \"*.example.com,localhost\").</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>origins_with_universal_network_access</code> <p>An optional list of origins to grant                                   unlimited cross-origin access to.                                   Parts of the URL other than those                                   constituting origin are ignored.</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to create a browser context, which will return     the ID of the created context.</p> <p> TYPE: <code>Command[CreateBrowserContextResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.target_commands.TargetCommands.create_target","title":"create_target  <code>staticmethod</code>","text":"<pre><code>create_target(url, left=None, top=None, width=None, height=None, window_state=None, browser_context_id=None, enable_begin_frame_control=None, new_window=None, background=None, for_tab=None, hidden=None)\n</code></pre> <p>Generates a command to create a new page (target).</p> <p>This is one of the primary methods to open a new tab or window with specific properties such as position, size, and browser context.</p> PARAMETER DESCRIPTION <code>url</code> <p>The initial URL the page will navigate to. An empty string indicates about:blank.</p> <p> TYPE: <code>str</code> </p> <code>left</code> <p>Frame left position in device-independent pixels (DIP).  Requires newWindow to be true or in headless mode.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>top</code> <p>Frame top position in DIP. Requires newWindow to be true or in headless mode.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>width</code> <p>Frame width in DIP.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>height</code> <p>Frame height in DIP.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>window_state</code> <p>Frame window state: normal, minimized, maximized, or fullscreen.          Default is normal.</p> <p> TYPE: <code>Optional[WindowState]</code> DEFAULT: <code>None</code> </p> <code>browser_context_id</code> <p>The browser context to create the page in.                If not specified, the default browser context is used.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>enable_begin_frame_control</code> <p>Whether BeginFrames for this target will be controlled                        via DevTools (headless shell only, not supported on                        MacOS yet, false by default).</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>new_window</code> <p>Whether to create a new window or tab (false by default,        not supported by headless shell).</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>background</code> <p>Whether to create the target in background or foreground        (false by default, not supported by headless shell).</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>for_tab</code> <p>Whether to create the target of type \"tab\".</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>hidden</code> <p>Whether to create a hidden target. The hidden target is observable via    protocol, but not present in the tab UI strip. Cannot be created with    forTab:true, newWindow:true or background:false. The life-time of the    tab is limited to the life-time of the session.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to create a target, which will return the ID of the created target.</p> <p> TYPE: <code>Command[CreateTargetResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.target_commands.TargetCommands.detach_from_target","title":"detach_from_target  <code>staticmethod</code>","text":"<pre><code>detach_from_target(session_id=None)\n</code></pre> <p>Generates a command to detach a session from its target.</p> <p>After detaching, you will no longer receive events from the target and cannot send commands to it.</p> PARAMETER DESCRIPTION <code>session_id</code> <p>Session ID to detach. If not specified, detaches all sessions.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to detach from the target.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.target_commands.TargetCommands.dispose_browser_context","title":"dispose_browser_context  <code>staticmethod</code>","text":"<pre><code>dispose_browser_context(browser_context_id)\n</code></pre> <p>Generates a command to delete a browser context.</p> <p>All pages belonging to the browser context will be closed without calling their beforeunload hooks. This is similar to closing an incognito profile.</p> PARAMETER DESCRIPTION <code>browser_context_id</code> <p>The ID of the browser context to dispose.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to dispose the browser context.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.target_commands.TargetCommands.get_browser_contexts","title":"get_browser_contexts  <code>staticmethod</code>","text":"<pre><code>get_browser_contexts()\n</code></pre> <p>Generates a command to get all browser contexts created with createBrowserContext.</p> <p>This is useful for obtaining a list of all available contexts for managing multiple isolated browser sessions.</p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to get all browser contexts, which will return     an array of browser context IDs.</p> <p> TYPE: <code>Command[GetBrowserContextsResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.target_commands.TargetCommands.get_targets","title":"get_targets  <code>staticmethod</code>","text":"<pre><code>get_targets(filter=None)\n</code></pre> <p>Generates a command to retrieve a list of available targets.</p> <p>Targets include tabs, extensions, web workers, and other attachable entities in the browser. This is useful for discovering what targets exist before attaching to them.</p> PARAMETER DESCRIPTION <code>filter</code> <p>Only targets matching the filter will be reported. If filter is not    specified and target discovery is currently enabled, a filter used for    target discovery is used for consistency.</p> <p> TYPE: <code>Optional[list]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to get targets, which will return a list of     TargetInfo objects with details about each target.</p> <p> TYPE: <code>Command[GetTargetsResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.target_commands.TargetCommands.set_auto_attach","title":"set_auto_attach  <code>staticmethod</code>","text":"<pre><code>set_auto_attach(auto_attach, wait_for_debugger_on_start=None, flatten=None, filter=None)\n</code></pre> <p>Generates a command to control whether to automatically attach to new targets.</p> <p>This method controls whether to automatically attach to new targets which are considered to be directly related to the current one (for example, iframes or workers). When turned on, it also attaches to all existing related targets. When turned off, it automatically detaches from all currently attached targets.</p> PARAMETER DESCRIPTION <code>auto_attach</code> <p>Whether to auto-attach to related targets.</p> <p> TYPE: <code>bool</code> </p> <code>wait_for_debugger_on_start</code> <p>Whether to pause new targets when attaching to them.                        Use Runtime.runIfWaitingForDebugger to run paused targets.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>flatten</code> <p>Enables \"flat\" access to the session via specifying sessionId attribute     in the commands. This mode is being preferred, and non-flattened mode     is being deprecated (see crbug.com/991325).</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>filter</code> <p>Only targets matching filter will be attached.</p> <p> TYPE: <code>Optional[list]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set auto-attach behavior.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.target_commands.TargetCommands.set_discover_targets","title":"set_discover_targets  <code>staticmethod</code>","text":"<pre><code>set_discover_targets(discover, filter=None)\n</code></pre> <p>Generates a command to control target discovery.</p> <p>This method controls whether to discover available targets and notify via targetCreated/targetInfoChanged/targetDestroyed events. Target discovery is useful for monitoring when new tabs, workers, or other targets are created or destroyed.</p> PARAMETER DESCRIPTION <code>discover</code> <p>Whether to discover available targets.</p> <p> TYPE: <code>bool</code> </p> <code>filter</code> <p>Only targets matching filter will be discovered. If discover is false,    filter must be omitted or empty.</p> <p> TYPE: <code>Optional[list]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set target discovery.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.target_commands.TargetCommands.attach_to_browser_target","title":"attach_to_browser_target  <code>staticmethod</code>","text":"<pre><code>attach_to_browser_target(session_id)\n</code></pre> <p>Generates a command to attach to the browser target.</p> <p>This is an experimental method that attaches to the browser target, only using flat sessionId mode. The browser target is a special target that represents the browser itself rather than a page or other content.</p> PARAMETER DESCRIPTION <code>session_id</code> <p>ID of the session to attach to the browser target.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to attach to the browser target,     which will return a new session ID.</p> <p> TYPE: <code>Command[AttachToBrowserTargetResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.target_commands.TargetCommands.get_target_info","title":"get_target_info  <code>staticmethod</code>","text":"<pre><code>get_target_info(target_id)\n</code></pre> <p>Generates a command to get information about a specific target.</p> <p>This experimental method returns detailed information about a target, such as its type, URL, title, and other properties.</p> PARAMETER DESCRIPTION <code>target_id</code> <p>ID of the target to get information about.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to get target information, which will return     a TargetInfo object with details about the target.</p> <p> TYPE: <code>Command[GetTargetInfoResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.target_commands.TargetCommands.set_remote_locations","title":"set_remote_locations  <code>staticmethod</code>","text":"<pre><code>set_remote_locations(locations)\n</code></pre> <p>Generates a command to enable target discovery for specified remote locations.</p> <p>This experimental method enables target discovery for remote locations when setDiscoverTargets was set to true. This is useful for discovering targets on remote devices or in different browser instances.</p> PARAMETER DESCRIPTION <code>locations</code> <p>list of remote locations, each containing a host and port.</p> <p> TYPE: <code>list[RemoteLocation]</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set remote locations for target discovery.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#storage-commands","title":"Storage Commands","text":""},{"location":"api/protocol/commands/#pydoll.commands.storage_commands","title":"pydoll.commands.storage_commands","text":""},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands","title":"StorageCommands","text":"<p>A class for interacting with browser storage using Chrome DevTools Protocol (CDP).</p> <p>The Storage domain of CDP allows managing various types of browser storage, including: - Cookies - Cache Storage - IndexedDB - Web Storage (localStorage/sessionStorage) - Shared Storage - Storage Buckets - Trust Tokens - Interest Groups - Attribution Reporting</p> <p>This class provides static methods that generate CDP commands to manage these types of storage without the need for traditional webdrivers.</p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.clear_cookies","title":"clear_cookies  <code>staticmethod</code>","text":"<pre><code>clear_cookies(browser_context_id=None)\n</code></pre> <p>Generates a command to clear all browser cookies.</p> PARAMETER DESCRIPTION <code>browser_context_id</code> <p>Browser context ID (optional). Useful when working                with multiple contexts (e.g., multiple windows or tabs).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to clear all cookies.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.clear_data_for_origin","title":"clear_data_for_origin  <code>staticmethod</code>","text":"<pre><code>clear_data_for_origin(origin, storage_types)\n</code></pre> <p>Generates a command to clear storage data for a specific origin.</p> PARAMETER DESCRIPTION <code>origin</code> <p>The security origin (e.g., \"https://example.com\").</p> <p> TYPE: <code>str</code> </p> <code>storage_types</code> <p>Comma-separated list of storage types to clear.           Possible values include: \"cookies\", \"local_storage\", \"indexeddb\",           \"cache_storage\", etc. Use \"all\" to clear all types.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to clear data for the specified origin.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.clear_data_for_storage_key","title":"clear_data_for_storage_key  <code>staticmethod</code>","text":"<pre><code>clear_data_for_storage_key(storage_key, storage_types)\n</code></pre> <p>Generates a command to clear data for a specific storage key.</p> PARAMETER DESCRIPTION <code>storage_key</code> <p>The storage key for which to clear data.         Unlike origin, a storage key is a more specific identifier         that may include partition isolation.</p> <p> TYPE: <code>str</code> </p> <code>storage_types</code> <p>Comma-separated list of storage types to clear.           Possible values include: \"cookies\", \"local_storage\", \"indexeddb\",           \"cache_storage\", etc. Use \"all\" to clear all types.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to clear data for the specified storage key.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.get_cookies","title":"get_cookies  <code>staticmethod</code>","text":"<pre><code>get_cookies(browser_context_id=None)\n</code></pre> <p>Generates a command to get all browser cookies.</p> PARAMETER DESCRIPTION <code>browser_context_id</code> <p>Browser context ID (optional). Useful when working                with multiple contexts (e.g., multiple windows or tabs).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to get all cookies, which will return an array of Cookie objects.</p> <p> TYPE: <code>Command[GetCookiesResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.get_storage_key_for_frame","title":"get_storage_key_for_frame  <code>staticmethod</code>","text":"<pre><code>get_storage_key_for_frame(frame_id)\n</code></pre> <p>Generates a command to get the storage key for a specific frame.</p> <p>Storage keys are used to isolate data between different origins or partitions in the browser.</p> PARAMETER DESCRIPTION <code>frame_id</code> <p>The ID of the frame for which to get the storage key.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to get the storage key for the specified frame.</p> <p> TYPE: <code>Command[GetStorageKeyForFrameResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.get_usage_and_quota","title":"get_usage_and_quota  <code>staticmethod</code>","text":"<pre><code>get_usage_and_quota(origin)\n</code></pre> <p>Generates a command to get storage usage and quota information for an origin.</p> <p>Useful for monitoring or debugging storage consumption of a site.</p> PARAMETER DESCRIPTION <code>origin</code> <p>The security origin (e.g., \"https://example.com\") for which to get information.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command that will return: - usage: Storage usage in bytes - quota: Storage quota in bytes - usageBreakdown: Breakdown of usage by storage type - overrideActive: Whether there is an active quota override</p> <p> TYPE: <code>Command[GetUsageAndQuotaResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.set_cookies","title":"set_cookies  <code>staticmethod</code>","text":"<pre><code>set_cookies(cookies, browser_context_id=None)\n</code></pre> <p>Generates a command to set browser cookies.</p> PARAMETER DESCRIPTION <code>cookies</code> <p>list of Cookie objects to set.</p> <p> TYPE: <code>list[CookieParam]</code> </p> <code>browser_context_id</code> <p>Browser context ID (optional). Useful when working                with multiple contexts (e.g., multiple windows or tabs).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set the specified cookies.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.set_protected_audience_k_anonymity","title":"set_protected_audience_k_anonymity  <code>staticmethod</code>","text":"<pre><code>set_protected_audience_k_anonymity(owner, name, hashes)\n</code></pre> <p>Generates a command to set K-anonymity for protected audience.</p> <p>This command is used to configure anonymity in privacy-preserving advertising systems (part of Google's Privacy Sandbox).</p> PARAMETER DESCRIPTION <code>owner</code> <p>Owner of the K-anonymity configuration.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name of the K-anonymity configuration.</p> <p> TYPE: <code>str</code> </p> <code>hashes</code> <p>list of hashes for the configuration.</p> <p> TYPE: <code>list[str]</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set protected audience K-anonymity.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.track_cache_storage_for_origin","title":"track_cache_storage_for_origin  <code>staticmethod</code>","text":"<pre><code>track_cache_storage_for_origin(origin)\n</code></pre> <p>Generates a command to register an origin to receive notifications about changes to its Cache Storage.</p> <p>Cache Storage is primarily used by Service Workers to store resources for offline use.</p> PARAMETER DESCRIPTION <code>origin</code> <p>The security origin (e.g., \"https://example.com\") to monitor.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to register monitoring of the origin's Cache Storage.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.track_cache_storage_for_storage_key","title":"track_cache_storage_for_storage_key  <code>staticmethod</code>","text":"<pre><code>track_cache_storage_for_storage_key(storage_key)\n</code></pre> <p>Generates a command to register a storage key to receive notifications about changes to its Cache Storage.</p> <p>Similar to track_cache_storage_for_origin, but uses the storage key for more precise isolation.</p> PARAMETER DESCRIPTION <code>storage_key</code> <p>The storage key to monitor.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to register monitoring of the key's Cache Storage.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.track_indexed_db_for_origin","title":"track_indexed_db_for_origin  <code>staticmethod</code>","text":"<pre><code>track_indexed_db_for_origin(origin)\n</code></pre> <p>Generates a command to register an origin to receive notifications about changes to its IndexedDB.</p> <p>IndexedDB is a NoSQL database system in the browser for storing large amounts of structured data.</p> PARAMETER DESCRIPTION <code>origin</code> <p>The security origin (e.g., \"https://example.com\") to monitor.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to register monitoring of the origin's IndexedDB.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.track_indexed_db_for_storage_key","title":"track_indexed_db_for_storage_key  <code>staticmethod</code>","text":"<pre><code>track_indexed_db_for_storage_key(storage_key)\n</code></pre> <p>Generates a command to register a storage key to receive notifications about changes to its IndexedDB.</p> <p>Similar to track_indexed_db_for_origin, but uses the storage key for more precise isolation.</p> PARAMETER DESCRIPTION <code>storage_key</code> <p>The storage key to monitor.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to register monitoring of the key's IndexedDB.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.untrack_cache_storage_for_origin","title":"untrack_cache_storage_for_origin  <code>staticmethod</code>","text":"<pre><code>untrack_cache_storage_for_origin(origin)\n</code></pre> <p>Generates a command to unregister an origin from receiving notifications about changes to its Cache Storage.</p> <p>Use this method to stop monitoring Cache Storage after using track_cache_storage_for_origin.</p> PARAMETER DESCRIPTION <code>origin</code> <p>The security origin (e.g., \"https://example.com\") to stop monitoring.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to cancel monitoring of the origin's Cache Storage.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.untrack_cache_storage_for_storage_key","title":"untrack_cache_storage_for_storage_key  <code>staticmethod</code>","text":"<pre><code>untrack_cache_storage_for_storage_key(storage_key)\n</code></pre> <p>Generates a command to unregister a storage key from receiving notifications about changes to its Cache Storage.</p> <p>Use this method to stop monitoring Cache Storage after using track_cache_storage_for_storage_key.</p> PARAMETER DESCRIPTION <code>storage_key</code> <p>The storage key to stop monitoring.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to cancel monitoring of the key's Cache Storage.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.untrack_indexed_db_for_origin","title":"untrack_indexed_db_for_origin  <code>staticmethod</code>","text":"<pre><code>untrack_indexed_db_for_origin(origin)\n</code></pre> <p>Generates a command to unregister an origin from receiving notifications about changes to its IndexedDB.</p> <p>Use this method to stop monitoring IndexedDB after using track_indexed_db_for_origin.</p> PARAMETER DESCRIPTION <code>origin</code> <p>The security origin (e.g., \"https://example.com\") to stop monitoring.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to cancel monitoring of the origin's IndexedDB.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.untrack_indexed_db_for_storage_key","title":"untrack_indexed_db_for_storage_key  <code>staticmethod</code>","text":"<pre><code>untrack_indexed_db_for_storage_key(storage_key)\n</code></pre> <p>Generates a command to unregister a storage key from receiving notifications about changes to its IndexedDB.</p> <p>Use this method to stop monitoring IndexedDB after using track_indexed_db_for_storage_key.</p> PARAMETER DESCRIPTION <code>storage_key</code> <p>The storage key to stop monitoring.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to cancel monitoring of the key's IndexedDB.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.clear_shared_storage_entries","title":"clear_shared_storage_entries  <code>staticmethod</code>","text":"<pre><code>clear_shared_storage_entries(owner_origin)\n</code></pre> <p>Generates a command to clear all Shared Storage entries for a specific origin.</p> <p>Shared Storage is an experimental API that allows cross-origin shared storage with privacy protections.</p> PARAMETER DESCRIPTION <code>owner_origin</code> <p>The owner origin of the Shared Storage to clear.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to clear the Shared Storage entries.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.clear_trust_tokens","title":"clear_trust_tokens  <code>staticmethod</code>","text":"<pre><code>clear_trust_tokens(issuer_origin)\n</code></pre> <p>Generates a command to remove all Trust Tokens issued by the specified origin.</p> <p>Trust Tokens are an experimental API for combating fraud while preserving user privacy. This command keeps other stored data, including the issuer's redemption records, intact.</p> PARAMETER DESCRIPTION <code>issuer_origin</code> <p>The issuer origin of the tokens to remove.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to clear Trust Tokens, which will return: - didDeleteTokens: True if any tokens were deleted, False otherwise.</p> <p> TYPE: <code>Command[ClearTrustTokensResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.delete_shared_storage_entry","title":"delete_shared_storage_entry  <code>staticmethod</code>","text":"<pre><code>delete_shared_storage_entry(owner_origin, key)\n</code></pre> <p>Generates a command to delete a specific Shared Storage entry.</p> PARAMETER DESCRIPTION <code>owner_origin</code> <p>The owner origin of the Shared Storage.</p> <p> TYPE: <code>str</code> </p> <code>key</code> <p>The key of the entry to delete.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to delete the Shared Storage entry.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.delete_storage_bucket","title":"delete_storage_bucket  <code>staticmethod</code>","text":"<pre><code>delete_storage_bucket(bucket)\n</code></pre> <p>Generates a command to delete a Storage Bucket with the specified key and name.</p> <p>Storage Buckets are an experimental API for managing storage data with greater granularity and expiration control.</p> PARAMETER DESCRIPTION <code>bucket</code> <p>A StorageBucket object containing the storageKey and name of the bucket to delete.</p> <p> TYPE: <code>StorageBucket</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to delete the Storage Bucket.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.get_affected_urls_for_third_party_cookie_metadata","title":"get_affected_urls_for_third_party_cookie_metadata  <code>staticmethod</code>","text":"<pre><code>get_affected_urls_for_third_party_cookie_metadata(first_party_url, third_party_urls)\n</code></pre> <p>Generates a command to get the list of URLs from a page and its embedded resources that match existing grace period URL pattern rules.</p> <p>This command is useful for monitoring which URLs would be affected by the Privacy Sandbox's third-party cookie policies.</p> PARAMETER DESCRIPTION <code>first_party_url</code> <p>The URL of the page being visited (first-party).</p> <p> TYPE: <code>str</code> </p> <code>third_party_urls</code> <p>Optional list of embedded third-party resource URLs.</p> <p> TYPE: <code>list[str]</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to get URLs affected by third-party cookie metadata.</p> <p> TYPE: <code>Command[GetAffectedUrlsForThirdPartyCookieMetadataResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.get_interest_group_details","title":"get_interest_group_details  <code>staticmethod</code>","text":"<pre><code>get_interest_group_details(owner_origin, name)\n</code></pre> <p>Generates a command to get details of a specific interest group.</p> <p>Interest Groups are part of the FLEDGE/Protected Audience API for privacy-preserving advertising, enabling in-browser ad auctions.</p> PARAMETER DESCRIPTION <code>owner_origin</code> <p>The owner origin of the interest group.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>The name of the interest group.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to get interest group details.</p> <p> TYPE: <code>Command[GetInterestGroupDetailsResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.get_related_website_sets","title":"get_related_website_sets  <code>staticmethod</code>","text":"<pre><code>get_related_website_sets(sets)\n</code></pre> <p>Generates a command to get related website sets.</p> <p>Related Website Sets are an API that allows sites under the same entity to share some data, despite third-party cookie restrictions.</p> PARAMETER DESCRIPTION <code>sets</code> <p>list of RelatedWebsiteSet objects.</p> <p> TYPE: <code>list[RelatedWebsiteSet]</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to get related website sets.</p> <p> TYPE: <code>Command[GetRelatedWebsiteSetsResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.get_shared_storage_entries","title":"get_shared_storage_entries  <code>staticmethod</code>","text":"<pre><code>get_shared_storage_entries(owner_origin)\n</code></pre> <p>Generates a command to get all Shared Storage entries for an origin.</p> PARAMETER DESCRIPTION <code>owner_origin</code> <p>The owner origin of the Shared Storage.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to get the Shared Storage entries.</p> <p> TYPE: <code>Command[GetSharedStorageEntriesResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.get_shared_storage_metadata","title":"get_shared_storage_metadata  <code>staticmethod</code>","text":"<pre><code>get_shared_storage_metadata(owner_origin)\n</code></pre> <p>Generates a command to get Shared Storage metadata for an origin.</p> <p>Metadata includes information such as usage, budget, and creation time.</p> PARAMETER DESCRIPTION <code>owner_origin</code> <p>The owner origin of the Shared Storage.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to get Shared Storage metadata.</p> <p> TYPE: <code>Command[GetSharedStorageMetadataResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.get_trust_tokens","title":"get_trust_tokens  <code>staticmethod</code>","text":"<pre><code>get_trust_tokens()\n</code></pre> <p>Generates a command to get all available Trust Tokens.</p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to get Trust Tokens, which will return pairs     of issuer origin and count of available tokens.</p> <p> TYPE: <code>Command[GetTrustTokensResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.override_quota_for_origin","title":"override_quota_for_origin  <code>staticmethod</code>","text":"<pre><code>override_quota_for_origin(origin, quota_size=None)\n</code></pre> <p>Generates a command to override the storage quota for a specific origin.</p> <p>This command is useful for storage exhaustion testing or simulating different storage conditions.</p> PARAMETER DESCRIPTION <code>origin</code> <p>The origin for which to override the quota.</p> <p> TYPE: <code>str</code> </p> <code>quota_size</code> <p>The size of the new quota in bytes (optional).        If not specified, any existing override will be removed.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to override the origin's quota.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.reset_shared_storage_budget","title":"reset_shared_storage_budget  <code>staticmethod</code>","text":"<pre><code>reset_shared_storage_budget(owner_origin)\n</code></pre> <p>Generates a command to reset the Shared Storage budget for an origin.</p> <p>Shared Storage uses a budget system to limit the amount of operations or specific operations to preserve user privacy.</p> PARAMETER DESCRIPTION <code>owner_origin</code> <p>The owner origin of the Shared Storage.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to reset the Shared Storage budget.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.run_bounce_tracking_mitigations","title":"run_bounce_tracking_mitigations  <code>staticmethod</code>","text":"<pre><code>run_bounce_tracking_mitigations()\n</code></pre> <p>Generates a command to run bounce tracking mitigations.</p> <p>Bounce tracking is a tracking technique that involves redirecting users through intermediate URLs to establish tracking cookies. This command activates protections against this technique.</p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to run bounce tracking mitigations.</p> <p> TYPE: <code>Command[RunBounceTrackingMitigationsResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.send_pending_attribution_reports","title":"send_pending_attribution_reports  <code>staticmethod</code>","text":"<pre><code>send_pending_attribution_reports()\n</code></pre> <p>Generates a command to send pending attribution reports.</p> <p>Attribution Reporting is an API that allows measuring conversions while preserving user privacy. This command forces sending reports that are waiting to be sent.</p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to send pending attribution reports.</p> <p> TYPE: <code>Command[SendPendingAttributionReportsResponse]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.set_attribution_reporting_local_testing_mode","title":"set_attribution_reporting_local_testing_mode  <code>staticmethod</code>","text":"<pre><code>set_attribution_reporting_local_testing_mode(enable)\n</code></pre> <p>Generates a command to enable or disable local testing mode for Attribution Reporting.</p> <p>Testing mode makes it easier to develop and test the Attribution Reporting API by removing restrictions like delays and rate limits that would normally apply.</p> PARAMETER DESCRIPTION <code>enable</code> <p>True to enable local testing mode, False to disable it.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set Attribution Reporting local testing mode.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.set_attribution_reporting_tracking","title":"set_attribution_reporting_tracking  <code>staticmethod</code>","text":"<pre><code>set_attribution_reporting_tracking(enable)\n</code></pre> <p>Generates a command to enable or disable Attribution Reporting tracking.</p> PARAMETER DESCRIPTION <code>enable</code> <p>True to enable tracking, False to disable it.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set Attribution Reporting tracking.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.set_interest_group_auction_tracking","title":"set_interest_group_auction_tracking  <code>staticmethod</code>","text":"<pre><code>set_interest_group_auction_tracking(enable)\n</code></pre> <p>Generates a command to enable or disable interest group auction tracking.</p> <p>Interest group auctions are part of the FLEDGE/Protected Audience API and allow for in-browser ad auctions in a privacy-preserving way.</p> PARAMETER DESCRIPTION <code>enable</code> <p>True to enable tracking, False to disable it.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set interest group auction tracking.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.set_interest_group_tracking","title":"set_interest_group_tracking  <code>staticmethod</code>","text":"<pre><code>set_interest_group_tracking(enable)\n</code></pre> <p>Generates a command to enable or disable interest group tracking.</p> PARAMETER DESCRIPTION <code>enable</code> <p>True to enable tracking, False to disable it.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set interest group tracking.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.set_shared_storage_entry","title":"set_shared_storage_entry  <code>staticmethod</code>","text":"<pre><code>set_shared_storage_entry(owner_origin, key, value, ignore_if_present=None)\n</code></pre> <p>Generates a command to set an entry in Shared Storage.</p> PARAMETER DESCRIPTION <code>owner_origin</code> <p>The owner origin of the Shared Storage.</p> <p> TYPE: <code>str</code> </p> <code>key</code> <p>The key of the entry to set.</p> <p> TYPE: <code>str</code> </p> <code>value</code> <p>The value of the entry to set.</p> <p> TYPE: <code>str</code> </p> <code>ignore_if_present</code> <p>If True, won't replace an existing entry with the same key.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set a Shared Storage entry.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.set_shared_storage_tracking","title":"set_shared_storage_tracking  <code>staticmethod</code>","text":"<pre><code>set_shared_storage_tracking(enable)\n</code></pre> <p>Generates a command to enable or disable Shared Storage tracking.</p> <p>When enabled, events related to Shared Storage usage will be emitted.</p> PARAMETER DESCRIPTION <code>enable</code> <p>True to enable tracking, False to disable it.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set Shared Storage tracking.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/commands/#pydoll.commands.storage_commands.StorageCommands.set_storage_bucket_tracking","title":"set_storage_bucket_tracking  <code>staticmethod</code>","text":"<pre><code>set_storage_bucket_tracking(storage_key, enable)\n</code></pre> <p>Generates a command to enable or disable Storage Bucket tracking.</p> <p>When enabled, events related to changes in storage buckets will be emitted.</p> PARAMETER DESCRIPTION <code>storage_key</code> <p>The storage key for which to set tracking.</p> <p> TYPE: <code>str</code> </p> <code>enable</code> <p>True to enable tracking, False to disable it.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Command</code> <p>The CDP command to set Storage Bucket tracking.</p> <p> TYPE: <code>Command[Response]</code> </p>"},{"location":"api/protocol/events/","title":"Protocol Events","text":"<p>This section documents the Chrome DevTools Protocol event constants and handlers used by Pydoll.</p>"},{"location":"api/protocol/events/#page-events","title":"Page Events","text":""},{"location":"api/protocol/events/#pydoll.protocol.page.events","title":"pydoll.protocol.page.events","text":""},{"location":"api/protocol/events/#pydoll.protocol.page.events.PageEvent","title":"PageEvent","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Events from the Page domain of the Chrome DevTools Protocol.</p> <p>This enumeration contains the names of Page-related events that can be received from the Chrome DevTools Protocol. These events provide information about page lifecycle, frame navigation, JavaScript dialogs, and other page-related activities.</p>"},{"location":"api/protocol/events/#pydoll.protocol.page.events.PageEvent.DOM_CONTENT_EVENT_FIRED","title":"DOM_CONTENT_EVENT_FIRED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DOM_CONTENT_EVENT_FIRED = 'Page.domContentEventFired'\n</code></pre> <p>Fired when DOMContentLoaded event is fired.</p> PARAMETER DESCRIPTION <code>timestamp</code> <p>Timestamp when the event occurred.</p> <p> TYPE: <code>MonotonicTime</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.page.events.PageEvent.FILE_CHOOSER_OPENED","title":"FILE_CHOOSER_OPENED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FILE_CHOOSER_OPENED = 'Page.fileChooserOpened'\n</code></pre> <p>Emitted only when page.interceptFileChooser is enabled.</p> PARAMETER DESCRIPTION <code>frameId</code> <p>Id of the frame containing input node.</p> <p> TYPE: <code>FrameId</code> </p> <code>mode</code> <p>Input mode. Allowed Values: selectSingle, selectMultiple</p> <p> TYPE: <code>str</code> </p> <code>backendNodeId</code> <p>Input node id. Only present for file choosers opened via an  element.</p> <p> TYPE: <code>BackendNodeId</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.page.events.PageEvent.FRAME_ATTACHED","title":"FRAME_ATTACHED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FRAME_ATTACHED = 'Page.frameAttached'\n</code></pre> <p>Fired when frame has been attached to its parent.</p> PARAMETER DESCRIPTION <code>frameId</code> <p>Id of the frame that has been attached.</p> <p> TYPE: <code>FrameId</code> </p> <code>parentFrameId</code> <p>Parent frame identifier.</p> <p> TYPE: <code>FrameId</code> </p> <code>stack</code> <p>JavaScript stack trace of when frame was attached, only set if frame initiated from script.</p> <p> TYPE: <code>StackTrace</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.page.events.PageEvent.FRAME_DETACHED","title":"FRAME_DETACHED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FRAME_DETACHED = 'Page.frameDetached'\n</code></pre> <p>Fired when frame has been detached from its parent.</p> PARAMETER DESCRIPTION <code>frameId</code> <p>Id of the frame that has been detached.</p> <p> TYPE: <code>FrameId</code> </p> <code>reason</code> <p>Reason why the frame was detached. Allowed Values: remove, swap</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.page.events.PageEvent.FRAME_NAVIGATED","title":"FRAME_NAVIGATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FRAME_NAVIGATED = 'Page.frameNavigated'\n</code></pre> <p>Fired once navigation of the frame has completed. Frame is now associated with the new loader.</p> PARAMETER DESCRIPTION <code>frame</code> <p>Frame object.</p> <p> TYPE: <code>Frame</code> </p> <code>type</code> <p>Type of navigation.</p> <p> TYPE: <code>NavigationType</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.page.events.PageEvent.INTERSTITIAL_HIDDEN","title":"INTERSTITIAL_HIDDEN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INTERSTITIAL_HIDDEN = 'Page.interstitialHidden'\n</code></pre> <p>Fired when interstitial page was hidden.</p>"},{"location":"api/protocol/events/#pydoll.protocol.page.events.PageEvent.INTERSTITIAL_SHOWN","title":"INTERSTITIAL_SHOWN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INTERSTITIAL_SHOWN = 'Page.interstitialShown'\n</code></pre> <p>Fired when interstitial page was shown.</p>"},{"location":"api/protocol/events/#pydoll.protocol.page.events.PageEvent.JAVASCRIPT_DIALOG_CLOSED","title":"JAVASCRIPT_DIALOG_CLOSED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>JAVASCRIPT_DIALOG_CLOSED = 'Page.javascriptDialogClosed'\n</code></pre> <p>Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) has been closed.</p> PARAMETER DESCRIPTION <code>frameId</code> <p>Frame id.</p> <p> TYPE: <code>FrameId</code> </p> <code>result</code> <p>Whether dialog was confirmed.</p> <p> TYPE: <code>bool</code> </p> <code>userInput</code> <p>User input in case of prompt.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.page.events.PageEvent.JAVASCRIPT_DIALOG_OPENING","title":"JAVASCRIPT_DIALOG_OPENING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>JAVASCRIPT_DIALOG_OPENING = 'Page.javascriptDialogOpening'\n</code></pre> <p>Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) is about to open.</p> PARAMETER DESCRIPTION <code>url</code> <p>Frame url.</p> <p> TYPE: <code>str</code> </p> <code>frameId</code> <p>Frame id.</p> <p> TYPE: <code>FrameId</code> </p> <code>message</code> <p>Message that will be displayed by the dialog.</p> <p> TYPE: <code>str</code> </p> <code>type</code> <p>Dialog type.</p> <p> TYPE: <code>DialogType</code> </p> <code>hasBrowserHandler</code> <p>True if browser is capable showing or acting on the given dialog. When browser has no dialog handler for given target, calling alert while Page domain is engaged will stall the page execution. Execution can be resumed via calling Page.handleJavaScriptDialog.</p> <p> TYPE: <code>bool</code> </p> <code>defaultPrompt</code> <p>Default dialog prompt.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.page.events.PageEvent.LIFECYCLE_EVENT","title":"LIFECYCLE_EVENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LIFECYCLE_EVENT = 'Page.lifecycleEvent'\n</code></pre> <p>Fired for lifecycle events (navigation, load, paint, etc) in the current target (including local frames).</p> PARAMETER DESCRIPTION <code>frameId</code> <p>Id of the frame.</p> <p> TYPE: <code>FrameId</code> </p> <code>loaderId</code> <p>Loader identifier. Empty string if the request is fetched from worker.</p> <p> TYPE: <code>LoaderId</code> </p> <code>name</code> <p>Lifecycle event name.</p> <p> TYPE: <code>str</code> </p> <code>timestamp</code> <p>Timestamp when the event occurred.</p> <p> TYPE: <code>MonotonicTime</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.page.events.PageEvent.LOAD_EVENT_FIRED","title":"LOAD_EVENT_FIRED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LOAD_EVENT_FIRED = 'Page.loadEventFired'\n</code></pre> <p>Fired when the page load event has fired.</p> PARAMETER DESCRIPTION <code>timestamp</code> <p>Timestamp when the event occurred.</p> <p> TYPE: <code>MonotonicTime</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.page.events.PageEvent.WINDOW_OPEN","title":"WINDOW_OPEN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WINDOW_OPEN = 'Page.windowOpen'\n</code></pre> <p>Fired when a new window is going to be opened, via window.open(), link click, form submission, etc.</p> PARAMETER DESCRIPTION <code>url</code> <p>The URL for the new window.</p> <p> TYPE: <code>str</code> </p> <code>windowName</code> <p>Window name.</p> <p> TYPE: <code>str</code> </p> <code>windowFeatures</code> <p>An array of enabled window features.</p> <p> TYPE: <code>array[str]</code> </p> <code>userGesture</code> <p>Whether or not it was triggered by user gesture.</p> <p> TYPE: <code>bool</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.page.events.PageEvent.BACK_FORWARD_CACHE_NOT_USED","title":"BACK_FORWARD_CACHE_NOT_USED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BACK_FORWARD_CACHE_NOT_USED = 'Page.backForwardCacheNotUsed'\n</code></pre> <p>Fired for failed bfcache history navigations if BackForwardCache feature is enabled. Do not assume any ordering with the Page.frameNavigated event. This event is fired only for main-frame history navigation where the document changes (non-same-document navigations), when bfcache navigation fails.</p> PARAMETER DESCRIPTION <code>loaderId</code> <p>The loader id for the associated navigation.</p> <p> TYPE: <code>LoaderId</code> </p> <code>frameId</code> <p>The frame id of the associated frame.</p> <p> TYPE: <code>FrameId</code> </p> <code>notRestoredExplanations</code> <p>Array of reasons why the page could not be cached. This must not be empty.</p> <p> TYPE: <code>array[BackForwardCacheNotRestoredExplanation]</code> </p> <code>notRestoredExplanationsTree</code> <p>Tree structure of reasons why the page could not be cached for each frame.</p> <p> TYPE: <code>BackForwardCacheNotRestoredExplanationTree</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.page.events.PageEvent.COMPILATION_CACHE_PRODUCED","title":"COMPILATION_CACHE_PRODUCED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>COMPILATION_CACHE_PRODUCED = 'Page.compilationCacheProduced'\n</code></pre> <p>Issued for every compilation cache generated. Is only available if Page.setGenerateCompilationCache is enabled.</p> PARAMETER DESCRIPTION <code>url</code> <p>The URL of the document whose compilation cache was produced.</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>Base64-encoded data (Encoded as a base64 string when passed over JSON).</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.page.events.PageEvent.DOCUMENT_OPENED","title":"DOCUMENT_OPENED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DOCUMENT_OPENED = 'Page.documentOpened'\n</code></pre> <p>Fired when opening document to write to.</p> PARAMETER DESCRIPTION <code>frame</code> <p>Frame object.</p> <p> TYPE: <code>Frame</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.page.events.PageEvent.FRAME_REQUESTED_NAVIGATION","title":"FRAME_REQUESTED_NAVIGATION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FRAME_REQUESTED_NAVIGATION = 'Page.frameRequestedNavigation'\n</code></pre> <p>Fired when a renderer-initiated navigation is requested. Navigation may still be cancelled after the event is issued.</p> PARAMETER DESCRIPTION <code>frameId</code> <p>Id of the frame that is being navigated.</p> <p> TYPE: <code>FrameId</code> </p> <code>reason</code> <p>The reason for the navigation.</p> <p> TYPE: <code>ClientNavigationReason</code> </p> <code>url</code> <p>The destination URL for the requested navigation.</p> <p> TYPE: <code>str</code> </p> <code>disposition</code> <p>The disposition for the navigation.</p> <p> TYPE: <code>ClientNavigationDisposition</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.page.events.PageEvent.FRAME_RESIZED","title":"FRAME_RESIZED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FRAME_RESIZED = 'Page.frameResized'\n</code></pre> <p>Fired when frame has been resized.</p>"},{"location":"api/protocol/events/#pydoll.protocol.page.events.PageEvent.FRAME_STARTED_LOADING","title":"FRAME_STARTED_LOADING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FRAME_STARTED_LOADING = 'Page.frameStartedLoading'\n</code></pre> <p>Fired when frame has started loading.</p> PARAMETER DESCRIPTION <code>frameId</code> <p>Id of the frame that has started loading.</p> <p> TYPE: <code>FrameId</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.page.events.PageEvent.FRAME_STARTED_NAVIGATING","title":"FRAME_STARTED_NAVIGATING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FRAME_STARTED_NAVIGATING = 'Page.frameStartedNavigating'\n</code></pre> <p>Fired when a navigation starts. This event is fired for both renderer-initiated and browser-initiated navigations. For renderer-initiated navigations, the event is fired after frameRequestedNavigation. Navigation may still be cancelled after the event is issued. Multiple events can be fired for a single navigation, for example, when a same-document navigation becomes a cross-document navigation (such as in the case of a frameset).</p> PARAMETER DESCRIPTION <code>frameId</code> <p>ID of the frame that is being navigated.</p> <p> TYPE: <code>FrameId</code> </p> <code>url</code> <p>The URL the navigation started with. The final URL can be different.</p> <p> TYPE: <code>str</code> </p> <code>loaderId</code> <p>Loader identifier. Even though it is present in case of same-document navigation, the previously committed loaderId would not change unless the navigation changes from a same-document to a cross-document navigation.</p> <p> TYPE: <code>LoaderId</code> </p> <code>navigationType</code> <p>Type of navigation. Allowed Values: reload, reloadBypassingCache, restore, restoreWithPost, historySameDocument, historyDifferentDocument, sameDocument, differentDocument</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.page.events.PageEvent.FRAME_STOPPED_LOADING","title":"FRAME_STOPPED_LOADING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FRAME_STOPPED_LOADING = 'Page.frameStoppedLoading'\n</code></pre> <p>Fired when frame has stopped loading.</p> PARAMETER DESCRIPTION <code>frameId</code> <p>Id of the frame that has stopped loading.</p> <p> TYPE: <code>FrameId</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.page.events.PageEvent.FRAME_SUBTREE_WILL_BE_DETACHED","title":"FRAME_SUBTREE_WILL_BE_DETACHED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FRAME_SUBTREE_WILL_BE_DETACHED = 'Page.frameSubtreeWillBeDetached'\n</code></pre> <p>Fired before frame subtree is detached. Emitted before any frame of the subtree is actually detached.</p> PARAMETER DESCRIPTION <code>frameId</code> <p>Id of the frame that is the root of the subtree that will be detached.</p> <p> TYPE: <code>FrameId</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.page.events.PageEvent.NAVIGATED_WITHIN_DOCUMENT","title":"NAVIGATED_WITHIN_DOCUMENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NAVIGATED_WITHIN_DOCUMENT = 'Page.navigatedWithinDocument'\n</code></pre> <p>Fired when same-document navigation happens, e.g. due to history API usage or anchor navigation.</p> PARAMETER DESCRIPTION <code>frameId</code> <p>Id of the frame.</p> <p> TYPE: <code>FrameId</code> </p> <code>url</code> <p>Frame's new url.</p> <p> TYPE: <code>str</code> </p> <code>navigationType</code> <p>Navigation type. Allowed Values: fragment, historyApi, other</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.page.events.PageEvent.SCREENCAST_FRAME","title":"SCREENCAST_FRAME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SCREENCAST_FRAME = 'Page.screencastFrame'\n</code></pre> <p>Compressed image data requested by the startScreencast.</p> PARAMETER DESCRIPTION <code>data</code> <p>Base64-encoded compressed image.</p> <p> TYPE: <code>str</code> </p> <code>metadata</code> <p>Screencast frame metadata.</p> <p> TYPE: <code>ScreencastFrameMetadata</code> </p> <code>sessionId</code> <p>Frame number.</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.page.events.PageEvent.SCREENCAST_VISIBILITY_CHANGED","title":"SCREENCAST_VISIBILITY_CHANGED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SCREENCAST_VISIBILITY_CHANGED = 'Page.screencastVisibilityChanged'\n</code></pre> <p>Fired when the page with currently enabled screencast was shown or hidden.</p> PARAMETER DESCRIPTION <code>visible</code> <p>True if the page is visible.</p> <p> TYPE: <code>bool</code> </p>"},{"location":"api/protocol/events/#network-events","title":"Network Events","text":""},{"location":"api/protocol/events/#pydoll.protocol.network.events","title":"pydoll.protocol.network.events","text":""},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent","title":"NetworkEvent","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Events from the Network domain of the Chrome DevTools Protocol.</p> <p>This enumeration contains the names of Network-related events that can be received from the Chrome DevTools Protocol. These events provide information about network activities, such as requests, responses, and WebSocket communications.</p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.DATA_RECEIVED","title":"DATA_RECEIVED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DATA_RECEIVED = 'Network.dataReceived'\n</code></pre> <p>Fired when data chunk was received over the network.</p> PARAMETER DESCRIPTION <code>requestId</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p> <code>dataLength</code> <p>Data chunk length.</p> <p> TYPE: <code>int</code> </p> <code>encodedDataLength</code> <p>Actual bytes received (might be less than dataLength for compressed encodings).</p> <p> TYPE: <code>int</code> </p> <code>data</code> <p>Data that was received. (Encoded as a base64 string when passed over JSON)</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.EVENT_SOURCE_MESSAGE_RECEIVED","title":"EVENT_SOURCE_MESSAGE_RECEIVED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EVENT_SOURCE_MESSAGE_RECEIVED = 'Network.eventSourceMessageReceived'\n</code></pre> <p>Fired when EventSource message is received.</p> PARAMETER DESCRIPTION <code>requestId</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p> <code>eventName</code> <p>Message type.</p> <p> TYPE: <code>str</code> </p> <code>eventId</code> <p>Message identifier.</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>Message content.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.LOADING_FAILED","title":"LOADING_FAILED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LOADING_FAILED = 'Network.loadingFailed'\n</code></pre> <p>Fired when HTTP request has failed to load.</p> PARAMETER DESCRIPTION <code>requestId</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p> <code>type</code> <p>Resource type.</p> <p> TYPE: <code>ResourceType</code> </p> <code>errorText</code> <p>Error message. List of network errors: https://cs.chromium.org/chromium/src/net/base/net_error_list.h</p> <p> TYPE: <code>str</code> </p> <code>canceled</code> <p>True if loading was canceled.</p> <p> TYPE: <code>bool</code> </p> <code>blockedReason</code> <p>The reason why loading was blocked, if any.</p> <p> TYPE: <code>BlockedReason</code> </p> <code>corsErrorStatus</code> <p>The reason why loading was blocked by CORS, if any.</p> <p> TYPE: <code>CorsErrorStatus</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.LOADING_FINISHED","title":"LOADING_FINISHED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LOADING_FINISHED = 'Network.loadingFinished'\n</code></pre> <p>Fired when HTTP request has finished loading.</p> PARAMETER DESCRIPTION <code>requestId</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p> <code>encodedDataLength</code> <p>Total number of bytes received for this request.</p> <p> TYPE: <code>number</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.REQUEST_SERVED_FROM_CACHE","title":"REQUEST_SERVED_FROM_CACHE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REQUEST_SERVED_FROM_CACHE = 'Network.requestServedFromCache'\n</code></pre> <p>Fired if request ended up loading from cache.</p> PARAMETER DESCRIPTION <code>requestId</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.REQUEST_WILL_BE_SENT","title":"REQUEST_WILL_BE_SENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REQUEST_WILL_BE_SENT = 'Network.requestWillBeSent'\n</code></pre> <p>Fired when page is about to send HTTP request.</p> PARAMETER DESCRIPTION <code>requestId</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>loaderId</code> <p>Loader identifier. Empty string if the request is fetched from worker.</p> <p> TYPE: <code>LoaderId</code> </p> <code>documentURL</code> <p>URL of the document this request is loaded for.</p> <p> TYPE: <code>str</code> </p> <code>request</code> <p>Request data.</p> <p> TYPE: <code>Request</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p> <code>wallTime</code> <p>Timestamp.</p> <p> TYPE: <code>TimeSinceEpoch</code> </p> <code>initiator</code> <p>Request initiator.</p> <p> TYPE: <code>Initiator</code> </p> <code>redirectHasExtraInfo</code> <p>In the case that redirectResponse is populated, this flag indicates whether requestWillBeSentExtraInfo and responseReceivedExtraInfo events will be or were emitted for the request which was just redirected.</p> <p> TYPE: <code>bool</code> </p> <code>redirectResponse</code> <p>Redirect response data.</p> <p> TYPE: <code>Response</code> </p> <code>type</code> <p>Type of this resource.</p> <p> TYPE: <code>ResourceType</code> </p> <code>frameId</code> <p>Frame identifier.</p> <p> TYPE: <code>FrameId</code> </p> <code>hasUserGesture</code> <p>Whether the request is initiated by a user gesture. Defaults to false.</p> <p> TYPE: <code>bool</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.RESPONSE_RECEIVED","title":"RESPONSE_RECEIVED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESPONSE_RECEIVED = 'Network.responseReceived'\n</code></pre> <p>Fired when HTTP response is available.</p> PARAMETER DESCRIPTION <code>requestId</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>loaderId</code> <p>Loader identifier. Empty string if the request is fetched from worker.</p> <p> TYPE: <code>LoaderId</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p> <code>type</code> <p>Resource type.</p> <p> TYPE: <code>ResourceType</code> </p> <code>response</code> <p>Response data.</p> <p> TYPE: <code>Response</code> </p> <code>hasExtraInfo</code> <p>Indicates whether requestWillBeSentExtraInfo and responseReceivedExtraInfo events will be or were emitted for this request.</p> <p> TYPE: <code>bool</code> </p> <code>frameId</code> <p>Frame identifier.</p> <p> TYPE: <code>FrameId</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.WEBSOCKET_CLOSED","title":"WEBSOCKET_CLOSED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEBSOCKET_CLOSED = 'Network.webSocketClosed'\n</code></pre> <p>Fired when WebSocket is closed.</p> PARAMETER DESCRIPTION <code>requestId</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.WEBSOCKET_CREATED","title":"WEBSOCKET_CREATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEBSOCKET_CREATED = 'Network.webSocketCreated'\n</code></pre> <p>Fired upon WebSocket creation.</p> PARAMETER DESCRIPTION <code>requestId</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>url</code> <p>WebSocket request URL.</p> <p> TYPE: <code>str</code> </p> <code>initiator</code> <p>Request initiator.</p> <p> TYPE: <code>Initiator</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.WEBSOCKET_FRAME_ERROR","title":"WEBSOCKET_FRAME_ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEBSOCKET_FRAME_ERROR = 'Network.webSocketFrameError'\n</code></pre> <p>Fired when WebSocket message error occurs.</p> PARAMETER DESCRIPTION <code>requestId</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p> <code>errorMessage</code> <p>WebSocket error message.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.WEBSOCKET_FRAME_RECEIVED","title":"WEBSOCKET_FRAME_RECEIVED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEBSOCKET_FRAME_RECEIVED = 'Network.webSocketFrameReceived'\n</code></pre> <p>Fired when WebSocket message is received.</p> PARAMETER DESCRIPTION <code>requestId</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p> <code>response</code> <p>WebSocket response data.</p> <p> TYPE: <code>WebSocketFrame</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.WEBSOCKET_FRAME_SENT","title":"WEBSOCKET_FRAME_SENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEBSOCKET_FRAME_SENT = 'Network.webSocketFrameSent'\n</code></pre> <p>Fired when WebSocket message is sent.</p> PARAMETER DESCRIPTION <code>requestId</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p> <code>response</code> <p>WebSocket response data.</p> <p> TYPE: <code>WebSocketFrame</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.WEBSOCKET_HANDSHAKE_RESPONSE_RECEIVED","title":"WEBSOCKET_HANDSHAKE_RESPONSE_RECEIVED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEBSOCKET_HANDSHAKE_RESPONSE_RECEIVED = 'Network.webSocketHandshakeResponseReceived'\n</code></pre> <p>Fired when WebSocket handshake response becomes available.</p> PARAMETER DESCRIPTION <code>requestId</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p> <code>response</code> <p>WebSocket response data.</p> <p> TYPE: <code>WebSocketResponse</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.WEBSOCKET_WILL_SEND_HANDSHAKE_REQUEST","title":"WEBSOCKET_WILL_SEND_HANDSHAKE_REQUEST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEBSOCKET_WILL_SEND_HANDSHAKE_REQUEST = 'Network.webSocketWillSendHandshakeRequest'\n</code></pre> <p>Fired when WebSocket is about to initiate handshake.</p> PARAMETER DESCRIPTION <code>requestId</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p> <code>wallTime</code> <p>UTC Timestamp.</p> <p> TYPE: <code>TimeSinceEpoch</code> </p> <code>request</code> <p>WebSocket request data.</p> <p> TYPE: <code>WebSocketRequest</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.WEBTRANSPORT_CLOSED","title":"WEBTRANSPORT_CLOSED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEBTRANSPORT_CLOSED = 'Network.webTransportClosed'\n</code></pre> <p>Fired when WebTransport is disposed.</p> PARAMETER DESCRIPTION <code>transportId</code> <p>WebTransport identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.WEBTRANSPORT_CONNECTION_ESTABLISHED","title":"WEBTRANSPORT_CONNECTION_ESTABLISHED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEBTRANSPORT_CONNECTION_ESTABLISHED = 'Network.webTransportConnectionEstablished'\n</code></pre> <p>Fired when WebTransport handshake is finished.</p> PARAMETER DESCRIPTION <code>transportId</code> <p>WebTransport identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.WEBTRANSPORT_CREATED","title":"WEBTRANSPORT_CREATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEBTRANSPORT_CREATED = 'Network.webTransportCreated'\n</code></pre> <p>Fired upon WebTransport creation.</p> PARAMETER DESCRIPTION <code>transportId</code> <p>WebTransport identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>url</code> <p>WebTransport request URL.</p> <p> TYPE: <code>str</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p> <code>initiator</code> <p>Request initiator.</p> <p> TYPE: <code>Initiator</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.DIRECT_TCP_SOCKET_ABORTED","title":"DIRECT_TCP_SOCKET_ABORTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIRECT_TCP_SOCKET_ABORTED = 'Network.directTCPSocketAborted'\n</code></pre> <p>Fired when direct_socket.TCPSocket is aborted.</p> PARAMETER DESCRIPTION <code>identifier</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>errorMessage</code> <p>Error message.</p> <p> TYPE: <code>str</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.DIRECT_TCP_SOCKET_CHUNK_RECEIVED","title":"DIRECT_TCP_SOCKET_CHUNK_RECEIVED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIRECT_TCP_SOCKET_CHUNK_RECEIVED = 'Network.directTCPSocketChunkReceived'\n</code></pre> <p>Fired when data is received from tcp direct socket stream.</p> PARAMETER DESCRIPTION <code>identifier</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>data</code> <p>Data received.</p> <p> TYPE: <code>str</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.DIRECT_TCP_SOCKET_CHUNK_SENT","title":"DIRECT_TCP_SOCKET_CHUNK_SENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIRECT_TCP_SOCKET_CHUNK_SENT = 'Network.directTCPSocketChunkSent'\n</code></pre> <p>Fired when data is sent to tcp direct socket stream.</p> PARAMETER DESCRIPTION <code>identifier</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>data</code> <p>Data sent.</p> <p> TYPE: <code>str</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.DIRECT_TCP_SOCKET_CLOSED","title":"DIRECT_TCP_SOCKET_CLOSED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIRECT_TCP_SOCKET_CLOSED = 'Network.directTCPSocketClosed'\n</code></pre> <p>Fired when direct_socket.TCPSocket is closed.</p> PARAMETER DESCRIPTION <code>identifier</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.DIRECT_TCP_SOCKET_CREATED","title":"DIRECT_TCP_SOCKET_CREATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIRECT_TCP_SOCKET_CREATED = 'Network.directTCPSocketCreated'\n</code></pre> <p>Fired upon direct_socket.TCPSocket creation.</p> PARAMETER DESCRIPTION <code>identifier</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>remoteAddr</code> <p>Remote address.</p> <p> TYPE: <code>str</code> </p> <code>remotePort</code> <p>Remote port. Unsigned int 16.</p> <p> TYPE: <code>int</code> </p> <code>options</code> <p>Socket options.</p> <p> TYPE: <code>DirectTCPSocketOptions</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p> <code>initiator</code> <p>Request initiator.</p> <p> TYPE: <code>Initiator</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.DIRECT_TCP_SOCKET_OPENED","title":"DIRECT_TCP_SOCKET_OPENED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIRECT_TCP_SOCKET_OPENED = 'Network.directTCPSocketOpened'\n</code></pre> <p>Fired when direct_socket.TCPSocket connection is opened.</p> PARAMETER DESCRIPTION <code>identifier</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>remoteAddr</code> <p>Remote address.</p> <p> TYPE: <code>str</code> </p> <code>remotePort</code> <p>Remote port. Expected to be unsigned integer.</p> <p> TYPE: <code>int</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p> <code>localAddr</code> <p>Local address.</p> <p> TYPE: <code>str</code> </p> <code>localPort</code> <p>Local port. Expected to be unsigned integer.</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.DIRECT_UDP_SOCKET_ABORTED","title":"DIRECT_UDP_SOCKET_ABORTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIRECT_UDP_SOCKET_ABORTED = 'Network.directUDPSocketAborted'\n</code></pre> <p>Fired when direct_socket.UDPSocket is aborted.</p> PARAMETER DESCRIPTION <code>identifier</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>errorMessage</code> <p>Error message.</p> <p> TYPE: <code>str</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.DIRECT_UDP_SOCKET_CHUNK_RECEIVED","title":"DIRECT_UDP_SOCKET_CHUNK_RECEIVED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIRECT_UDP_SOCKET_CHUNK_RECEIVED = 'Network.directUDPSocketChunkReceived'\n</code></pre> <p>Fired when message is received from udp direct socket stream.</p> PARAMETER DESCRIPTION <code>identifier</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>message</code> <p>Message data.</p> <p> TYPE: <code>DirectUDPMessage</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.DIRECT_UDP_SOCKET_CHUNK_SENT","title":"DIRECT_UDP_SOCKET_CHUNK_SENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIRECT_UDP_SOCKET_CHUNK_SENT = 'Network.directUDPSocketChunkSent'\n</code></pre> <p>Fired when message is sent to udp direct socket stream.</p> PARAMETER DESCRIPTION <code>identifier</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>message</code> <p>Message data.</p> <p> TYPE: <code>DirectUDPMessage</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.DIRECT_UDP_SOCKET_CLOSED","title":"DIRECT_UDP_SOCKET_CLOSED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIRECT_UDP_SOCKET_CLOSED = 'Network.directUDPSocketClosed'\n</code></pre> <p>Fired when direct_socket.UDPSocket is closed.</p> PARAMETER DESCRIPTION <code>identifier</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.DIRECT_UDP_SOCKET_CREATED","title":"DIRECT_UDP_SOCKET_CREATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIRECT_UDP_SOCKET_CREATED = 'Network.directUDPSocketCreated'\n</code></pre> <p>Fired upon direct_socket.UDPSocket creation.</p> PARAMETER DESCRIPTION <code>identifier</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>options</code> <p>Socket options.</p> <p> TYPE: <code>DirectUDPSocketOptions</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p> <code>initiator</code> <p>Request initiator.</p> <p> TYPE: <code>Initiator</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.DIRECT_UDP_SOCKET_OPENED","title":"DIRECT_UDP_SOCKET_OPENED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIRECT_UDP_SOCKET_OPENED = 'Network.directUDPSocketOpened'\n</code></pre> <p>Fired when direct_socket.UDPSocket connection is opened.</p> PARAMETER DESCRIPTION <code>identifier</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>localAddr</code> <p>Local address.</p> <p> TYPE: <code>str</code> </p> <code>localPort</code> <p>Local port. Expected to be unsigned integer.</p> <p> TYPE: <code>int</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p> <code>remoteAddr</code> <p>Remote address.</p> <p> TYPE: <code>str</code> </p> <code>remotePort</code> <p>Remote port. Expected to be unsigned integer.</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.POLICY_UPDATED","title":"POLICY_UPDATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POLICY_UPDATED = 'Network.policyUpdated'\n</code></pre> <p>Fired once security policy has been updated.</p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.REPORTING_API_ENDPOINTS_CHANGED_FOR_ORIGIN","title":"REPORTING_API_ENDPOINTS_CHANGED_FOR_ORIGIN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPORTING_API_ENDPOINTS_CHANGED_FOR_ORIGIN = 'Network.reportingApiEndpointsChangedForOrigin'\n</code></pre> <p>Fired when Reporting API endpoints change for an origin.</p> PARAMETER DESCRIPTION <code>origin</code> <p>Origin of the document(s) which configured the endpoints.</p> <p> TYPE: <code>str</code> </p> <code>endpoints</code> <p>The endpoints configured for the origin.</p> <p> TYPE: <code>array[ReportingApiEndpoint]</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.REPORTING_API_REPORT_ADDED","title":"REPORTING_API_REPORT_ADDED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPORTING_API_REPORT_ADDED = 'Network.reportingApiReportAdded'\n</code></pre> <p>Is sent whenever a new report is added. And after 'enableReportingApi' for all existing reports.</p> PARAMETER DESCRIPTION <code>report</code> <p>The report that was added.</p> <p> TYPE: <code>ReportingApiReport</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.REPORTING_API_REPORT_UPDATED","title":"REPORTING_API_REPORT_UPDATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPORTING_API_REPORT_UPDATED = 'Network.reportingApiReportUpdated'\n</code></pre> <p>Fired when a report is updated.</p> PARAMETER DESCRIPTION <code>report</code> <p>The report that was updated.</p> <p> TYPE: <code>ReportingApiReport</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.REQUEST_WILL_BE_SENT_EXTRA_INFO","title":"REQUEST_WILL_BE_SENT_EXTRA_INFO  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REQUEST_WILL_BE_SENT_EXTRA_INFO = 'Network.requestWillBeSentExtraInfo'\n</code></pre> <p>Fired when additional information about a requestWillBeSent event is available from the network stack. Not every requestWillBeSent event will have an additional requestWillBeSentExtraInfo fired for it, and there is no guarantee whether requestWillBeSent or requestWillBeSentExtraInfo will be fired first for the same request.</p> PARAMETER DESCRIPTION <code>requestId</code> <p>Request identifier. Used to match this information to an existing requestWillBeSent event.</p> <p> TYPE: <code>RequestId</code> </p> <code>associatedCookies</code> <p>A list of cookies potentially associated to the requested URL. This includes both cookies sent with the request and the ones not sent; the latter are distinguished by having blockedReasons field set.</p> <p> TYPE: <code>array[AssociatedCookie]</code> </p> <code>headers</code> <p>Raw request headers as they will be sent over the wire.</p> <p> TYPE: <code>Headers</code> </p> <code>connectTiming</code> <p>Connection timing information for the request.</p> <p> TYPE: <code>ConnectTiming</code> </p> <code>clientSecurityState</code> <p>The client security state set for the request.</p> <p> TYPE: <code>ClientSecurityState</code> </p> <code>siteHasCookieInOtherPartition</code> <p>Whether the site has partitioned cookies stored in a partition different than the current one.</p> <p> TYPE: <code>bool</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.RESOURCE_CHANGED_PRIORITY","title":"RESOURCE_CHANGED_PRIORITY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESOURCE_CHANGED_PRIORITY = 'Network.resourceChangedPriority'\n</code></pre> <p>Fired when resource loading priority is changed.</p> PARAMETER DESCRIPTION <code>requestId</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>newPriority</code> <p>New priority.</p> <p> TYPE: <code>ResourcePriority</code> </p> <code>timestamp</code> <p>Timestamp.</p> <p> TYPE: <code>MonotonicTime</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.RESPONSE_RECEIVED_EARLY_HINTS","title":"RESPONSE_RECEIVED_EARLY_HINTS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESPONSE_RECEIVED_EARLY_HINTS = 'Network.responseReceivedEarlyHints'\n</code></pre> <p>Fired when 103 Early Hints headers is received in addition to the common response. Not every responseReceived event will have an responseReceivedEarlyHints fired. Only one responseReceivedEarlyHints may be fired for eached responseReceived event.</p> PARAMETER DESCRIPTION <code>requestId</code> <p>Request identifier. Used to match this information to another responseReceived event.</p> <p> TYPE: <code>RequestId</code> </p> <code>headers</code> <p>Raw response headers as they were received over the wire. Duplicate headers in the response are represented as a single key with their values concatentated using \\n as the separator. See also headersText that contains verbatim text for HTTP/1.*.</p> <p> TYPE: <code>Headers</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.RESPONSE_RECEIVED_EXTRA_INFO","title":"RESPONSE_RECEIVED_EXTRA_INFO  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESPONSE_RECEIVED_EXTRA_INFO = 'Network.responseReceivedExtraInfo'\n</code></pre> <p>Fired when additional information about a responseReceived event is available from the network stack. Not every responseReceived event will have an additional responseReceivedExtraInfo for it, and responseReceivedExtraInfo may be fired before or after responseReceived.</p> PARAMETER DESCRIPTION <code>requestId</code> <p>Request identifier. Used to match this information to another responseReceived event.</p> <p> TYPE: <code>RequestId</code> </p> <code>blockedCookies</code> <p>A list of cookies which were not stored from the response along with the corresponding reasons for blocking. The cookies here may not be valid due to syntax errors, which are represented by the invalid cookie line string instead of a proper cookie.</p> <p> TYPE: <code>array[BlockedSetCookieWithReason]</code> </p> <code>headers</code> <p>Raw response headers as they were received over the wire. Duplicate headers in the response are represented as a single key with their values concatentated using \\n as the separator. See also headersText that contains verbatim text for HTTP/1.*.</p> <p> TYPE: <code>Headers</code> </p> <code>resourceIPAddressSpace</code> <p>The IP address space of the resource. The address space can only be determined once the transport established the connection, so we can't send it in requestWillBeSentExtraInfo.</p> <p> TYPE: <code>IPAddressSpace</code> </p> <code>statusCode</code> <p>The status code of the response. This is useful in cases the request failed and no responseReceived event is triggered, which is the case for, e.g., CORS errors. This is also the correct status code for cached requests, where the status in responseReceived is a 200 and this will be 304.</p> <p> TYPE: <code>int</code> </p> <code>headersText</code> <p>Raw response header text as it was received over the wire. The raw text may not always be available, such as in the case of HTTP/2 or QUIC.</p> <p> TYPE: <code>str</code> </p> <code>cookiePartitionKey</code> <p>The cookie partition key that will be used to store partitioned cookies set in this response. Only sent when partitioned cookies are enabled.</p> <p> TYPE: <code>CookiePartitionKey</code> </p> <code>cookiePartitionKeyOpaque</code> <p>True if partitioned cookies are enabled, but the partition key is not serializable to string.</p> <p> TYPE: <code>bool</code> </p> <code>exemptedCookies</code> <p>A list of cookies which should have been blocked by 3PCD but are exempted and stored from the response with the corresponding reason.</p> <p> TYPE: <code>array[ExemptedSetCookieWithReason]</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.SIGNED_EXCHANGE_RECEIVED","title":"SIGNED_EXCHANGE_RECEIVED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SIGNED_EXCHANGE_RECEIVED = 'Network.signedExchangeReceived'\n</code></pre> <p>Fired when a signed exchange was received over the network.</p> PARAMETER DESCRIPTION <code>requestId</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>info</code> <p>Information about the signed exchange response.</p> <p> TYPE: <code>SignedExchangeInfo</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.SUBRESOURCE_WEB_BUNDLE_INNER_RESPONSE_ERROR","title":"SUBRESOURCE_WEB_BUNDLE_INNER_RESPONSE_ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SUBRESOURCE_WEB_BUNDLE_INNER_RESPONSE_ERROR = 'Network.subresourceWebBundleInnerResponseError'\n</code></pre> <p>Fired when request for resources within a .wbn file failed.</p> PARAMETER DESCRIPTION <code>innerRequestId</code> <p>Request identifier of the subresource request.</p> <p> TYPE: <code>RequestId</code> </p> <code>innerRequestURL</code> <p>URL of the subresource resource.</p> <p> TYPE: <code>str</code> </p> <code>errorMessage</code> <p>Error message.</p> <p> TYPE: <code>str</code> </p> <code>bundleRequestId</code> <p>Bundle request identifier. Used to match this information to another event. This made be absent in case when the instrumentation was enabled only after webbundle was parsed.</p> <p> TYPE: <code>RequestId</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.SUBRESOURCE_WEB_BUNDLE_INNER_RESPONSE_PARSED","title":"SUBRESOURCE_WEB_BUNDLE_INNER_RESPONSE_PARSED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SUBRESOURCE_WEB_BUNDLE_INNER_RESPONSE_PARSED = 'Network.subresourceWebBundleInnerResponseParsed'\n</code></pre> <p>Fired when handling requests for resources within a .wbn file. Note: this will only be fired for resources that are requested by the webpage.</p> PARAMETER DESCRIPTION <code>innerRequestId</code> <p>Request identifier of the subresource request.</p> <p> TYPE: <code>RequestId</code> </p> <code>innerRequestURL</code> <p>URL of the subresource resource.</p> <p> TYPE: <code>str</code> </p> <code>bundleRequestId</code> <p>Bundle request identifier. Used to match this information to another event. This made be absent in case when the instrumentation was enabled only after webbundle was parsed.</p> <p> TYPE: <code>RequestId</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.SUBRESOURCE_WEB_BUNDLE_METADATA_ERROR","title":"SUBRESOURCE_WEB_BUNDLE_METADATA_ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SUBRESOURCE_WEB_BUNDLE_METADATA_ERROR = 'Network.subresourceWebBundleMetadataError'\n</code></pre> <p>Fired once when parsing the .wbn file has failed.</p> PARAMETER DESCRIPTION <code>requestId</code> <p>Request identifier. Used to match this information to another event.</p> <p> TYPE: <code>RequestId</code> </p> <code>errorMessage</code> <p>Error message.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.SUBRESOURCE_WEB_BUNDLE_METADATA_RECEIVED","title":"SUBRESOURCE_WEB_BUNDLE_METADATA_RECEIVED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SUBRESOURCE_WEB_BUNDLE_METADATA_RECEIVED = 'Network.subresourceWebBundleMetadataReceived'\n</code></pre> <p>Fired once when parsing the .wbn file has succeeded. The event contains the information about the web bundle contents.</p> PARAMETER DESCRIPTION <code>requestId</code> <p>Request identifier. Used to match this information to another event.</p> <p> TYPE: <code>RequestId</code> </p> <code>urls</code> <p>A list of URLs of resources in the subresource Web Bundle.</p> <p> TYPE: <code>array[str]</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.network.events.NetworkEvent.TRUST_TOKEN_OPERATION_DONE","title":"TRUST_TOKEN_OPERATION_DONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TRUST_TOKEN_OPERATION_DONE = 'Network.trustTokenOperationDone'\n</code></pre> <p>Fired exactly once for each Trust Token operation. Depending on the type of the operation and whether the operation succeeded or failed, the event is fired before the corresponding request was sent or after the response was received.</p> PARAMETER DESCRIPTION <code>status</code> <p>Detailed success or error status of the operation. Allowed Values: Ok, InvalidArgument, MissingIssuerKeys, FailedPrecondition, ResourceExhausted, AlreadyExists, ResourceLimited, Unauthorized, BadResponse, InternalError, UnknownError, FulfilledLocally, SiteIssuerLimit</p> <p> TYPE: <code>str</code> </p> <code>type</code> <p>Type of Trust Token operation.</p> <p> TYPE: <code>TrustTokenOperationType</code> </p> <code>requestId</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>topLevelOrigin</code> <p>Top level origin. The context in which the operation was attempted.</p> <p> TYPE: <code>str</code> </p> <code>issuerOrigin</code> <p>Origin of the issuer in case of a \"Issuance\" or \"Redemption\" operation.</p> <p> TYPE: <code>str</code> </p> <code>issuedTokenCount</code> <p>The number of obtained Trust Tokens on a successful \"Issuance\" operation.</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/protocol/events/#dom-events","title":"DOM Events","text":""},{"location":"api/protocol/events/#pydoll.protocol.dom.events","title":"pydoll.protocol.dom.events","text":""},{"location":"api/protocol/events/#pydoll.protocol.dom.events.DomEvent","title":"DomEvent","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Events from the DOM domain of the Chrome DevTools Protocol.</p> <p>This enumeration contains the names of DOM-related events that can be received from the Chrome DevTools Protocol. These events provide information about changes to the DOM structure, attributes, and other DOM-related activities.</p>"},{"location":"api/protocol/events/#pydoll.protocol.dom.events.DomEvent.ATTRIBUTE_MODIFIED","title":"ATTRIBUTE_MODIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ATTRIBUTE_MODIFIED = 'DOM.attributeModified'\n</code></pre> <p>Fired when Element's attribute is modified.</p> PARAMETER DESCRIPTION <code>nodeId</code> <p>Id of the node that has changed.</p> <p> TYPE: <code>NodeId</code> </p> <code>name</code> <p>Attribute name.</p> <p> TYPE: <code>str</code> </p> <code>value</code> <p>Attribute value.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.dom.events.DomEvent.ATTRIBUTE_REMOVED","title":"ATTRIBUTE_REMOVED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ATTRIBUTE_REMOVED = 'DOM.attributeRemoved'\n</code></pre> <p>Fired when Element's attribute is removed.</p> PARAMETER DESCRIPTION <code>nodeId</code> <p>Id of the node that has changed.</p> <p> TYPE: <code>NodeId</code> </p> <code>name</code> <p>Attribute name.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.dom.events.DomEvent.CHARACTER_DATA_MODIFIED","title":"CHARACTER_DATA_MODIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHARACTER_DATA_MODIFIED = 'DOM.characterDataModified'\n</code></pre> <p>Mirrors DOMCharacterDataModified event.</p> PARAMETER DESCRIPTION <code>nodeId</code> <p>Id of the node that has changed.</p> <p> TYPE: <code>NodeId</code> </p> <code>characterData</code> <p>New text value.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.dom.events.DomEvent.CHILD_NODE_COUNT_UPDATED","title":"CHILD_NODE_COUNT_UPDATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHILD_NODE_COUNT_UPDATED = 'DOM.childNodeCountUpdated'\n</code></pre> <p>Fired when Container's child node count has changed.</p> PARAMETER DESCRIPTION <code>nodeId</code> <p>Id of the node that has changed.</p> <p> TYPE: <code>NodeId</code> </p> <code>childNodeCount</code> <p>New node count.</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.dom.events.DomEvent.CHILD_NODE_INSERTED","title":"CHILD_NODE_INSERTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHILD_NODE_INSERTED = 'DOM.childNodeInserted'\n</code></pre> <p>Mirrors DOMNodeInserted event.</p> PARAMETER DESCRIPTION <code>parentNodeId</code> <p>Id of the node that has changed.</p> <p> TYPE: <code>NodeId</code> </p> <code>previousNodeId</code> <p>Id of the previous sibling.</p> <p> TYPE: <code>NodeId</code> </p> <code>node</code> <p>Inserted node data.</p> <p> TYPE: <code>Node</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.dom.events.DomEvent.CHILD_NODE_REMOVED","title":"CHILD_NODE_REMOVED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHILD_NODE_REMOVED = 'DOM.childNodeRemoved'\n</code></pre> <p>Mirrors DOMNodeRemoved event.</p> PARAMETER DESCRIPTION <code>parentNodeId</code> <p>Parent id.</p> <p> TYPE: <code>NodeId</code> </p> <code>nodeId</code> <p>Id of the node that has been removed.</p> <p> TYPE: <code>NodeId</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.dom.events.DomEvent.DOCUMENT_UPDATED","title":"DOCUMENT_UPDATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DOCUMENT_UPDATED = 'DOM.documentUpdated'\n</code></pre> <p>Fired when Document has been totally updated. Node ids are no longer valid.</p>"},{"location":"api/protocol/events/#pydoll.protocol.dom.events.DomEvent.SET_CHILD_NODES","title":"SET_CHILD_NODES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SET_CHILD_NODES = 'DOM.setChildNodes'\n</code></pre> <p>Fired when backend wants to provide client with the missing DOM structure. This happens upon most of the calls requesting node ids.</p> PARAMETER DESCRIPTION <code>parentId</code> <p>Parent node id to populate with children.</p> <p> TYPE: <code>NodeId</code> </p> <code>nodes</code> <p>Child nodes array.</p> <p> TYPE: <code>array[Node]</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.dom.events.DomEvent.DISTRIBUTED_NODES_UPDATED","title":"DISTRIBUTED_NODES_UPDATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISTRIBUTED_NODES_UPDATED = 'DOM.distributedNodesUpdated'\n</code></pre> <p>Called when distribution is changed.</p> PARAMETER DESCRIPTION <code>insertionPointId</code> <p>Insertion point where distributed nodes were updated.</p> <p> TYPE: <code>NodeId</code> </p> <code>distributedNodes</code> <p>Distributed nodes for given insertion point.</p> <p> TYPE: <code>array[BackendNode]</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.dom.events.DomEvent.INLINE_STYLE_INVALIDATED","title":"INLINE_STYLE_INVALIDATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INLINE_STYLE_INVALIDATED = 'DOM.inlineStyleInvalidated'\n</code></pre> <p>Fired when Element's inline style is modified via a CSS property modification.</p> PARAMETER DESCRIPTION <code>nodeIds</code> <p>Ids of the nodes for which the inline styles have been invalidated.</p> <p> TYPE: <code>array[NodeId]</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.dom.events.DomEvent.PSEUDO_ELEMENT_ADDED","title":"PSEUDO_ELEMENT_ADDED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PSEUDO_ELEMENT_ADDED = 'DOM.pseudoElementAdded'\n</code></pre> <p>Called when a pseudo element is added to an element.</p> PARAMETER DESCRIPTION <code>parentId</code> <p>Pseudo element's parent element id.</p> <p> TYPE: <code>NodeId</code> </p> <code>pseudoElement</code> <p>The added pseudo element.</p> <p> TYPE: <code>Node</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.dom.events.DomEvent.PSEUDO_ELEMENT_REMOVED","title":"PSEUDO_ELEMENT_REMOVED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PSEUDO_ELEMENT_REMOVED = 'DOM.pseudoElementRemoved'\n</code></pre> <p>Called when a pseudo element is removed from an element.</p> PARAMETER DESCRIPTION <code>parentId</code> <p>Pseudo element's parent element id.</p> <p> TYPE: <code>NodeId</code> </p> <code>pseudoElementId</code> <p>The removed pseudo element id.</p> <p> TYPE: <code>NodeId</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.dom.events.DomEvent.SCROLLABLE_FLAG_UPDATED","title":"SCROLLABLE_FLAG_UPDATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SCROLLABLE_FLAG_UPDATED = 'DOM.scrollableFlagUpdated'\n</code></pre> <p>Fired when a node's scrollability state changes.</p> PARAMETER DESCRIPTION <code>nodeId</code> <p>The id of the node.</p> <p> TYPE: <code>NodeId</code> </p> <code>isScrollable</code> <p>If the node is scrollable.</p> <p> TYPE: <code>bool</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.dom.events.DomEvent.SHADOW_ROOT_POPPED","title":"SHADOW_ROOT_POPPED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SHADOW_ROOT_POPPED = 'DOM.shadowRootPopped'\n</code></pre> <p>Called when shadow root is popped from the element.</p> PARAMETER DESCRIPTION <code>hostId</code> <p>Host element id.</p> <p> TYPE: <code>NodeId</code> </p> <code>rootId</code> <p>Shadow root id.</p> <p> TYPE: <code>NodeId</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.dom.events.DomEvent.SHADOW_ROOT_PUSHED","title":"SHADOW_ROOT_PUSHED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SHADOW_ROOT_PUSHED = 'DOM.shadowRootPushed'\n</code></pre> <p>Called when shadow root is pushed into the element.</p> PARAMETER DESCRIPTION <code>hostId</code> <p>Host element id.</p> <p> TYPE: <code>NodeId</code> </p> <code>root</code> <p>Shadow root.</p> <p> TYPE: <code>Node</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.dom.events.DomEvent.TOP_LAYER_ELEMENTS_UPDATED","title":"TOP_LAYER_ELEMENTS_UPDATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TOP_LAYER_ELEMENTS_UPDATED = 'DOM.topLayerElementsUpdated'\n</code></pre> <p>Called when top layer elements are changed.</p>"},{"location":"api/protocol/events/#runtime-events","title":"Runtime Events","text":""},{"location":"api/protocol/events/#pydoll.protocol.runtime.events","title":"pydoll.protocol.runtime.events","text":""},{"location":"api/protocol/events/#pydoll.protocol.runtime.events.RuntimeEvent","title":"RuntimeEvent","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Events from the Runtime domain of the Chrome DevTools Protocol.</p> <p>This enumeration contains the names of Runtime-related events that can be received from the Chrome DevTools Protocol. These events provide information about JavaScript execution, console API calls, exceptions, and execution contexts.</p>"},{"location":"api/protocol/events/#pydoll.protocol.runtime.events.RuntimeEvent.CONSOLE_API_CALLED","title":"CONSOLE_API_CALLED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CONSOLE_API_CALLED = 'Runtime.consoleAPICalled'\n</code></pre> <p>Issued when console API was called.</p> PARAMETER DESCRIPTION <code>type</code> <p>Type of the call. Allowed Values: log, debug, info, error, warning, dir, dirxml, table, trace, clear, startGroup, startGroupCollapsed, endGroup, assert, profile, profileEnd, count, timeEnd</p> <p> TYPE: <code>str</code> </p> <code>args</code> <p>Call arguments.</p> <p> TYPE: <code>array[RemoteObject]</code> </p> <code>executionContextId</code> <p>Identifier of the context where the call was made.</p> <p> TYPE: <code>ExecutionContextId</code> </p> <code>timestamp</code> <p>Call timestamp.</p> <p> TYPE: <code>Timestamp</code> </p> <code>stackTrace</code> <p>Stack trace captured when the call was made. The async stack chain is automatically reported for the following call types: assert, error, trace, warning. For other types the async call chain can be retrieved using Debugger.getStackTrace and stackTrace.parentId field.</p> <p> TYPE: <code>StackTrace</code> </p> <code>context</code> <p>Console context descriptor for calls on non-default console context (not console.*): 'anonymous#unique-logger-id' for call on unnamed context, 'name#unique-logger-id' for call on named context.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.runtime.events.RuntimeEvent.EXCEPTION_REVOKED","title":"EXCEPTION_REVOKED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EXCEPTION_REVOKED = 'Runtime.exceptionRevoked'\n</code></pre> <p>Issued when unhandled exception was revoked.</p> PARAMETER DESCRIPTION <code>reason</code> <p>Reason describing why exception was revoked.</p> <p> TYPE: <code>str</code> </p> <code>exceptionId</code> <p>The id of revoked exception, as reported in exceptionThrown.</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.runtime.events.RuntimeEvent.EXCEPTION_THROWN","title":"EXCEPTION_THROWN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EXCEPTION_THROWN = 'Runtime.exceptionThrown'\n</code></pre> <p>Issued when exception was thrown and unhandled.</p> PARAMETER DESCRIPTION <code>timestamp</code> <p>Timestamp of the exception.</p> <p> TYPE: <code>Timestamp</code> </p> <code>exceptionDetails</code> <p>Details about the exception.</p> <p> TYPE: <code>ExceptionDetails</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.runtime.events.RuntimeEvent.EXECUTION_CONTEXT_CREATED","title":"EXECUTION_CONTEXT_CREATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EXECUTION_CONTEXT_CREATED = 'Runtime.executionContextCreated'\n</code></pre> <p>Issued when new execution context is created.</p> PARAMETER DESCRIPTION <code>context</code> <p>A newly created execution context.</p> <p> TYPE: <code>ExecutionContextDescription</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.runtime.events.RuntimeEvent.EXECUTION_CONTEXT_DESTROYED","title":"EXECUTION_CONTEXT_DESTROYED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EXECUTION_CONTEXT_DESTROYED = 'Runtime.executionContextDestroyed'\n</code></pre> <p>Issued when execution context is destroyed.</p> PARAMETER DESCRIPTION <code>executionContextId</code> <p>Id of the destroyed context.</p> <p> TYPE: <code>ExecutionContextId</code> </p> <code>executionContextUniqueId</code> <p>Unique Id of the destroyed context.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.runtime.events.RuntimeEvent.EXECUTION_CONTEXTS_CLEARED","title":"EXECUTION_CONTEXTS_CLEARED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EXECUTION_CONTEXTS_CLEARED = 'Runtime.executionContextsCleared'\n</code></pre> <p>Issued when all executionContexts were cleared in browser.</p>"},{"location":"api/protocol/events/#pydoll.protocol.runtime.events.RuntimeEvent.INSPECT_REQUESTED","title":"INSPECT_REQUESTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INSPECT_REQUESTED = 'Runtime.inspectRequested'\n</code></pre> <p>Issued when object should be inspected (for example, as a result of inspect() command line API call).</p> PARAMETER DESCRIPTION <code>object</code> <p>Object to inspect.</p> <p> TYPE: <code>RemoteObject</code> </p> <code>hints</code> <p>Hints.</p> <p> TYPE: <code>object</code> </p> <code>executionContextId</code> <p>Identifier of the context where the call was made.</p> <p> TYPE: <code>ExecutionContextId</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.runtime.events.RuntimeEvent.BINDING_CALLED","title":"BINDING_CALLED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BINDING_CALLED = 'Runtime.bindingCalled'\n</code></pre> <p>Notification is issued every time when binding is called.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the binding.</p> <p> TYPE: <code>str</code> </p> <code>payload</code> <p>Payload of the binding.</p> <p> TYPE: <code>str</code> </p> <code>executionContextId</code> <p>Identifier of the context where the call was made.</p> <p> TYPE: <code>ExecutionContextId</code> </p>"},{"location":"api/protocol/events/#fetch-events","title":"Fetch Events","text":""},{"location":"api/protocol/events/#pydoll.protocol.fetch.events","title":"pydoll.protocol.fetch.events","text":""},{"location":"api/protocol/events/#pydoll.protocol.fetch.events.FetchEvent","title":"FetchEvent","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Events from the Fetch domain of the Chrome DevTools Protocol.</p> <p>This enumeration contains the names of Fetch-related events that can be received from the Chrome DevTools Protocol. These events provide information about network requests that can be intercepted, modified, or responded to by the client.</p>"},{"location":"api/protocol/events/#pydoll.protocol.fetch.events.FetchEvent.AUTH_REQUIRED","title":"AUTH_REQUIRED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AUTH_REQUIRED = 'Fetch.authRequired'\n</code></pre> <p>Issued when the domain is enabled with handleAuthRequests set to true. The request is paused until client responds with continueWithAuth.</p> PARAMETER DESCRIPTION <code>requestId</code> <p>Each request the page makes will have a unique id.</p> <p> TYPE: <code>RequestId</code> </p> <code>request</code> <p>The details of the request.</p> <p> TYPE: <code>Request</code> </p> <code>frameId</code> <p>The id of the frame that initiated the request.</p> <p> TYPE: <code>FrameId</code> </p> <code>resourceType</code> <p>How the requested resource will be used.</p> <p> TYPE: <code>ResourceType</code> </p> <code>authChallenge</code> <p>Details of the Authorization Challenge encountered. If this is set, client should respond with continueRequest that contains AuthChallengeResponse.</p> <p> TYPE: <code>AuthChallenge</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.fetch.events.FetchEvent.REQUEST_PAUSED","title":"REQUEST_PAUSED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REQUEST_PAUSED = 'Fetch.requestPaused'\n</code></pre> <p>Issued when the domain is enabled and the request URL matches the specified filter.</p> <p>The request is paused until the client responds with one of continueRequest, failRequest or fulfillRequest. The stage of the request can be determined by presence of responseErrorReason and responseStatusCode -- the request is at the response stage if either of these fields is present and in the request stage otherwise.</p> <p>Redirect responses and subsequent requests are reported similarly to regular responses and requests. Redirect responses may be distinguished by the value of responseStatusCode (which is one of 301, 302, 303, 307, 308) along with presence of the location header. Requests resulting from a redirect will have redirectedRequestId field set.</p> PARAMETER DESCRIPTION <code>requestId</code> <p>Each request the page makes will have a unique id.</p> <p> TYPE: <code>RequestId</code> </p> <code>request</code> <p>The details of the request.</p> <p> TYPE: <code>Request</code> </p> <code>frameId</code> <p>The id of the frame that initiated the request.</p> <p> TYPE: <code>FrameId</code> </p> <code>resourceType</code> <p>How the requested resource will be used.</p> <p> TYPE: <code>ResourceType</code> </p> <code>responseErrorReason</code> <p>Response error if intercepted at response stage.</p> <p> TYPE: <code>ErrorReason</code> </p> <code>responseStatusCode</code> <p>Response code if intercepted at response stage.</p> <p> TYPE: <code>int</code> </p> <code>responseStatusText</code> <p>Response status text if intercepted at response stage.</p> <p> TYPE: <code>str</code> </p> <code>responseHeaders</code> <p>Response headers if intercepted at the response stage.</p> <p> TYPE: <code>array[HeaderEntry]</code> </p> <code>networkId</code> <p>If the intercepted request had a corresponding Network.requestWillBeSent event fired for it, then this networkId will be the same as the requestId present in the requestWillBeSent event.</p> <p> TYPE: <code>RequestId</code> </p> <code>redirectedRequestId</code> <p>If the request is due to a redirect response from the server, the id of the request that has caused the redirect.</p> <p> TYPE: <code>RequestId</code> </p>"},{"location":"api/protocol/events/#browser-events","title":"Browser Events","text":""},{"location":"api/protocol/events/#pydoll.protocol.browser.events","title":"pydoll.protocol.browser.events","text":""},{"location":"api/protocol/events/#pydoll.protocol.browser.events.BrowserEvent","title":"BrowserEvent","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Events from the Browser domain of the Chrome DevTools Protocol.</p> <p>This enumeration contains the names of browser-related events that can be received from the Chrome DevTools Protocol. These events provide information about browser activities and state changes.</p>"},{"location":"api/protocol/events/#pydoll.protocol.browser.events.BrowserEvent.DOWNLOAD_PROGRESS","title":"DOWNLOAD_PROGRESS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DOWNLOAD_PROGRESS = 'Browser.downloadProgress'\n</code></pre> <p>Fired when download makes progress. The last call has |done| == true.</p> PARAMETER DESCRIPTION <code>guid</code> <p>Global unique identifier of the download.</p> <p> TYPE: <code>str</code> </p> <code>totalBytes</code> <p>Total expected bytes to download.</p> <p> TYPE: <code>int</code> </p> <code>receivedBytes</code> <p>Total bytes received.</p> <p> TYPE: <code>int</code> </p> <code>state</code> <p>Download status. Allowed values: 'inProgress', 'completed', 'canceled'</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.browser.events.BrowserEvent.DOWNLOAD_WILL_BEGIN","title":"DOWNLOAD_WILL_BEGIN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DOWNLOAD_WILL_BEGIN = 'Browser.downloadWillBegin'\n</code></pre> <p>Fired when page is about to start a download.</p> PARAMETER DESCRIPTION <code>frameId</code> <p>Id of the frame that caused the download to begin.</p> <p> TYPE: <code>str</code> </p> <code>guid</code> <p>Global unique identifier of the download.</p> <p> TYPE: <code>str</code> </p> <code>url</code> <p>URL of the resource being downloaded.</p> <p> TYPE: <code>str</code> </p> <code>suggestedFilename</code> <p>Suggested file name of the resource (the actual name of the file saved on disk may differ).</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/protocol/events/#target-events","title":"Target Events","text":""},{"location":"api/protocol/events/#pydoll.protocol.target.events","title":"pydoll.protocol.target.events","text":""},{"location":"api/protocol/events/#pydoll.protocol.target.events.TargetEvent","title":"TargetEvent","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Events from the Target domain of the Chrome DevTools Protocol.</p> <p>This enumeration contains the names of Target-related events that can be received from the Chrome DevTools Protocol. These events provide information about target creation, destruction, and communication between targets.</p>"},{"location":"api/protocol/events/#pydoll.protocol.target.events.TargetEvent.RECEIVED_MESSAGE_FROM_TARGET","title":"RECEIVED_MESSAGE_FROM_TARGET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RECEIVED_MESSAGE_FROM_TARGET = 'Target.receivedMessageFromTarget'\n</code></pre> <p>Notifies about a new protocol message received from the session (as reported in attachedToTarget event).</p> PARAMETER DESCRIPTION <code>sessionId</code> <p>Identifier of a session which sends a message.</p> <p> TYPE: <code>SessionID</code> </p> <code>message</code> <p>The message content.</p> <p> TYPE: <code>str</code> </p> <code>targetId</code> <p>Deprecated.</p> <p> TYPE: <code>TargetID</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.target.events.TargetEvent.TARGET_CRASHED","title":"TARGET_CRASHED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TARGET_CRASHED = 'Target.targetCrashed'\n</code></pre> <p>Issued when a target has crashed.</p> PARAMETER DESCRIPTION <code>targetId</code> <p>Identifier of the crashed target.</p> <p> TYPE: <code>TargetID</code> </p> <code>status</code> <p>Termination status type.</p> <p> TYPE: <code>str</code> </p> <code>errorCode</code> <p>Termination error code.</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.target.events.TargetEvent.TARGET_CREATED","title":"TARGET_CREATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TARGET_CREATED = 'Target.targetCreated'\n</code></pre> <p>Issued when a possible inspection target is created.</p> PARAMETER DESCRIPTION <code>targetInfo</code> <p>Information about the created target.</p> <p> TYPE: <code>TargetInfo</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.target.events.TargetEvent.TARGET_DESTROYED","title":"TARGET_DESTROYED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TARGET_DESTROYED = 'Target.targetDestroyed'\n</code></pre> <p>Issued when a target is destroyed.</p> PARAMETER DESCRIPTION <code>targetId</code> <p>Identifier of the destroyed target.</p> <p> TYPE: <code>TargetID</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.target.events.TargetEvent.TARGET_INFO_CHANGED","title":"TARGET_INFO_CHANGED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TARGET_INFO_CHANGED = 'Target.targetInfoChanged'\n</code></pre> <p>Issued when some information about a target has changed. This only happens between targetCreated and targetDestroyed.</p> PARAMETER DESCRIPTION <code>targetInfo</code> <p>Updated information about the target.</p> <p> TYPE: <code>TargetInfo</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.target.events.TargetEvent.ATTACHED_TO_TARGET","title":"ATTACHED_TO_TARGET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ATTACHED_TO_TARGET = 'Target.attachedToTarget'\n</code></pre> <p>Issued when attached to target because of auto-attach or attachToTarget command.</p> PARAMETER DESCRIPTION <code>sessionId</code> <p>Identifier assigned to the session used to send/receive messages.</p> <p> TYPE: <code>SessionID</code> </p> <code>targetInfo</code> <p>Information about the target.</p> <p> TYPE: <code>TargetInfo</code> </p> <code>waitingForDebugger</code> <p>Whether the target is waiting for debugger to attach.</p> <p> TYPE: <code>bool</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.target.events.TargetEvent.DETACHED_FROM_TARGET","title":"DETACHED_FROM_TARGET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DETACHED_FROM_TARGET = 'Target.detachedFromTarget'\n</code></pre> <p>Issued when detached from target for any reason (including detachFromTarget command). Can be issued multiple times per target if multiple sessions have been attached to it.</p> PARAMETER DESCRIPTION <code>sessionId</code> <p>Detached session identifier.</p> <p> TYPE: <code>SessionID</code> </p> <code>targetId</code> <p>Deprecated.</p> <p> TYPE: <code>TargetID</code> </p>"},{"location":"api/protocol/events/#storage-events","title":"Storage Events","text":""},{"location":"api/protocol/events/#pydoll.protocol.storage.events","title":"pydoll.protocol.storage.events","text":""},{"location":"api/protocol/events/#pydoll.protocol.storage.events.StorageEvent","title":"StorageEvent","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Events from the Storage domain of the Chrome DevTools Protocol.</p> <p>This enumeration contains the names of Storage-related events that can be received from the Chrome DevTools Protocol. These events provide information about changes to various browser storage mechanisms including Cache Storage, IndexedDB, Interest Groups, Shared Storage, and Storage Buckets.</p>"},{"location":"api/protocol/events/#pydoll.protocol.storage.events.StorageEvent.CACHE_STORAGE_CONTENT_UPDATED","title":"CACHE_STORAGE_CONTENT_UPDATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CACHE_STORAGE_CONTENT_UPDATED = 'Storage.cacheStorageContentUpdated'\n</code></pre> <p>A cache's contents have been modified.</p> PARAMETER DESCRIPTION <code>origin</code> <p>Origin to update.</p> <p> TYPE: <code>str</code> </p> <code>storageKey</code> <p>Storage key to update.</p> <p> TYPE: <code>str</code> </p> <code>bucketId</code> <p>Storage bucket to update.</p> <p> TYPE: <code>str</code> </p> <code>cacheName</code> <p>Name of cache in origin.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.storage.events.StorageEvent.CACHE_STORAGE_LIST_UPDATED","title":"CACHE_STORAGE_LIST_UPDATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CACHE_STORAGE_LIST_UPDATED = 'Storage.cacheStorageListUpdated'\n</code></pre> <p>A cache has been added/deleted.</p> PARAMETER DESCRIPTION <code>origin</code> <p>Origin to update.</p> <p> TYPE: <code>str</code> </p> <code>storageKey</code> <p>Storage key to update.</p> <p> TYPE: <code>str</code> </p> <code>bucketId</code> <p>Storage bucket to update.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.storage.events.StorageEvent.INDEXED_DB_CONTENT_UPDATED","title":"INDEXED_DB_CONTENT_UPDATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INDEXED_DB_CONTENT_UPDATED = 'Storage.indexedDBContentUpdated'\n</code></pre> <p>The origin's IndexedDB object store has been modified.</p> PARAMETER DESCRIPTION <code>origin</code> <p>Origin to update.</p> <p> TYPE: <code>str</code> </p> <code>storageKey</code> <p>Storage key to update.</p> <p> TYPE: <code>str</code> </p> <code>bucketId</code> <p>Storage bucket to update.</p> <p> TYPE: <code>str</code> </p> <code>databaseName</code> <p>Database to update.</p> <p> TYPE: <code>str</code> </p> <code>objectStoreName</code> <p>ObjectStore to update.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.storage.events.StorageEvent.INDEXED_DB_LIST_UPDATED","title":"INDEXED_DB_LIST_UPDATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INDEXED_DB_LIST_UPDATED = 'Storage.indexedDBListUpdated'\n</code></pre> <p>The origin's IndexedDB database list has been modified.</p> PARAMETER DESCRIPTION <code>origin</code> <p>Origin to update.</p> <p> TYPE: <code>str</code> </p> <code>storageKey</code> <p>Storage key to update.</p> <p> TYPE: <code>str</code> </p> <code>bucketId</code> <p>Storage bucket to update.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.storage.events.StorageEvent.INTEREST_GROUP_ACCESSED","title":"INTEREST_GROUP_ACCESSED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INTEREST_GROUP_ACCESSED = 'Storage.interestGroupAccessed'\n</code></pre> <p>One of the interest groups was accessed. Note that these events are global to all targets sharing an interest group store.</p> PARAMETER DESCRIPTION <code>accessTime</code> <p>Time of the access.</p> <p> TYPE: <code>TimeSinceEpoch</code> </p> <code>type</code> <p>Type of access.</p> <p> TYPE: <code>InterestGroupAccessType</code> </p> <code>ownerOrigin</code> <p>Owner origin.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name of the interest group.</p> <p> TYPE: <code>str</code> </p> <code>componentSellerOrigin</code> <p>For topLevelBid/topLevelAdditionalBid, and when appropriate, win and additionalBidWin.</p> <p> TYPE: <code>str</code> </p> <code>bid</code> <p>For bid or somethingBid event, if done locally and not on a server.</p> <p> TYPE: <code>number</code> </p> <code>bidCurrency</code> <p>Currency of the bid.</p> <p> TYPE: <code>str</code> </p> <code>uniqueAuctionId</code> <p>For non-global events --- links to interestGroupAuctionEvent.</p> <p> TYPE: <code>InterestGroupAuctionId</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.storage.events.StorageEvent.INTEREST_GROUP_AUCTION_EVENT_OCCURRED","title":"INTEREST_GROUP_AUCTION_EVENT_OCCURRED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INTEREST_GROUP_AUCTION_EVENT_OCCURRED = 'Storage.interestGroupAuctionEventOccurred'\n</code></pre> <p>An auction involving interest groups is taking place. These events are target-specific.</p> PARAMETER DESCRIPTION <code>eventTime</code> <p>Time of the event.</p> <p> TYPE: <code>TimeSinceEpoch</code> </p> <code>type</code> <p>Type of auction event.</p> <p> TYPE: <code>InterestGroupAuctionEventType</code> </p> <code>uniqueAuctionId</code> <p>Unique identifier for the auction.</p> <p> TYPE: <code>InterestGroupAuctionId</code> </p> <code>parentAuctionId</code> <p>Set for child auctions.</p> <p> TYPE: <code>InterestGroupAuctionId</code> </p> <code>auctionConfig</code> <p>Set for started and configResolved.</p> <p> TYPE: <code>object</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.storage.events.StorageEvent.INTEREST_GROUP_AUCTION_NETWORK_REQUEST_CREATED","title":"INTEREST_GROUP_AUCTION_NETWORK_REQUEST_CREATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INTEREST_GROUP_AUCTION_NETWORK_REQUEST_CREATED = 'Storage.interestGroupAuctionNetworkRequestCreated'\n</code></pre> <p>Specifies which auctions a particular network fetch may be related to, and in what role. Note that it is not ordered with respect to Network.requestWillBeSent (but will happen before loadingFinished loadingFailed).</p> PARAMETER DESCRIPTION <code>type</code> <p>Type of fetch.</p> <p> TYPE: <code>InterestGroupAuctionFetchType</code> </p> <code>requestId</code> <p>Request identifier.</p> <p> TYPE: <code>RequestId</code> </p> <code>auctions</code> <p>This is the set of the auctions using the worklet that issued this request. In the case of trusted signals, it's possible that only some of them actually care about the keys being queried.</p> <p> TYPE: <code>array[InterestGroupAuctionId]</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.storage.events.StorageEvent.SHARED_STORAGE_ACCESSED","title":"SHARED_STORAGE_ACCESSED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SHARED_STORAGE_ACCESSED = 'Storage.sharedStorageAccessed'\n</code></pre> <p>Shared storage was accessed by the associated page. The following parameters are included in all events.</p> PARAMETER DESCRIPTION <code>accessTime</code> <p>Time of the access.</p> <p> TYPE: <code>TimeSinceEpoch</code> </p> <code>scope</code> <p>Enum value indicating the access scope.</p> <p> TYPE: <code>SharedStorageAccessScope</code> </p> <code>method</code> <p>Enum value indicating the Shared Storage API method invoked.</p> <p> TYPE: <code>SharedStorageAccessMethod</code> </p> <code>mainFrameId</code> <p>DevTools Frame Token for the primary frame tree's root.</p> <p> TYPE: <code>FrameId</code> </p> <code>ownerOrigin</code> <p>Serialization of the origin owning the Shared Storage data.</p> <p> TYPE: <code>str</code> </p> <code>ownerSite</code> <p>Serialization of the site owning the Shared Storage data.</p> <p> TYPE: <code>str</code> </p> <code>params</code> <p>The sub-parameters wrapped by params are all optional and their presence/absence depends on type.</p> <p> TYPE: <code>SharedStorageAccessParams</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.storage.events.StorageEvent.SHARED_STORAGE_WORKLET_OPERATION_EXECUTION_FINISHED","title":"SHARED_STORAGE_WORKLET_OPERATION_EXECUTION_FINISHED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SHARED_STORAGE_WORKLET_OPERATION_EXECUTION_FINISHED = 'Storage.sharedStorageWorkletOperationExecutionFinished'\n</code></pre> <p>A shared storage run or selectURL operation finished its execution. The following parameters are included in all events.</p> PARAMETER DESCRIPTION <code>finishedTime</code> <p>Time that the operation finished.</p> <p> TYPE: <code>TimeSinceEpoch</code> </p> <code>executionTime</code> <p>Time, in microseconds, from start of shared storage JS API call until end of operation execution in the worklet.</p> <p> TYPE: <code>int</code> </p> <code>method</code> <p>Enum value indicating the Shared Storage API method invoked.</p> <p> TYPE: <code>SharedStorageAccessMethod</code> </p> <code>operationId</code> <p>ID of the operation call.</p> <p> TYPE: <code>str</code> </p> <code>workletTargetId</code> <p>Hex representation of the DevTools token used as the TargetID for the associated shared storage worklet.</p> <p> TYPE: <code>TargetID</code> </p> <code>mainFrameId</code> <p>DevTools Frame Token for the primary frame tree's root.</p> <p> TYPE: <code>FrameId</code> </p> <code>ownerOrigin</code> <p>Serialization of the origin owning the Shared Storage data.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.storage.events.StorageEvent.STORAGE_BUCKET_CREATED_OR_UPDATED","title":"STORAGE_BUCKET_CREATED_OR_UPDATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STORAGE_BUCKET_CREATED_OR_UPDATED = 'Storage.storageBucketCreatedOrUpdated'\n</code></pre> <p>Fired when a storage bucket is created or updated.</p> PARAMETER DESCRIPTION <code>bucketInfo</code> <p>Information about the storage bucket.</p> <p> TYPE: <code>StorageBucketInfo</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.storage.events.StorageEvent.STORAGE_BUCKET_DELETED","title":"STORAGE_BUCKET_DELETED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STORAGE_BUCKET_DELETED = 'Storage.storageBucketDeleted'\n</code></pre> <p>Fired when a storage bucket is deleted.</p> PARAMETER DESCRIPTION <code>bucketId</code> <p>ID of the deleted storage bucket.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.storage.events.StorageEvent.ATTRIBUTION_REPORTING_REPORT_SENT","title":"ATTRIBUTION_REPORTING_REPORT_SENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ATTRIBUTION_REPORTING_REPORT_SENT = 'Storage.attributionReportingReportSent'\n</code></pre> <p>Fired when an attribution report is sent.</p> PARAMETER DESCRIPTION <code>url</code> <p>URL the report was sent to.</p> <p> TYPE: <code>str</code> </p> <code>body</code> <p>Body of the report.</p> <p> TYPE: <code>object</code> </p> <code>result</code> <p>Result of the report sending.</p> <p> TYPE: <code>AttributionReportingReportResult</code> </p> <code>netError</code> <p>If result is sent, populated with net/HTTP status.</p> <p> TYPE: <code>int</code> </p> <code>netErrorName</code> <p>Name of the network error if any.</p> <p> TYPE: <code>str</code> </p> <code>httpStatusCode</code> <p>HTTP status code if available.</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.storage.events.StorageEvent.ATTRIBUTION_REPORTING_SOURCE_REGISTERED","title":"ATTRIBUTION_REPORTING_SOURCE_REGISTERED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ATTRIBUTION_REPORTING_SOURCE_REGISTERED = 'Storage.attributionReportingSourceRegistered'\n</code></pre> <p>Fired when an attribution source is registered.</p> PARAMETER DESCRIPTION <code>registration</code> <p>Registration details.</p> <p> TYPE: <code>AttributionReportingSourceRegistration</code> </p> <code>result</code> <p>Result of the registration.</p> <p> TYPE: <code>AttributionReportingSourceRegistrationResult</code> </p>"},{"location":"api/protocol/events/#pydoll.protocol.storage.events.StorageEvent.ATTRIBUTION_REPORTING_TRIGGER_REGISTERED","title":"ATTRIBUTION_REPORTING_TRIGGER_REGISTERED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ATTRIBUTION_REPORTING_TRIGGER_REGISTERED = 'Storage.attributionReportingTriggerRegistered'\n</code></pre> <p>Fired when an attribution trigger is registered.</p> PARAMETER DESCRIPTION <code>registration</code> <p>Registration details.</p> <p> TYPE: <code>AttributionReportingTriggerRegistration</code> </p> <code>eventLevel</code> <p>Event level result.</p> <p> TYPE: <code>AttributionReportingEventLevelResult</code> </p> <code>aggregatable</code> <p>Aggregatable result.</p> <p> TYPE: <code>AttributionReportingAggregatableResult</code> </p>"},{"location":"api/protocol/events/#input-events","title":"Input Events","text":""},{"location":"api/protocol/events/#pydoll.protocol.input.events","title":"pydoll.protocol.input.events","text":""},{"location":"api/protocol/events/#pydoll.protocol.input.events.InputEvent","title":"InputEvent","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Events from the Input domain of the Chrome DevTools Protocol.</p> <p>This enumeration contains the names of Input-related events that can be received from the Chrome DevTools Protocol. These events provide information about user input interactions that can be intercepted or simulated.</p>"},{"location":"api/protocol/events/#pydoll.protocol.input.events.InputEvent.DRAG_INTERCEPTED","title":"DRAG_INTERCEPTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DRAG_INTERCEPTED = 'Input.dragIntercepted'\n</code></pre> <p>Emitted only when Input.setInterceptDrags is enabled. Use this data with Input.dispatchDragEvent to restore normal drag and drop behavior.</p> PARAMETER DESCRIPTION <code>data</code> <p>Contains information about the dragged data.</p> <p> TYPE: <code>DragData</code> </p>"},{"location":"deep-dive/","title":"Deep Dive","text":"<p>Welcome to the in-depth technical documentation section of Pydoll. This area is dedicated to developers who want to understand the internal workings of the library, its architectural design, and the technical principles behind its operation.</p>"},{"location":"deep-dive/#what-youll-find-here","title":"What You'll Find Here","text":"<p>Unlike the introduction and features sections that focus on \"how to use\" Pydoll, the Deep Dive section explores \"how it works\" and the \"why\" behind the design and implementation decisions.</p> <p>In this section, you'll find detailed documentation about:</p> <ul> <li>Chrome DevTools Protocol (CDP) - How Pydoll communicates with browsers without relying on webdrivers</li> <li>Internal Architecture - The layered structure that makes Pydoll efficient and extensible</li> <li>Domain Implementations - Technical details of each functional domain (Browser, Page, WebElement)</li> <li>Event System - How the reactive event system works internally</li> <li>Performance Optimizations - Details about how we achieve high asynchronous performance</li> </ul>"},{"location":"deep-dive/#who-this-section-is-for","title":"Who This Section Is For","text":"<p>This documentation is especially useful for:</p> <ul> <li>Developers looking to contribute code to Pydoll</li> <li>Engineers creating advanced integrations or extensions</li> <li>Technical users who need to understand the execution model for debugging</li> <li>Anyone interested in the technical aspects of browser automation</li> </ul> <p>Each topic in this section is self-contained, so you can navigate directly to the areas of greatest interest using the navigation menu.</p> <p>Explore the different domains and technical features using the sidebar links to dive deep into Pydoll's implementation details.</p>"},{"location":"deep-dive/browser-domain/","title":"Browser Domain","text":"<p>The Browser domain is the backbone of Pydoll's zero-webdriver architecture. This component provides a direct interface to browser instances through the Chrome DevTools Protocol (CDP), eliminating the need for traditional webdrivers while delivering superior performance and reliability.</p> <pre><code>graph LR\n    A[Pydoll API] --&gt; B[Browser Domain]\n    B &lt;--&gt; C[Chrome DevTools Protocol]\n    C &lt;--&gt; D[Browser Process]\n\n    subgraph \"Internal Components\"\n        B --&gt; E[Connection Handler]\n        B --&gt; F[Process Manager]\n        B --&gt; G[Options Manager]\n        B --&gt; H[Proxy Manager]\n        B --&gt; I[Temp Directory Manager]\n    end</code></pre>"},{"location":"deep-dive/browser-domain/#technical-architecture","title":"Technical Architecture","text":"<p>At its core, the Browser domain is implemented as an abstract base class (<code>Browser</code>) that establishes the fundamental contract for all browser implementations. Specific browser classes like <code>Chrome</code> and <code>Edge</code> extend this base class to provide browser-specific behavior while sharing the common architecture.</p> <pre><code># Abstract base class (simplified)\nclass Browser(ABC):\n    def __init__(self, options_manager: BrowserOptionsManager, connection_port: Optional[int] = None):\n        # Initialize components\n        # ...\n\n    @abstractmethod\n    def _get_default_binary_location(self) -&gt; str:\n        \"\"\"Must be implemented by subclasses\"\"\"\n        pass\n\n    async def start(self, headless: bool = False) -&gt; Tab:\n        # Start browser process\n        # Establish CDP connection\n        # Return initial tab for interaction\n        # ...\n\n# Implementation for Chrome\nclass Chrome(Browser):\n    def _get_default_binary_location(self) -&gt; str:\n        # Return path to Chrome binary\n        # ...\n</code></pre> <p>The abstraction allows Pydoll to support multiple browsers through a unified interface, with each implementation handling browser-specific details such as executable discovery, command-line arguments, and protocol variations.</p>"},{"location":"deep-dive/browser-domain/#core-usage-patterns","title":"Core Usage Patterns","text":"<p>The Browser domain follows a consistent pattern for initialization, tab management, and cleanup. Note that <code>start()</code> now returns a <code>Tab</code> instance directly:</p> <pre><code>import asyncio\nfrom pydoll.browser.chromium import Chrome\n\nasync def simple_browser_example():\n    # Create and start a browser instance\n    browser = Chrome()\n    tab = await browser.start()  # Returns Tab directly\n\n    try:\n        # Navigate and interact with the tab\n        await tab.go_to(\"https://example.com\")\n\n        # Perform operations with the tab\n        title = await tab.execute_script(\"return document.title\")\n        print(f\"Page title: {title}\")\n\n    finally:\n        # Always ensure the browser is properly closed\n        await browser.stop()\n\n# Run the async example\nasyncio.run(simple_browser_example())\n</code></pre> <p>Context Manager Usage</p> <p>For cleaner resource management, use the context manager pattern:</p> <pre><code>async def context_manager_example():\n    async with Chrome() as browser:\n        tab = await browser.start()\n        await tab.go_to(\"https://example.com\")\n        # The browser is automatically closed when exiting the context\n\nasyncio.run(context_manager_example())\n</code></pre>"},{"location":"deep-dive/browser-domain/#hierarchy-of-browser-implementations","title":"Hierarchy of Browser Implementations","text":"<p>The Browser domain follows a clear inheritance hierarchy that promotes code reuse while allowing for browser-specific implementations:</p> <pre><code>classDiagram\n    class Browser {\n        &lt;&lt;Abstract&gt;&gt;\n        +__init__(options_manager, connection_port)\n        +start(headless) Tab\n        +stop()\n        +new_tab(url, browser_context_id) Tab\n        +create_browser_context() str\n        #_get_default_binary_location()*\n    }\n\n    class Chrome {\n        +_get_default_binary_location()\n    }\n\n    class Edge {\n        +_get_default_binary_location()\n    }\n\n    Browser &lt;|-- Chrome : extends\n    Browser &lt;|-- Edge : extends</code></pre> <p>This architecture allows Pydoll to support multiple browser types through a unified interface. Each concrete implementation (Chrome, Edge) needs only to provide browser-specific details like executable discovery, while inheriting the robust core functionality from the base Browser class.</p>"},{"location":"deep-dive/browser-domain/#initialization-parameters","title":"Initialization Parameters","text":"<p>The Browser domain accepts two primary parameters during initialization, each controlling a different aspect of the browser's behavior:</p>"},{"location":"deep-dive/browser-domain/#options-manager-parameter","title":"Options Manager Parameter","text":"<p>The <code>options_manager</code> parameter accepts an instance of <code>BrowserOptionsManager</code> that handles browser options initialization and configuration:</p> <pre><code>from pydoll.browser.chromium import Chrome\nfrom pydoll.browser.interfaces import BrowserOptionsManager\n\n# The options manager is typically handled internally by browser implementations\nbrowser = Chrome()  # Uses default ChromiumOptionsManager internally\n</code></pre> <p>The options manager is responsible for: - Initializing browser options with appropriate defaults - Adding required CDP arguments - Managing browser-specific configuration</p> <p>Internal Implementation</p> <p>Most users don't need to interact directly with the options manager, as browser implementations like <code>Chrome</code> provide their own specialized managers internally. However, advanced users can create custom options managers for specialized configurations.</p>"},{"location":"deep-dive/browser-domain/#connection-port-parameter","title":"Connection Port Parameter","text":"<p>The <code>connection_port</code> parameter defines which port to use for the CDP WebSocket connection:</p> <pre><code># Specify exact port for connection\nbrowser = Chrome(connection_port=9222)\n</code></pre> <p>This parameter serves two distinct purposes:</p> <ol> <li>For browser launching: Specifies which port the browser should open for CDP communication</li> <li>For connection to existing browser: Defines which port to connect to when using external browser instances</li> </ol> <p>Port Availability</p> <p>When not specified, Pydoll selects a random available port between 9223 and 9322. If your environment has firewall or network restrictions, you may need to explicitly set a port that's accessible.</p>"},{"location":"deep-dive/browser-domain/#internal-components","title":"Internal Components","text":"<p>The Browser domain coordinates several specialized components to provide its functionality:</p>"},{"location":"deep-dive/browser-domain/#connection-handler","title":"Connection Handler","text":"<p>The ConnectionHandler establishes and maintains communication with the browser through the Chrome DevTools Protocol. It provides a layer of abstraction over the WebSocket connection, handling command execution, response processing, and event subscription.</p> <p>This component is a fundamental part of Pydoll's architecture and will be explored in more detail in the dedicated Connection Domain section.</p>"},{"location":"deep-dive/browser-domain/#browser-process-manager","title":"Browser Process Manager","text":"<p>The BrowserProcessManager handles the browser process lifecycle:</p> <pre><code>class BrowserProcessManager:\n    def start_browser_process(self, binary, port, arguments):\n        # Launch browser executable with proper arguments\n        # Monitor process startup\n        # ...\n\n    def stop_process(self):\n        # Terminate browser process\n        # Cleanup resources\n        # ...\n</code></pre> <p>This separation of concerns ensures that browser process management is decoupled from protocol communication, making the code more maintainable and testable.</p>"},{"location":"deep-dive/browser-domain/#temp-directory-manager","title":"Temp Directory Manager","text":"<p>The TempDirectoryManager handles temporary directory creation and cleanup for browser user data:</p> <pre><code>class TempDirectoryManager:\n    def create_temp_dir(self):\n        # Create temporary directory for browser user data\n        # Return directory handle\n        # ...\n\n    def cleanup(self):\n        # Remove temporary directories\n        # Clean up resources\n        # ...\n</code></pre> <p>This component ensures that temporary browser data is properly managed and cleaned up, preventing disk space issues during long-running automation sessions.</p>"},{"location":"deep-dive/browser-domain/#proxy-manager","title":"Proxy Manager","text":"<p>The ProxyManager configures browser proxy settings:</p> <pre><code>class ProxyManager:\n    def __init__(self, options):\n        # Parse proxy settings from options\n        # ...\n\n    def get_proxy_credentials(self):\n        # Extract authentication details\n        # Format proxy configuration\n        # ...\n</code></pre> <p>This component is crucial for automated web scraping or testing scenarios that require proxy rotation or authentication.</p>"},{"location":"deep-dive/browser-domain/#lifecyle-and-context-management","title":"Lifecyle and Context Management","text":"<p>The Browser domain implements Python's asynchronous context management protocol (<code>__aenter__</code> and <code>__aexit__</code>) to provide automatic resource cleanup:</p> <pre><code>async def scrape_data():\n    async with Chrome() as browser:\n        tab = await browser.start()\n        await tab.go_to('https://example.com')\n        # Work with tab...\n        # Browser automatically closes when exiting the context\n</code></pre> <p>This pattern ensures that browser processes are properly terminated even if exceptions occur during automation, preventing resource leaks.</p>"},{"location":"deep-dive/browser-domain/#starting-browser-and-getting-initial-tab","title":"Starting Browser and Getting Initial Tab","text":"<pre><code>browser = Chrome()\ntab = await browser.start()  # Returns Tab instance\nawait tab.go_to(\"https://example.com\")\n</code></pre>"},{"location":"deep-dive/browser-domain/#creating-additional-tabs","title":"Creating Additional Tabs","text":"<pre><code># Create additional tabs\ntab2 = await browser.new_tab(\"https://github.com\")\ntab3 = await browser.new_tab()  # Empty tab\n\n# Work with multiple tabs\nawait tab.go_to(\"https://example.com\")\nawait tab2.go_to(\"https://github.com\")\n</code></pre> <p>Multi-Tab Automation</p> <p>You can work with multiple tabs simultaneously:</p> <pre><code>async def multi_tab_example():\n    browser = Chrome()\n    tab1 = await browser.start()\n\n    # Create and work with multiple tabs\n    await tab1.go_to(\"https://example.com\")\n\n    tab2 = await browser.new_tab(\"https://github.com\")\n\n    # Get information from both tabs\n    title1 = await tab1.execute_script(\"return document.title\")\n    title2 = await tab2.execute_script(\"return document.title\")\n\n    print(f\"Tab 1: {title1}\")\n    print(f\"Tab 2: {title2}\")\n\n    await browser.stop()\n</code></pre>"},{"location":"deep-dive/browser-domain/#browser-context-management","title":"Browser Context Management","text":""},{"location":"deep-dive/browser-domain/#understanding-browser-contexts","title":"Understanding Browser Contexts","text":"<p>Browser contexts are one of Pydoll's most powerful features for creating isolated browsing environments. Think of a browser context as a completely separate browser session within the same browser process - similar to opening an incognito window, but with programmatic control.</p> <p>Each browser context maintains its own:</p> <ul> <li>Cookies and session storage: Completely isolated from other contexts</li> <li>Local storage and IndexedDB: Separate data stores per context</li> <li>Cache: Independent caching for each context</li> <li>Permissions: Context-specific permission grants</li> <li>Network settings: Including proxy configurations</li> <li>Authentication state: Login sessions are context-specific</li> </ul> <pre><code>graph TB\n    A[Browser Process] --&gt; B[Default Context]\n    A --&gt; C[Context 1]\n    A --&gt; D[Context 2]\n\n    B --&gt; B1[Tab 1]\n    B --&gt; B2[Tab 2]\n\n    C --&gt; C1[Tab 3]\n\n    D --&gt; D1[Tab 4]\n\n</code></pre>"},{"location":"deep-dive/browser-domain/#why-use-browser-contexts","title":"Why Use Browser Contexts?","text":"<p>Browser contexts are essential for several automation scenarios:</p> <ol> <li>Multi-Account Testing: Test different user accounts simultaneously without interference</li> <li>A/B Testing: Compare different user experiences in parallel</li> <li>Geo-Location Testing: Use different proxy settings per context</li> <li>Session Isolation: Prevent cross-contamination between test scenarios</li> <li>Parallel Scraping: Scrape multiple sites with different configurations</li> </ol>"},{"location":"deep-dive/browser-domain/#creating-and-managing-contexts","title":"Creating and Managing Contexts","text":"<pre><code># Create isolated browser context\ncontext_id = await browser.create_browser_context()\n\n# Create tab in specific context\ntab = await browser.new_tab(\"https://example.com\", browser_context_id=context_id)\n\n# Get all browser contexts\ncontexts = await browser.get_browser_contexts()\nprint(f\"Active contexts: {contexts}\")\n\n# Delete context (closes all associated tabs)\nawait browser.delete_browser_context(context_id)\n</code></pre>"},{"location":"deep-dive/browser-domain/#default-vs-custom-contexts","title":"Default vs Custom Contexts","text":"<p>Every browser starts with a default context that contains the initial tab returned by <code>browser.start()</code>. You can create additional contexts as needed:</p> <pre><code>browser = Chrome()\ndefault_tab = await browser.start()  # Uses default context\n\n# Create custom context\ncustom_context_id = await browser.create_browser_context()\ncustom_tab = await browser.new_tab(\"https://example.com\", browser_context_id=custom_context_id)\n\n# Both tabs are completely isolated from each other\nawait default_tab.go_to(\"https://site1.com\")\nawait custom_tab.go_to(\"https://site2.com\")\n</code></pre>"},{"location":"deep-dive/browser-domain/#practical-example-multi-account-testing","title":"Practical Example: Multi-Account Testing","text":"<p>Here's a real-world example of testing multiple user accounts simultaneously:</p> <pre><code>async def test_multiple_accounts():\n    browser = Chrome()\n    await browser.start()\n\n    # Test data for different accounts\n    accounts = [\n        {\"username\": \"user1@example.com\", \"password\": \"pass1\"},\n        {\"username\": \"user2@example.com\", \"password\": \"pass2\"},\n        {\"username\": \"admin@example.com\", \"password\": \"admin_pass\"}\n    ]\n\n    contexts_and_tabs = []\n\n    # Create isolated context for each account\n    for i, account in enumerate(accounts):\n        context_id = await browser.create_browser_context()\n        tab = await browser.new_tab(\"https://app.example.com/login\", browser_context_id=context_id)\n\n        # Login with account credentials\n        await tab.find(tag_name=\"input\", name=\"username\").type_text(account[\"username\"])\n        await tab.find(tag_name=\"input\", name=\"password\").type_text(account[\"password\"])\n        await tab.find(tag_name=\"button\", type=\"submit\").click()\n\n        contexts_and_tabs.append((context_id, tab, account[\"username\"]))\n\n    # Now test different scenarios with each account simultaneously\n    for context_id, tab, username in contexts_and_tabs:\n        # Each tab maintains its own login session\n        await tab.go_to(\"https://app.example.com/dashboard\")\n        user_info = await tab.find(class_name=\"user-info\").text\n        print(f\"User {username} dashboard: {user_info}\")\n\n    # Cleanup: delete all contexts\n    for context_id, _, _ in contexts_and_tabs:\n        await browser.delete_browser_context(context_id)\n\n    await browser.stop()\n</code></pre>"},{"location":"deep-dive/browser-domain/#context-specific-proxy-configuration","title":"Context-Specific Proxy Configuration","text":"<p>Each browser context can have its own proxy settings, making it perfect for geo-location testing or IP rotation:</p> <pre><code># Create context with specific proxy\ncontext_id = await browser.create_browser_context(\n    proxy_server=\"http://proxy.example.com:8080\",\n    proxy_bypass_list=\"localhost,127.0.0.1\"\n)\n\n# All tabs in this context will use the specified proxy\ntab = await browser.new_tab(\"https://example.com\", browser_context_id=context_id)\n</code></pre>"},{"location":"deep-dive/browser-domain/#advanced-context-management","title":"Advanced Context Management","text":""},{"location":"deep-dive/browser-domain/#context-lifecycle-management","title":"Context Lifecycle Management","text":"<pre><code>async def manage_context_lifecycle():\n    browser = Chrome()\n    await browser.start()\n\n    # Create multiple contexts for different purposes\n    contexts = {}\n\n    # Context for US region testing\n    us_context = await browser.create_browser_context(\n        proxy_server=\"http://us-proxy.example.com:8080\"\n    )\n    contexts['us'] = us_context\n\n    # Context for EU region testing  \n    eu_context = await browser.create_browser_context(\n        proxy_server=\"http://eu-proxy.example.com:8080\"\n    )\n    contexts['eu'] = eu_context\n\n    # Context for admin testing (no proxy)\n    admin_context = await browser.create_browser_context()\n    contexts['admin'] = admin_context\n\n    try:\n        # Use contexts for parallel testing\n        us_tab = await browser.new_tab(\"https://api.example.com/geo\", browser_context_id=contexts['us'])\n        eu_tab = await browser.new_tab(\"https://api.example.com/geo\", browser_context_id=contexts['eu'])\n        admin_tab = await browser.new_tab(\"https://admin.example.com\", browser_context_id=contexts['admin'])\n\n        # Each tab will have different IP/location\n        us_location = await us_tab.execute_script(\"return fetch('/api/location').then(r =&gt; r.json())\")\n        eu_location = await eu_tab.execute_script(\"return fetch('/api/location').then(r =&gt; r.json())\")\n\n        print(f\"US Context Location: {us_location}\")\n        print(f\"EU Context Location: {eu_location}\")\n\n    finally:\n        # Clean up all contexts\n        for region, context_id in contexts.items():\n            await browser.delete_browser_context(context_id)\n            print(f\"Deleted {region} context\")\n\n        await browser.stop()\n</code></pre>"},{"location":"deep-dive/browser-domain/#context-storage-isolation","title":"Context Storage Isolation","text":"<pre><code>async def demonstrate_storage_isolation():\n    browser = Chrome()\n    await browser.start()\n\n    # Create two contexts\n    context1 = await browser.create_browser_context()\n    context2 = await browser.create_browser_context()\n\n    # Create tabs in each context\n    tab1 = await browser.new_tab(\"https://example.com\", browser_context_id=context1)\n    tab2 = await browser.new_tab(\"https://example.com\", browser_context_id=context2)\n\n    # Set different data in localStorage for each context\n    await tab1.execute_script(\"localStorage.setItem('user', 'Alice')\")\n    await tab2.execute_script(\"localStorage.setItem('user', 'Bob')\")\n\n    # Verify isolation - each context has its own storage\n    user1 = await tab1.execute_script(\"return localStorage.getItem('user')\")\n    user2 = await tab2.execute_script(\"return localStorage.getItem('user')\")\n\n    print(f\"Context 1 user: {user1}\")  # Alice\n    print(f\"Context 2 user: {user2}\")  # Bob\n\n    # Clean up\n    await browser.delete_browser_context(context1)\n    await browser.delete_browser_context(context2)\n    await browser.stop()\n</code></pre>"},{"location":"deep-dive/browser-domain/#target-management","title":"Target Management","text":"<p>Get information about all active targets (tabs, service workers, etc.) in the browser:</p> <pre><code># Get all targets\ntargets = await browser.get_targets()\n\n# Filter for page targets only\npages = [t for t in targets if t.get('type') == 'page']\n\nfor page in pages:\n    print(f\"Target ID: {page['targetId']}\")\n    print(f\"URL: {page['url']}\")\n    print(f\"Title: {page.get('title', 'No title')}\")\n</code></pre>"},{"location":"deep-dive/browser-domain/#window-management","title":"Window Management","text":"<p>The Browser domain provides methods to control the browser window:</p> <pre><code># Get the current window ID\nwindow_id = await browser.get_window_id()\n\n# Set window bounds (position and size)\nawait browser.set_window_bounds({\n    'left': 100,\n    'top': 100,\n    'width': 1024,\n    'height': 768\n})\n\n# Maximize the window\nawait browser.set_window_maximized()\n\n# Minimize the window\nawait browser.set_window_minimized()\n</code></pre> <p>Window Management Use Cases</p> <p>Window management is particularly useful for: - Setting precise window sizes for consistent screenshots - Positioning windows for multi-monitor setups - Creating user-friendly automation that's visible during development</p>"},{"location":"deep-dive/browser-domain/#cookie-management","title":"Cookie Management","text":"<p>The Browser domain provides methods for browser-wide cookie management:</p> <pre><code># Set cookies at the browser level\ncookies_to_set = [\n    {\n        \"name\": \"session_id\",\n        \"value\": \"global_session_123\",\n        \"domain\": \"example.com\",\n        \"path\": \"/\",\n        \"secure\": True,\n        \"httpOnly\": True\n    }\n]\nawait browser.set_cookies(cookies_to_set)\n\n# Get all cookies from the browser\nall_cookies = await browser.get_cookies()\nprint(f\"Number of cookies: {len(all_cookies)}\")\n\n# Delete all cookies from the browser\nawait browser.delete_all_cookies()\n</code></pre>"},{"location":"deep-dive/browser-domain/#context-specific-cookie-management","title":"Context-Specific Cookie Management","text":"<pre><code># Create browser context\ncontext_id = await browser.create_browser_context()\n\n# Set cookies for specific context\nawait browser.set_cookies(cookies_to_set, browser_context_id=context_id)\n\n# Get cookies from specific context\ncontext_cookies = await browser.get_cookies(browser_context_id=context_id)\n\n# Delete cookies from specific context\nawait browser.delete_all_cookies(browser_context_id=context_id)\n</code></pre> <p>Browser vs Tab Cookie Management</p> <ul> <li>Browser-level cookies (using the methods above) apply to all tabs in the browser or specific context</li> <li>Tab-level cookies (using <code>tab.set_cookies()</code>) apply only to that specific tab</li> </ul> <p>Choose the appropriate scope based on your automation needs.</p>"},{"location":"deep-dive/browser-domain/#download-management","title":"Download Management","text":"<p>Configure download behavior for the browser or specific contexts:</p> <pre><code># Set a custom download path\ndownload_path = \"/path/to/downloads\"\nawait browser.set_download_path(download_path)\n\n# Advanced download configuration\nawait browser.set_download_behavior(\n    behavior=DownloadBehavior.ALLOW,\n    download_path=download_path,\n    events_enabled=True  # Enable download progress events\n)\n\n# Context-specific download configuration\ncontext_id = await browser.create_browser_context()\nawait browser.set_download_behavior(\n    behavior=DownloadBehavior.ALLOW,\n    download_path=\"/path/to/context/downloads\",\n    browser_context_id=context_id\n)\n</code></pre>"},{"location":"deep-dive/browser-domain/#permission-management","title":"Permission Management","text":"<p>Grant or reset browser permissions for automated testing:</p> <pre><code>from pydoll.constants import PermissionType\n\n# Grant permissions globally\nawait browser.grant_permissions([\n    PermissionType.GEOLOCATION,\n    PermissionType.NOTIFICATIONS,\n    PermissionType.CAMERA\n])\n\n# Grant permissions for specific origin\nawait browser.grant_permissions(\n    [PermissionType.GEOLOCATION],\n    origin=\"https://example.com\"\n)\n\n# Grant permissions for specific context\ncontext_id = await browser.create_browser_context()\nawait browser.grant_permissions(\n    [PermissionType.MICROPHONE],\n    browser_context_id=context_id\n)\n\n# Reset all permissions to defaults\nawait browser.reset_permissions()\n</code></pre>"},{"location":"deep-dive/browser-domain/#event-system-overview","title":"Event System Overview","text":"<p>The Browser domain provides methods to enable and monitor various types of events. These methods include <code>enable_fetch_events()</code> and the <code>on()</code> method for registering event callbacks.</p>"},{"location":"deep-dive/browser-domain/#request-interception","title":"Request Interception","text":"<pre><code># Enable request interception\nawait browser.enable_fetch_events(handle_auth_requests=True)\n\n# Register event handler for intercepted requests\nasync def handle_request(event):\n    request_id = event['params']['requestId']\n    url = event['params']['request']['url']\n\n    if 'analytics' in url:\n        # Block analytics requests\n        await browser.fail_request(request_id, NetworkErrorReason.BLOCKED_BY_CLIENT)\n    else:\n        # Continue other requests\n        await browser.continue_request(request_id)\n\nawait browser.on('Fetch.requestPaused', handle_request)\n</code></pre>"},{"location":"deep-dive/browser-domain/#custom-response-fulfillment","title":"Custom Response Fulfillment","text":"<pre><code>async def fulfill_custom_response(event):\n    request_id = event['params']['requestId']\n\n    # Fulfill with custom response\n    await browser.fulfill_request(\n        request_id=request_id,\n        response_code=200,\n        response_headers=[{'name': 'Content-Type', 'value': 'application/json'}],\n        response_body={'message': 'Custom response from Pydoll'}\n    )\n\nawait browser.on('Fetch.requestPaused', fulfill_custom_response)\n</code></pre> <p>Browser vs Tab Event Scope</p> <p>When enabling events at the Browser level (e.g., <code>browser.enable_fetch_events()</code>), they apply globally to all tabs in the browser. In contrast, enabling events at the Tab level (e.g., <code>tab.enable_fetch_events()</code>) affects only that specific tab.</p> <p>This distinction is important for performance and resource management. Enable events at the browser level when you need to monitor activity across all tabs, and at the tab level when you only care about a specific tab's events.</p> <p>Detailed Event System Documentation</p> <p>The event system is a core component of Pydoll's architecture and will be covered in detail in a dedicated section. This will include event types, handling patterns, and advanced event-driven techniques.</p>"},{"location":"deep-dive/browser-domain/#proxy-configuration","title":"Proxy Configuration","text":"<p>Pydoll supports using proxies for browser connections. This is useful for web scraping, testing geo-specific content, or bypassing IP-based rate limits:</p> <pre><code>from pydoll.browser.chromium import Chrome\nfrom pydoll.browser.options import ChromiumOptions\n\noptions = ChromiumOptions()\n\n# Configure a proxy\noptions.add_argument('--proxy-server=http://proxy.example.com:8080')\n\n# For proxies requiring authentication\nbrowser = Chrome(options=options)\ntab = await browser.start()\n\n# Pydoll automatically handles proxy authentication challenges\nawait tab.go_to(\"https://example.com\")\n</code></pre> <p>Private Proxy Authentication</p> <p>Pydoll handles private proxy authentication automatically:</p> <ol> <li>When a proxy authentication challenge is detected, Pydoll intercepts it</li> <li>The proxy credentials are applied from the options</li> <li>The authentication is completed transparently</li> <li>Your automation continues without interruption</li> </ol> <p>This makes working with authenticated proxies much simpler compared to traditional browser automation.</p>"},{"location":"deep-dive/browser-domain/#conclusion","title":"Conclusion","text":"<p>The Browser domain serves as the foundation of Pydoll's architecture, providing a powerful interface to browser instances through the Chrome DevTools Protocol. By understanding its capabilities and patterns, you can create sophisticated browser automation that's more reliable and efficient than traditional webdriver-based approaches.</p> <p>The combination of a clean abstraction layer, comprehensive event system, tab-based architecture, and direct control over the browser process enables advanced automation scenarios while maintaining a simple and intuitive API.</p>"},{"location":"deep-dive/cdp/","title":"Chrome DevTools Protocol (CDP)","text":"<p>The Chrome DevTools Protocol (CDP) is the foundation that enables Pydoll to control browsers without traditional webdrivers. Understanding how CDP works provides valuable insight into Pydoll's capabilities and internal architecture.</p>"},{"location":"deep-dive/cdp/#what-is-cdp","title":"What is CDP?","text":"<p>The Chrome DevTools Protocol is a powerful interface developed by the Chromium team that allows programmatic interaction with Chromium-based browsers. It's the same protocol used by Chrome DevTools when you inspect a webpage, but exposed as a programmable API that can be leveraged by automation tools.</p> <p>At its core, CDP provides a comprehensive set of methods and events for interfacing with browser internals. This allows for fine-grained control over every aspect of the browser, from navigating between pages to manipulating the DOM, intercepting network requests, and monitoring performance metrics.</p> <p>CDP Evolution</p> <p>The Chrome DevTools Protocol has been continuously evolving since its introduction. Google maintains and updates the protocol with each Chrome release, regularly adding new functionality and improving existing features.</p> <p>While the protocol was initially designed for Chrome's DevTools, its comprehensive capabilities have made it the foundation for next-generation browser automation tools like Puppeteer, Playwright, and of course, Pydoll.</p>"},{"location":"deep-dive/cdp/#websocket-communication","title":"WebSocket Communication","text":"<p>One of the key architectural decisions in CDP is its use of WebSockets for communication. When a Chromium-based browser is started with the remote debugging flag enabled, it opens a WebSocket server on a specified port:</p> <pre><code>chrome --remote-debugging-port=9222\n</code></pre> <p>Pydoll connects to this WebSocket endpoint to establish a bidirectional communication channel with the browser. This connection:</p> <ol> <li>Remains persistent throughout the automation session</li> <li>Enables real-time events from the browser to be pushed to the client</li> <li>Allows commands to be sent to the browser</li> <li>Supports binary data for efficient transfer of screenshots, PDFs, and other assets</li> </ol> <p>The WebSocket protocol is particularly well-suited for browser automation because it provides:</p> <ul> <li>Low latency communication - Necessary for responsive automation</li> <li>Bidirectional messaging - Essential for event-driven architecture</li> <li>Persistent connections - Eliminating connection setup overhead for each operation</li> </ul> <p>Here's a simplified view of how Pydoll's communication with the browser works:</p> <pre><code>sequenceDiagram\n    participant App as Pydoll Application\n    participant WS as WebSocket Connection\n    participant Browser as Chrome Browser\n\n    App -&gt;&gt; WS: Command: navigate to URL\n    WS -&gt;&gt; Browser: Execute navigation\n\n    Browser --&gt;&gt; WS: Send page load event\n    WS --&gt;&gt; App: Receive page load event</code></pre> <p>WebSocket vs HTTP</p> <p>Earlier browser automation protocols often relied on HTTP endpoints for communication. CDP's switch to WebSockets represents a significant architectural improvement that enables more responsive automation and real-time event monitoring.</p> <p>HTTP-based protocols require continuous polling to detect changes, creating overhead and delays. WebSockets allow the browser to push notifications to your automation script exactly when events occur, with minimal latency.</p>"},{"location":"deep-dive/cdp/#key-cdp-domains","title":"Key CDP Domains","text":"<p>CDP is organized into logical domains, each responsible for a specific aspect of browser functionality. Some of the most important domains include:</p> Domain Responsibility Example Use Cases Browser Control of the browser application itself Window management, browser context creation Page Interaction with page lifecycle Navigation, JavaScript execution, frame management DOM Access to page structure Query selectors, attribute modification, event listeners Network Network traffic monitoring and control Request interception, response examination, caching Runtime JavaScript execution environment Evaluate expressions, call functions, handle exceptions Input Simulating user interactions Mouse movements, keyboard input, touch events Target Managing browser contexts and targets Creating tabs, accessing iframes, handling popups Fetch Low-level network interception Modifying requests, simulating responses, authentication <p>Pydoll maps these CDP domains to a more intuitive API structure while preserving the full capabilities of the underlying protocol.</p>"},{"location":"deep-dive/cdp/#event-driven-architecture","title":"Event-Driven Architecture","text":"<p>One of CDP's most powerful features is its event system. The protocol allows clients to subscribe to various events that the browser emits during normal operation. These events cover virtually every aspect of browser behavior:</p> <ul> <li>Lifecycle events: Page loads, frame navigation, target creation</li> <li>DOM events: Element changes, attribute modifications</li> <li>Network events: Request/response cycles, WebSocket messages</li> <li>Execution events: JavaScript exceptions, console messages</li> <li>Performance events: Metrics for rendering, scripting, and more</li> </ul> <p>When you enable event monitoring in Pydoll (e.g., with <code>page.enable_network_events()</code>), the library sets up the necessary subscriptions with the browser and provides hooks for your code to react to these events.</p> <pre><code>from pydoll.events.network import NetworkEvents\nfrom functools import partial\n\nasync def on_request(page, event):\n    url = event['params']['request']['url']\n    print(f\"Request to: {url}\")\n\n# Subscribe to network request events\nawait page.enable_network_events()\nawait page.on(NetworkEvents.REQUEST_WILL_BE_SENT, partial(on_request, page))\n</code></pre> <p>This event-driven approach allows automation scripts to react immediately to browser state changes without relying on inefficient polling or arbitrary delays.</p>"},{"location":"deep-dive/cdp/#performance-advantages-of-direct-cdp-integration","title":"Performance Advantages of Direct CDP Integration","text":"<p>Using CDP directly, as Pydoll does, offers several performance advantages over traditional webdriver-based automation:</p>"},{"location":"deep-dive/cdp/#1-elimination-of-protocol-translation-layer","title":"1. Elimination of Protocol Translation Layer","text":"<p>Traditional webdriver-based tools like Selenium use a multi-layered approach:</p> <pre><code>graph LR\n    AS[Automation Script] --&gt; WC[WebDriver Client]\n    WC --&gt; WS[WebDriver Server]\n    WS --&gt; B[Browser]</code></pre> <p>Each layer adds overhead, especially the WebDriver server, which acts as a translation layer between the WebDriver protocol and the browser's native APIs.</p> <p>Pydoll's approach streamlines this to:</p> <pre><code>graph LR\n    AS[Automation Script] --&gt; P[Pydoll]\n    P --&gt; B[Browser via CDP]</code></pre> <p>This direct communication eliminates the computational and network overhead of the intermediate server, resulting in faster operations.</p>"},{"location":"deep-dive/cdp/#2-efficient-command-batching","title":"2. Efficient Command Batching","text":"<p>CDP allows for the batching of multiple commands in a single message, reducing the number of round trips required for complex operations. This is particularly valuable for operations that require several steps, such as finding an element and then interacting with it.</p>"},{"location":"deep-dive/cdp/#3-asynchronous-operation","title":"3. Asynchronous Operation","text":"<p>CDP's WebSocket-based, event-driven architecture aligns perfectly with Python's asyncio framework, enabling true asynchronous operation. This allows Pydoll to:</p> <ul> <li>Execute multiple operations concurrently</li> <li>Process events as they occur</li> <li>Avoid blocking the main thread during I/O operations</li> </ul> <pre><code>graph TD\n    subgraph \"Pydoll Async Architecture\"\n        EL[Event Loop]\n\n        subgraph \"Concurrent Tasks\"\n            T1[Task 1: Navigate]\n            T2[Task 2: Wait for Element]\n            T3[Task 3: Handle Network Events]\n        end\n\n        EL --&gt; T1\n        EL --&gt; T2\n        EL --&gt; T3\n\n        T1 --&gt; WS[WebSocket Connection]\n        T2 --&gt; WS\n        T3 --&gt; WS\n\n        WS --&gt; B[Browser]\n    end</code></pre> <p>Async Performance Gains</p> <p>The combination of asyncio and CDP creates a multiplicative effect on performance. In benchmark tests, Pydoll's asynchronous approach can process multiple pages in parallel with near-linear scaling, while traditional synchronous tools see diminishing returns as concurrency increases.</p> <p>For example, scraping 10 pages that each take 2 seconds to load might take over 20 seconds with a synchronous tool, but just over 2 seconds with Pydoll's async architecture (plus some minimal overhead).</p>"},{"location":"deep-dive/cdp/#4-fine-grained-control","title":"4. Fine-Grained Control","text":"<p>CDP provides more granular control over browser behavior than the WebDriver protocol. This allows Pydoll to implement optimized strategies for common operations:</p> <ul> <li>More precise waiting conditions (vs. arbitrary timeouts)</li> <li>Direct access to browser caches and storage</li> <li>Targeted JavaScript execution in specific contexts</li> <li>Detailed network control for request optimization</li> </ul>"},{"location":"deep-dive/cdp/#conclusion","title":"Conclusion","text":"<p>The Chrome DevTools Protocol forms the foundation of Pydoll's zero-webdriver approach to browser automation. By leveraging CDP's WebSocket communication, comprehensive domain coverage, event-driven architecture, and direct browser integration, Pydoll achieves superior performance and reliability compared to traditional automation tools.</p> <p>In the following sections, we'll dive deeper into how Pydoll implements specific CDP domains and transforms the low-level protocol into an intuitive, developer-friendly API. </p>"},{"location":"deep-dive/connection-layer/","title":"Connection Handler","text":"<p>The Connection Handler is the foundational layer of Pydoll's architecture, serving as the bridge between your Python code and the browser's Chrome DevTools Protocol (CDP). This component manages the WebSocket connection to the browser, handles command execution, and processes events in a non-blocking, asynchronous manner.</p> <pre><code>graph TD\n    A[Python Code] --&gt; B[Connection Handler]\n    B &lt;--&gt; C[WebSocket]\n    C &lt;--&gt; D[Browser CDP Endpoint]\n\n    subgraph \"Connection Handler\"\n        E[Command Manager]\n        F[Events Handler]\n        G[WebSocket Client]\n    end\n\n    B --&gt; E\n    B --&gt; F\n    B --&gt; G</code></pre>"},{"location":"deep-dive/connection-layer/#asynchronous-programming-model","title":"Asynchronous Programming Model","text":"<p>Pydoll is built on Python's <code>asyncio</code> framework, which enables non-blocking I/O operations. This design choice is critical for high-performance browser automation, as it allows multiple operations to occur concurrently without waiting for each to complete.</p>"},{"location":"deep-dive/connection-layer/#understanding-asyncawait","title":"Understanding Async/Await","text":"<p>To understand how async/await works in practice, let's examine a more detailed example with two concurrent operations:</p> <pre><code>import asyncio\nfrom pydoll.browser.chrome import Chrome\n\nasync def fetch_page_data(url):\n    print(f\"Starting fetch for {url}\")\n    browser = Chrome()\n    await browser.start()\n    page = await browser.get_page()\n\n    # Navigation takes time - this is where we yield control\n    await page.go_to(url)\n\n    # Get page title\n    title = await page.execute_script(\"return document.title\")\n\n    # Extract some data\n    description = await page.execute_script(\n        \"return document.querySelector('meta[name=\\\"description\\\"]')?.content || ''\"\n    )\n\n    await browser.stop()\n    print(f\"Completed fetch for {url}\")\n    return {\"url\": url, \"title\": title, \"description\": description}\n\nasync def main():\n    # Start two page operations concurrently\n    task1 = asyncio.create_task(fetch_page_data(\"https://example.com\"))\n    task2 = asyncio.create_task(fetch_page_data(\"https://github.com\"))\n\n    # Wait for both to complete and get results\n    result1 = await task1\n    result2 = await task2\n\n    return [result1, result2]\n\n# Run the async function\nresults = asyncio.run(main())\n</code></pre> <p>This example demonstrates how we can fetch data from two different websites concurrently, potentially cutting the overall execution time nearly in half compared to sequential execution.</p>"},{"location":"deep-dive/connection-layer/#async-execution-flow-diagram","title":"Async Execution Flow Diagram","text":"<p>Here's what happens in the event loop when executing the code above:</p> <pre><code>sequenceDiagram\n    participant A as Main Code\n    participant B as Task 1&lt;br/&gt; (example.com)\n    participant C as Task 2&lt;br/&gt; (github.com)\n    participant D as Event Loop\n\n    A-&gt;&gt;B: Create task1\n    B-&gt;&gt;D: Register in loop\n    A-&gt;&gt;C: Create task2\n    C-&gt;&gt;D: Register in loop\n    D-&gt;&gt;B: Execute until browser.start()\n    D-&gt;&gt;C: Execute until browser.start()\n    D--&gt;&gt;B: Resume after WebSocket connected\n    D--&gt;&gt;C: Resume after WebSocket connected\n    D-&gt;&gt;B: Execute until page.go_to()\n    D-&gt;&gt;C: Execute until page.go_to()\n    D--&gt;&gt;B: Resume after page loaded\n    D--&gt;&gt;C: Resume after page loaded\n    B--&gt;&gt;A: Return result\n    C--&gt;&gt;A: Return result</code></pre> <p>This sequence diagram illustrates how Python's asyncio manages the two concurrent tasks in our example code:</p> <ol> <li>The main function creates two tasks for fetching data from different websites</li> <li>Both tasks are registered in the event loop</li> <li>The event loop executes each task until it hits an <code>await</code> statement (like <code>browser.start()</code>)</li> <li>When async operations complete (like a WebSocket connection being established), tasks resume</li> <li>The loop continues to switch between tasks at each <code>await</code> point</li> <li>When each task completes, it returns its result back to the main function</li> </ol> <p>In the <code>fetch_page_data</code> example, this allows both browser instances to work concurrently - while one is waiting for a page to load, the other can be making progress. This is significantly more efficient than sequentially processing each website, as I/O wait times don't block the execution of other tasks.</p> <p>Cooperative Multitasking</p> <p>Asyncio uses cooperative multitasking, where tasks voluntarily yield control at <code>await</code> points. This differs from preemptive multitasking (threads), where tasks can be interrupted at any time. Cooperative multitasking can provide better performance for I/O-bound operations but requires careful coding to avoid blocking the event loop.</p>"},{"location":"deep-dive/connection-layer/#connection-handler-implementation","title":"Connection Handler Implementation","text":"<p>The <code>ConnectionHandler</code> class is designed to manage both command execution and event processing, providing a robust interface to the CDP WebSocket connection.</p>"},{"location":"deep-dive/connection-layer/#class-initialization","title":"Class Initialization","text":"<pre><code>def __init__(\n    self,\n    connection_port: int,\n    page_id: str = 'browser',\n    ws_address_resolver: Callable[[int], str] = get_browser_ws_address,\n    ws_connector: Callable = websockets.connect,\n):\n    # Initialize components...\n</code></pre> <p>The ConnectionHandler accepts several parameters:</p> Parameter Type Description <code>connection_port</code> <code>int</code> Port number where the browser's CDP endpoint is listening <code>page_id</code> <code>str</code> Identifier for the specific page/target (use 'browser' for browser-level connections) <code>ws_address_resolver</code> <code>Callable</code> Function to resolve the WebSocket URL from the port number <code>ws_connector</code> <code>Callable</code> Function to establish the WebSocket connection"},{"location":"deep-dive/connection-layer/#internal-components","title":"Internal Components","text":"<p>The ConnectionHandler orchestrates three primary components:</p> <ol> <li>WebSocket Connection: Manages the actual WebSocket communication with the browser</li> <li>Command Manager: Handles sending commands and receiving responses</li> <li>Events Handler: Processes events from the browser and triggers appropriate callbacks</li> </ol> <pre><code>classDiagram\n    class ConnectionHandler {\n        -_connection_port: int\n        -_page_id: str\n        -_ws_connection\n        -_command_manager: CommandManager\n        -_events_handler: EventsHandler\n        +execute_command(command, timeout) async\n        +register_callback(event_name, callback) async\n        +remove_callback(callback_id) async\n        +ping() async\n        +close() async\n        -_receive_events() async\n    }\n\n    class CommandManager {\n        -_pending_commands: dict\n        +create_command_future(command)\n        +resolve_command(id, response)\n        +remove_pending_command(id)\n    }\n\n    class EventsHandler {\n        -_callbacks: dict\n        -_network_logs: list\n        -_dialog: dict\n        +register_callback(event_name, callback, temporary)\n        +remove_callback(callback_id)\n        +clear_callbacks()\n        +process_event(event) async\n    }\n\n    ConnectionHandler *-- CommandManager\n    ConnectionHandler *-- EventsHandler</code></pre>"},{"location":"deep-dive/connection-layer/#command-execution-flow","title":"Command Execution Flow","text":"<p>When executing a command through the CDP, the ConnectionHandler follows a specific pattern:</p> <ol> <li>Ensure an active WebSocket connection exists</li> <li>Create a Future object to represent the pending response</li> <li>Send the command over the WebSocket</li> <li>Await the Future to be resolved with the response</li> <li>Return the response to the caller</li> </ol> <pre><code>async def execute_command(self, command: dict, timeout: int = 10) -&gt; dict:\n    # Validate command\n    if not isinstance(command, dict):\n        logger.error('Command must be a dictionary.')\n        raise exceptions.InvalidCommand('Command must be a dictionary')\n\n    # Ensure connection is active\n    await self._ensure_active_connection()\n\n    # Create future for this command\n    future = self._command_manager.create_command_future(command)\n    command_str = json.dumps(command)\n\n    # Send command and await response\n    try:\n        await self._ws_connection.send(command_str)\n        response: str = await asyncio.wait_for(future, timeout)\n        return json.loads(response)\n    except asyncio.TimeoutError as exc:\n        self._command_manager.remove_pending_command(command['id'])\n        raise exc\n    except websockets.ConnectionClosed as exc:\n        await self._handle_connection_loss()\n        raise exc\n</code></pre> <p>Command Timeout</p> <p>Commands that don't receive a response within the specified timeout period will raise a <code>TimeoutError</code>. This prevents automation scripts from hanging indefinitely due to missing responses. The default timeout is 10 seconds, but can be adjusted based on expected response times for complex operations.</p>"},{"location":"deep-dive/connection-layer/#event-processing-system","title":"Event Processing System","text":"<p>The event system is a key architectural component that enables reactive programming patterns in Pydoll. It allows you to register callbacks for specific browser events and have them executed automatically when those events occur.</p>"},{"location":"deep-dive/connection-layer/#event-flow","title":"Event Flow","text":"<p>The event processing flow follows these steps:</p> <ol> <li>The <code>_receive_events</code> method runs as a background task, continuously receiving messages from the WebSocket</li> <li>Each message is parsed and classified as either a command response or an event</li> <li>Events are passed to the EventsHandler for processing</li> <li>The EventsHandler identifies registered callbacks for the event and invokes them</li> </ol> <pre><code>flowchart TD\n    A[WebSocket Message] --&gt; B{Is Command Response?}\n    B --&gt;|Yes| C[Resolve Command Future]\n    B --&gt;|No| D[Process as Event]\n    D --&gt; E[Find Matching Callbacks]\n    E --&gt; F[Execute Callbacks]\n    F --&gt; G{Is Temporary?}\n    G --&gt;|Yes| H[Remove Callback]\n    G --&gt;|No| I[Keep Callback]</code></pre>"},{"location":"deep-dive/connection-layer/#callback-registration","title":"Callback Registration","text":"<p>The ConnectionHandler provides methods to register, remove, and manage event callbacks:</p> <pre><code># Register a callback for a specific event\ncallback_id = await connection.register_callback(\n    'Page.loadEventFired', \n    handle_page_load\n)\n\n# Remove a specific callback\nawait connection.remove_callback(callback_id)\n\n# Remove all callbacks\nawait connection.clear_callbacks()\n</code></pre> <p>Temporary Callbacks</p> <p>You can register a callback as temporary, which means it will be automatically removed after being triggered once. This is useful for one-time events like dialog handling:</p> <pre><code>await connection.register_callback(\n    'Page.javascriptDialogOpening',\n    handle_dialog,\n    temporary=True\n)\n</code></pre>"},{"location":"deep-dive/connection-layer/#asynchronous-callback-execution","title":"Asynchronous Callback Execution","text":"<p>Callbacks can be either synchronous functions or asynchronous coroutines. The ConnectionHandler handles both types properly:</p> <pre><code># Synchronous callback\ndef synchronous_callback(event):\n    print(f\"Event received: {event['method']}\")\n\n# Asynchronous callback\nasync def asynchronous_callback(event):\n    await asyncio.sleep(0.1)  # Perform some async operation\n    print(f\"Event processed asynchronously: {event['method']}\")\n\n# Both can be registered the same way\nawait connection.register_callback('Network.requestWillBeSent', synchronous_callback)\nawait connection.register_callback('Network.responseReceived', asynchronous_callback)\n</code></pre> <p>For asynchronous callbacks, the ConnectionHandler wraps them in a task that runs in the background, allowing the event processing loop to continue without waiting for the callback to complete.</p>"},{"location":"deep-dive/connection-layer/#connection-management","title":"Connection Management","text":"<p>The ConnectionHandler implements several strategies to ensure robust connections:</p>"},{"location":"deep-dive/connection-layer/#lazy-connection-establishment","title":"Lazy Connection Establishment","text":"<p>Connections are established only when needed, typically when the first command is executed or when explicitly requested. This lazy initialization approach conserves resources and allows for more flexible connection management.</p>"},{"location":"deep-dive/connection-layer/#automatic-reconnection","title":"Automatic Reconnection","text":"<p>If the WebSocket connection is lost or closed unexpectedly, the ConnectionHandler will attempt to re-establish it automatically when the next command is executed. This provides resilience against transient network issues.</p> <pre><code>async def _ensure_active_connection(self):\n    \"\"\"\n    Guarantees that an active connection exists before proceeding.\n    \"\"\"\n    if self._ws_connection is None or self._ws_connection.closed:\n        await self._establish_new_connection()\n</code></pre>"},{"location":"deep-dive/connection-layer/#resource-cleanup","title":"Resource Cleanup","text":"<p>The ConnectionHandler implements both explicit cleanup methods and Python's asynchronous context manager protocol (<code>__aenter__</code> and <code>__aexit__</code>), ensuring resources are properly released when no longer needed:</p> <pre><code>async def close(self):\n    \"\"\"\n    Closes the WebSocket connection and clears all callbacks.\n    \"\"\"\n    await self.clear_callbacks()\n    if self._ws_connection is not None:\n        try:\n            await self._ws_connection.close()\n        except websockets.ConnectionClosed as e:\n            logger.info(f'WebSocket connection has closed: {e}')\n        logger.info('WebSocket connection closed.')\n</code></pre> <p>Context Manager Usage</p> <p>Using the ConnectionHandler as a context manager is the recommended pattern for ensuring proper resource cleanup:</p> <pre><code>async with ConnectionHandler(9222, 'browser') as connection:\n    # Work with the connection...\n    await connection.execute_command(...)\n# Connection is automatically closed when exiting the context\n</code></pre>"},{"location":"deep-dive/connection-layer/#message-processing-pipeline","title":"Message Processing Pipeline","text":"<p>The ConnectionHandler implements a sophisticated message processing pipeline that handles the continuous stream of messages from the WebSocket connection:</p> <pre><code>sequenceDiagram\n    participant WS as WebSocket\n    participant RCV as _receive_events\n    participant MSG as _process_single_message\n    participant PARSE as _parse_message\n    participant CMD as _handle_command_message\n    participant EVT as _handle_event_message\n\n    loop While connected\n        WS-&gt;&gt;RCV: message\n        RCV-&gt;&gt;MSG: raw_message\n        MSG-&gt;&gt;PARSE: raw_message\n        PARSE--&gt;&gt;MSG: parsed JSON or None\n\n        alt Is command response\n            MSG-&gt;&gt;CMD: message\n            CMD-&gt;&gt;CMD: resolve command future\n        else Is event notification\n            MSG-&gt;&gt;EVT: message\n            EVT-&gt;&gt;EVT: process event &amp; trigger callbacks\n        end\n    end</code></pre> <p>This pipeline ensures efficient processing of both command responses and asynchronous events, allowing Pydoll to maintain responsive operation even under high message volume.</p>"},{"location":"deep-dive/connection-layer/#advanced-usage","title":"Advanced Usage","text":"<p>The ConnectionHandler is usually used indirectly through the Browser and Page classes, but it can also be used directly for advanced scenarios:</p>"},{"location":"deep-dive/connection-layer/#direct-event-monitoring","title":"Direct Event Monitoring","text":"<p>For specialized use cases, you might want to bypass the higher-level APIs and directly monitor specific CDP events:</p> <pre><code>from pydoll.connection.connection import ConnectionHandler\n\nasync def monitor_network():\n    connection = ConnectionHandler(9222)\n\n    async def log_request(event):\n        url = event['params']['request']['url']\n        print(f\"Request: {url}\")\n\n    await connection.register_callback(\n        'Network.requestWillBeSent', \n        log_request\n    )\n\n    # Enable network events via CDP command\n    await connection.execute_command({\n        \"id\": 1,\n        \"method\": \"Network.enable\"\n    })\n\n    # Keep running until interrupted\n    try:\n        while True:\n            await asyncio.sleep(1)\n    finally:\n        await connection.close()\n</code></pre>"},{"location":"deep-dive/connection-layer/#custom-command-execution","title":"Custom Command Execution","text":"<p>You can execute arbitrary CDP commands directly:</p> <pre><code>async def custom_cdp_command(connection, method, params=None):\n    command = {\n        \"id\": random.randint(1, 10000),\n        \"method\": method,\n        \"params\": params or {}\n    }\n    return await connection.execute_command(command)\n\n# Example: Get document HTML without using Page class\nasync def get_html(connection):\n    result = await custom_cdp_command(\n        connection,\n        \"Runtime.evaluate\",\n        {\"expression\": \"document.documentElement.outerHTML\"}\n    )\n    return result['result']['result']['value']\n</code></pre> <p>Advanced Interface</p> <p>Direct use of the ConnectionHandler requires a deep understanding of the Chrome DevTools Protocol. For most use cases, the higher-level Browser and Page APIs provide a more intuitive and safer interface.</p>"},{"location":"deep-dive/connection-layer/#advanced-concurrency-patterns","title":"Advanced Concurrency Patterns","text":"<p>The ConnectionHandler's asynchronous design enables sophisticated concurrency patterns:</p>"},{"location":"deep-dive/connection-layer/#parallel-command-execution","title":"Parallel Command Execution","text":"<p>Execute multiple commands concurrently and wait for all results:</p> <pre><code>async def get_page_metrics(connection):\n    commands = [\n        {\"id\": 1, \"method\": \"Performance.getMetrics\"},\n        {\"id\": 2, \"method\": \"Network.getResponseBody\", \"params\": {\"requestId\": \"...\"}},\n        {\"id\": 3, \"method\": \"DOM.getDocument\"}\n    ]\n\n    results = await asyncio.gather(\n        *(connection.execute_command(cmd) for cmd in commands)\n    )\n\n    return results\n</code></pre>"},{"location":"deep-dive/connection-layer/#conclusion","title":"Conclusion","text":"<p>The ConnectionHandler serves as the foundation of Pydoll's architecture, providing a robust, efficient interface to the Chrome DevTools Protocol. By leveraging Python's asyncio framework and WebSocket communication, it enables high-performance browser automation with elegant, event-driven programming patterns.</p> <p>Understanding the ConnectionHandler's design and operation provides valuable insights into Pydoll's internal workings and offers opportunities for advanced customization and optimization in specialized scenarios.</p> <p>For most use cases, you'll interact with the ConnectionHandler indirectly through the higher-level Browser and Page APIs, which provide a more intuitive interface while leveraging the ConnectionHandler's powerful capabilities. </p>"},{"location":"deep-dive/event-system/","title":"Event System","text":"<p>The event system is a foundational component of Pydoll's architecture, providing a powerful mechanism for responding to browser activities in real-time. This asynchronous notification system enables your automation code to react to various browser events as they occur, creating dynamic and responsive interactions.</p>"},{"location":"deep-dive/event-system/#websocket-communication-and-cdp","title":"WebSocket Communication and CDP","text":"<p>At the core of Pydoll's event system is the Chrome DevTools Protocol (CDP), which provides a structured way to interact with and monitor browser activities over WebSocket connections. This bidirectional communication channel allows your code to both send commands to the browser and receive events back.</p> <pre><code>sequenceDiagram\n    participant Client as Pydoll Code\n    participant Connection as ConnectionHandler\n    participant WebSocket\n    participant Browser\n\n    Client-&gt;&gt;Connection: Register callback for event\n    Connection-&gt;&gt;Connection: Store callback in registry\n\n    Client-&gt;&gt;Connection: Enable event domain\n    Connection-&gt;&gt;WebSocket: Send CDP command to enable domain\n    WebSocket-&gt;&gt;Browser: Forward command\n    Browser--&gt;&gt;WebSocket: Acknowledge domain enabled\n    WebSocket--&gt;&gt;Connection: Forward response\n    Connection--&gt;&gt;Client: Domain enabled\n\n    Browser-&gt;&gt;WebSocket: Event occurs, sends CDP event message\n    WebSocket-&gt;&gt;Connection: Forward event message\n    Connection-&gt;&gt;Connection: Look up callbacks for this event\n    Connection-&gt;&gt;Client: Execute registered callback</code></pre>"},{"location":"deep-dive/event-system/#websocket-communication-model","title":"WebSocket Communication Model","text":"<p>The WebSocket connection between Pydoll and the browser follows this pattern:</p> <ol> <li>Connection Establishment: When the browser starts, a WebSocket server is created, and Pydoll establishes a connection to it</li> <li>Bidirectional Messaging: Both Pydoll and the browser can send messages at any time</li> <li>Message Types:</li> <li>Commands: Sent from Pydoll to the browser (e.g., navigation, DOM manipulation)</li> <li>Command Responses: Sent from the browser to Pydoll in response to commands</li> <li>Events: Sent from the browser to Pydoll when something happens (e.g., page load, network activity)</li> </ol>"},{"location":"deep-dive/event-system/#chrome-devtools-protocol-structure","title":"Chrome DevTools Protocol Structure","text":"<p>CDP organizes its functionality into domains, each responsible for a specific area of browser functionality:</p> Domain Responsibility Typical Events Page Page lifecycle Load events, navigation, dialogs Network Network activity Request/response monitoring, WebSockets DOM Document structure DOM changes, attribute modifications Fetch Request interception Request paused, authentication required Runtime JavaScript execution Console messages, exceptions Browser Browser management Window creation, tabs, contexts <p>Each domain must be explicitly enabled before it will emit events, which helps manage performance by only processing events that are actually needed.</p>"},{"location":"deep-dive/event-system/#event-domains-and-enabling","title":"Event Domains and Enabling","text":"<p>Pydoll organizes events into logical domains that correspond to the CDP domains. Each domain must be explicitly enabled before it will emit events, which is handled through specific enabling methods.</p> <pre><code># Enable page events to monitor page load, navigation, dialogs, etc.\nawait tab.enable_page_events()\n\n# Enable network events to monitor requests, responses, etc.\nawait tab.enable_network_events()\n\n# Enable DOM events to monitor DOM changes\nawait tab.enable_dom_events()\n\n# Enable fetch events to intercept and modify requests\nawait tab.enable_fetch_events()\n</code></pre> <p>Domain Ownership</p> <p>Events belong to specific domains based on their functionality. For example, page load events belong to the Page domain, while network request events belong to the Network domain. Some domains are only available at certain levels - for instance, Page events are available on the Tab instance but not directly at the Browser level.</p>"},{"location":"deep-dive/event-system/#why-enabledisable-is-required","title":"Why Enable/Disable is Required","text":"<p>The explicit enable/disable pattern serves several important purposes:</p> <ol> <li>Performance Optimization: By only enabling domains you're interested in, you reduce the overhead of event processing</li> <li>Resource Management: Some event domains (like Network or DOM monitoring) can generate large volumes of events that consume memory</li> <li>Clarity of Intent: Explicit enabling makes the automation code's intentions clear and self-documenting</li> <li>Controlled Cleanup: Explicitly disabling domains ensures proper cleanup when events are no longer needed</li> </ol> <pre><code>stateDiagram-v2\n    [*] --&gt; Disabled: Initial State\n    Disabled --&gt; Enabled: enable_xxx_events()\n    Enabled --&gt; Disabled: disable_xxx_events()\n    Enabled --&gt; [*]: Tab Closed\n    Disabled --&gt; [*]: Tab Closed</code></pre> <p>Event Leak Prevention</p> <p>Failing to disable event domains when they're no longer needed can lead to memory leaks and performance degradation, especially in long-running automation. Always disable event domains when you're done with them, particularly for high-volume events like network monitoring.</p>"},{"location":"deep-dive/event-system/#domain-specific-enabling-methods","title":"Domain-Specific Enabling Methods","text":"<p>Different domains are enabled through specific methods on the appropriate objects:</p> Domain Enable Method Disable Method Available On Page <code>enable_page_events()</code> <code>disable_page_events()</code> Tab Network <code>enable_network_events()</code> <code>disable_network_events()</code> Tab DOM <code>enable_dom_events()</code> <code>disable_dom_events()</code> Tab Fetch <code>enable_fetch_events()</code> <code>disable_fetch_events()</code> Tab, Browser File Chooser <code>enable_intercept_file_chooser_dialog()</code> <code>disable_intercept_file_chooser_dialog()</code> Tab"},{"location":"deep-dive/event-system/#registering-event-callbacks","title":"Registering Event Callbacks","text":"<p>The central method for subscribing to events is the <code>on()</code> method, available on both Tab and Browser instances:</p> <pre><code>async def on(\n    self, event_name: str, callback: callable, temporary: bool = False\n) -&gt; int:\n    \"\"\"\n    Registers an event listener for the tab.\n\n    Args:\n        event_name (str): The event name to listen for.\n        callback (callable): The callback function to execute when the\n            event is triggered.\n        temporary (bool): If True, the callback will be removed after it's\n            triggered once. Defaults to False.\n\n    Returns:\n        int: The ID of the registered callback.\n    \"\"\"\n</code></pre> <p>This method returns a callback ID that can be used to remove the callback later if needed.</p>"},{"location":"deep-dive/event-system/#callback-types-and-parameters","title":"Callback Types and Parameters","text":"<p>Callbacks can be either synchronous functions or asynchronous coroutines:</p> <pre><code># Synchronous callback example\ndef handle_page_load(event):\n    print(f\"Page loaded at: {time.time()}\")\n\n# Asynchronous callback example\nasync def handle_network_request(event):\n    request_url = event['params']['request']['url']\n    print(f\"Request sent to: {request_url}\")\n    # Can perform async operations here\n    await save_request_details(request_url)\n\n# Register the callbacks\nawait tab.on('Page.loadEventFired', handle_page_load)\nawait tab.on('Network.requestWillBeSent', handle_network_request)\n</code></pre> <p>Asynchronous Callbacks</p> <p>Using async callbacks provides greater flexibility, allowing you to perform other async operations within the callback, such as making additional CDP commands or waiting for conditions.</p>"},{"location":"deep-dive/event-system/#using-partial-for-tab-access-in-callbacks","title":"Using Partial for Tab Access in Callbacks","text":"<p>A powerful technique is to use <code>functools.partial</code> to pass the Tab instance to your callbacks, allowing the callback to interact with the tab:</p> <pre><code>from functools import partial\n\n# Define a callback that needs access to the tab\nasync def handle_navigation(tab, event):\n    # The callback can now use the tab object\n    print(f\"Navigation occurred to: {await tab.current_url}\")\n\n    # Access tab methods directly\n    elements = await tab.find(tag_name=\"a\")\n    print(f\"Found {len(elements)} links on the new page\")\n\n# Register with partial to bind the tab parameter\nawait tab.enable_page_events()\nawait tab.on(PageEvent.FRAME_NAVIGATED, partial(handle_navigation, tab))\n</code></pre> <p>This technique is essential when: 1. Your callback needs to interact with the tab (finding elements, executing scripts) 2. You want to maintain state between events 3. You need to coordinate actions across different event types</p> <p>Why Use Partial?</p> <p>The event system only passes the event data to callbacks. Using <code>partial</code> lets you pre-configure callbacks with additional parameters (like the tab object) without modifying the callback signature expected by the event system.</p>"},{"location":"deep-dive/event-system/#temporary-callbacks","title":"Temporary Callbacks","text":"<p>For events you only want to handle once, you can use the <code>temporary</code> flag:</p> <pre><code># This callback will automatically be removed after the first time it fires\nawait tab.on('Page.loadEventFired', handle_first_load, temporary=True)\n</code></pre> <p>This is particularly useful for: - One-time setup operations - Waiting for a specific event before continuing - Handling the first occurrence of an event differently</p>"},{"location":"deep-dive/event-system/#event-flow-and-lifecycle","title":"Event Flow and Lifecycle","text":"<p>Understanding the event flow is crucial for effective event handling:</p> <pre><code>flowchart TD\n    A[Browser Activity] --&gt;|Generates| B[CDP Event]\n    B --&gt;|Sent via WebSocket| C[ConnectionHandler]\n    C --&gt;|Filters by Event Name| D{Registered Callbacks?}\n    D --&gt;|Yes| E[Process Event]\n    D --&gt;|No| F[Discard Event]\n    E --&gt;|For Each Callback| G[Execute Callback]\n    G --&gt;|If Temporary| H[Remove Callback]\n    G --&gt;|If Permanent| I[Retain for Future Events]</code></pre> <p>The event lifecycle follows these steps:</p> <ol> <li>Something happens in the browser (page loads, request sent, DOM changes)</li> <li>Browser generates a CDP event message</li> <li>Message is sent over WebSocket to Pydoll</li> <li>The ConnectionHandler receives the event</li> <li>ConnectionHandler checks its registry for callbacks matching the event name</li> <li>If callbacks exist, each is executed with the event data</li> <li>If a callback was registered as temporary, it's removed after execution</li> </ol>"},{"location":"deep-dive/event-system/#predefined-event-constants","title":"Predefined Event Constants","text":"<p>Pydoll provides a comprehensive set of predefined event constants in the <code>protocol</code> package, making it easier to reference common events without remembering exact CDP event strings:</p> <pre><code>from pydoll.protocol.page.events import PageEvent\nfrom pydoll.protocol.network.events import NetworkEvent\nfrom pydoll.protocol.dom.events import DomEvent\nfrom pydoll.protocol.fetch.events import FetchEvent\n\n# Using predefined events\nawait tab.on(PageEvent.LOAD_EVENT_FIRED, handle_page_load)\nawait tab.on(NetworkEvent.REQUEST_WILL_BE_SENT, handle_request)\nawait tab.on(DomEvent.DOCUMENT_UPDATED, handle_dom_update)\nawait tab.on(FetchEvent.REQUEST_PAUSED, handle_fetch_intercept)\n</code></pre> <p>Custom CDP Events</p> <p>While Pydoll provides constants for common events, you can use any valid CDP event string directly. This is useful for less common events that don't have predefined constants:</p> <pre><code># Using a direct CDP event string\nawait tab.on('Security.certificateError', handle_cert_error)\n</code></pre>"},{"location":"deep-dive/event-system/#common-event-types","title":"Common Event Types","text":"<p>Here are some of the most useful events for automation and scraping:</p>"},{"location":"deep-dive/event-system/#page-events","title":"Page Events","text":"Constant CDP Event Description <code>PageEvent.LOAD_EVENT_FIRED</code> <code>Page.loadEventFired</code> Fired when the page load event is triggered <code>PageEvent.DOM_CONTENT_EVENT_FIRED</code> <code>Page.domContentEventFired</code> Fired when DOM content has been loaded <code>PageEvent.FILE_CHOOSER_OPENED</code> <code>Page.fileChooserOpened</code> Fired when a file picker dialog is shown <code>PageEvent.JAVASCRIPT_DIALOG_OPENING</code> <code>Page.javascriptDialogOpening</code> Fired when a JavaScript dialog is shown <code>PageEvent.FRAME_NAVIGATED</code> <code>Page.frameNavigated</code> Fired when a frame has navigated to a new URL"},{"location":"deep-dive/event-system/#network-events","title":"Network Events","text":"Constant CDP Event Description <code>NetworkEvent.REQUEST_WILL_BE_SENT</code> <code>Network.requestWillBeSent</code> Fired when a request is about to be sent <code>NetworkEvent.RESPONSE_RECEIVED</code> <code>Network.responseReceived</code> Fired when an HTTP response is received <code>NetworkEvent.LOADING_FAILED</code> <code>Network.loadingFailed</code> Fired when a request fails to load <code>NetworkEvent.LOADING_FINISHED</code> <code>Network.loadingFinished</code> Fired when a request has finished loading <code>NetworkEvent.WEB_SOCKET_FRAME_SENT</code> <code>Network.webSocketFrameSent</code> Fired when a WebSocket frame is sent"},{"location":"deep-dive/event-system/#dom-events","title":"DOM Events","text":"Constant CDP Event Description <code>DomEvent.DOCUMENT_UPDATED</code> <code>DOM.documentUpdated</code> Fired when the document is updated <code>DomEvent.SET_CHILD_NODES</code> <code>DOM.setChildNodes</code> Fired when child nodes are set <code>DomEvent.ATTRIBUTE_MODIFIED</code> <code>DOM.attributeModified</code> Fired when an element's attribute is modified <code>DomEvent.ATTRIBUTE_REMOVED</code> <code>DOM.attributeRemoved</code> Fired when an element's attribute is removed"},{"location":"deep-dive/event-system/#advanced-event-patterns","title":"Advanced Event Patterns","text":""},{"location":"deep-dive/event-system/#event-driven-scraping","title":"Event-Driven Scraping","text":"<p>Events allow you to create reactive scrapers that respond to page changes in real-time:</p> <pre><code>import asyncio\nfrom functools import partial\nfrom pydoll.browser.chromium import Chrome\nfrom pydoll.constants import By\nfrom pydoll.protocol.network.events import NetworkEvent\nfrom pydoll.protocol.page.events import PageEvent\n\nasync def scrape_dynamic_content():\n    async with Chrome() as browser:\n        tab = await browser.start()\n\n        # Create a data storage container\n        scraped_data = []\n        data_complete = asyncio.Event()\n\n        # Set up a callback to extract data when AJAX responses are received\n        async def extract_data_from_response(tab, event):\n            if 'api/products' in event['params']['response']['url']:\n                # Extract the response body\n                request_id = event['params']['requestId']\n                body = await tab.get_network_response_body(request_id)\n\n                # Process the data\n                products = json.loads(body)\n                for product in products:\n                    scraped_data.append({\n                        'id': product['id'],\n                        'name': product['name'],\n                        'price': product['price']\n                    })\n\n                print(f\"Extracted {len(products)} products\")\n\n                # If we've collected enough data, signal completion\n                if len(scraped_data) &gt;= 100:\n                    data_complete.set()\n\n        # Set up navigation monitoring\n        async def handle_page_load(tab, event):\n            print(f\"Page loaded: {await tab.current_url}\")\n\n            # Now that the page is loaded, trigger the infinite scroll\n            await tab.execute_script(\"\"\"\n                function scrollDown() {\n                    window.scrollTo(0, document.body.scrollHeight);\n                    setTimeout(scrollDown, 1000);\n                }\n                scrollDown();\n            \"\"\")\n\n        # Enable events and register callbacks\n        await tab.enable_network_events()\n        await tab.enable_page_events()\n        await tab.on(NetworkEvent.RESPONSE_RECEIVED, partial(extract_data_from_response, tab))\n        await tab.on(PageEvent.LOAD_EVENT_FIRED, partial(handle_page_load, tab))\n\n        # Navigate to the page with dynamic content\n        await tab.go_to(\"https://example.com/products\")\n\n        # Wait for data collection to complete or timeout after 60 seconds\n        try:\n            await asyncio.wait_for(data_complete.wait(), timeout=60)\n        except asyncio.TimeoutError:\n            print(\"Timeout reached, continuing with data collected so far\")\n\n        # Process the collected data\n        print(f\"Total products collected: {len(scraped_data)}\")\n\n        return scraped_data\n</code></pre>"},{"location":"deep-dive/event-system/#parallel-scraping-with-events","title":"Parallel Scraping with Events","text":"<p>Events are particularly powerful when combined with concurrent execution for maximum efficiency. Pydoll excels at managing multiple Tabs simultaneously, which is one of its greatest advantages for high-performance automation.</p>"},{"location":"deep-dive/event-system/#multi-tab-single-browser-approach","title":"Multi-Tab Single Browser Approach","text":"<p>A more efficient approach is to use multiple tabs within a single browser instance:</p> <pre><code>import asyncio\nfrom functools import partial\nimport json\nfrom pydoll.browser.chromium import Chrome\nfrom pydoll.constants import By\nfrom pydoll.protocol.network.events import NetworkEvent\n\nasync def multi_tab_scraping():\n    # Create a single browser instance for all tabs\n    async with Chrome() as browser:\n        tab = await browser.start()\n\n        # Categories to scrape\n        categories = ['electronics', 'clothing', 'books', 'home']\n        base_url = 'https://example.com/products'\n\n        # Track results for each category\n        results = {category: [] for category in categories}\n        completion_events = {category: asyncio.Event() for category in categories}\n\n        # Create a callback for processing category data\n        async def process_category_data(tab, category, event):\n            if f'api/{category}' in event['params'].get('response', {}).get('url', ''):\n                request_id = event['params']['requestId']\n                body, _ = await tab.get_network_response_body(request_id)\n                data = json.loads(body)\n\n                # Add results to the appropriate category\n                results[category].extend(data['items'])\n                print(f\"Added {len(data['items'])} items to {category}, total: {len(results[category])}\")\n\n                # Signal completion if we have enough data\n                if len(results[category]) &gt;= 20 or data.get('isLastPage', False):\n                    completion_events[category].set()\n\n        # Prepare tabs, one for each category\n        tabs = {}\n        for category in categories:\n            # Create a new tab\n            new_tab = await browser.new_tab()\n            tabs[category] = new_tab\n\n            # Setup event monitoring for this tab\n            await new_tab.enable_network_events()\n            await new_tab.on(\n                NetworkEvent.RESPONSE_RECEIVED,\n                partial(process_category_data, new_tab, category)\n            )\n\n            # Start navigation (don't await here to allow parallel loading)\n            asyncio.create_task(new_tab.go_to(f\"{base_url}/{category}\"))\n\n        # Wait for all categories to complete or timeout\n        try:\n            await asyncio.wait_for(\n                asyncio.gather(*(event.wait() for event in completion_events.values())),\n                timeout=45\n            )\n        except asyncio.TimeoutError:\n            print(\"Some categories timed out, proceeding with collected data\")\n\n        # Display results\n        total_items = 0\n        for category, items in results.items():\n            count = len(items)\n            total_items += count\n            print(f\"{category}: collected {count} items\")\n\n            # Show sample items\n            for item in items[:2]:\n                print(f\"  - {item['name']}: ${item['price']}\")\n\n        print(f\"Total items across all categories: {total_items}\")\n\n        return results\n\n# Run the multi-tab scraper\nasyncio.run(multi_tab_scraping())\n</code></pre>"},{"location":"deep-dive/event-system/#dynamic-tab-creation-with-events","title":"Dynamic Tab Creation with Events","text":"<p>You can even create new tabs dynamically in response to events:</p> <pre><code>import asyncio\nfrom functools import partial\nfrom pydoll.browser.chromium import Chrome\nfrom pydoll.constants import By\nfrom pydoll.protocol.page.events import PageEvent\nfrom pydoll.protocol.network.events import NetworkEvent\n\nasync def dynamic_tab_creation():\n    async with Chrome() as browser:\n        main_tab = await browser.start()\n\n        # Store results from all product pages\n        all_results = []\n        # Count active tabs to know when we're done\n        active_tabs = 1  # Start with 1 (main tab)\n        # Event that signals all work is complete\n        all_done = asyncio.Event()\n\n        # This callback processes category links and creates a new tab for each\n        async def process_category_links(main_tab, event):\n            # Check if this is the categories response\n            if 'api/categories' not in event['params'].get('response', {}).get('url', ''):\n                return\n\n            # Extract categories from the response\n            request_id = event['params']['requestId']\n            body = await main_tab.get_network_response_body(request_id)\n            categories = json.loads(body)\n\n            print(f\"Found {len(categories)} categories to process\")\n            nonlocal active_tabs\n            active_tabs += len(categories)  # Update tab counter\n\n            # Create a new tab for each category\n            for category in categories:\n                # Create a new tab\n                new_tab = await browser.new_tab()\n\n                # Setup a callback for this tab\n                async def process_product_data(tab, category_name, event):\n                    if 'api/products' not in event['params'].get('response', {}).get('url', ''):\n                        return\n\n                    # Process the product data\n                    request_id = event['params']['requestId']\n                    body = await tab.get_network_response_body(request_id)\n                    products = json.loads(body)\n\n                    # Add to results\n                    nonlocal all_results\n                    all_results.extend(products)\n                    print(f\"Added {len(products)} products from {category_name}\")\n\n                    # Close this tab when done\n                    nonlocal active_tabs\n                    await tab.close()\n                    active_tabs -= 1\n\n                    # If this was the last tab, signal completion\n                    if active_tabs == 0:\n                        all_done.set()\n\n                # Enable network events on the new tab\n                await new_tab.enable_network_events()\n                await new_tab.on(\n                    NetworkEvent.RESPONSE_RECEIVED,\n                    partial(process_product_data, new_tab, category['name'])\n                )\n\n                # Navigate to the category page\n                asyncio.create_task(new_tab.go_to(f\"https://example.com/products/{category['id']}\"))\n\n        # Set up the main tab to find categories\n        await main_tab.enable_network_events()\n        await main_tab.on(\n            NetworkEvent.RESPONSE_RECEIVED,\n            partial(process_category_links, main_tab)\n        )\n\n        # Navigate to the main categories page\n        await main_tab.go_to(\"https://example.com/categories\")\n\n        # Wait for all tabs to complete their work\n        try:\n            await asyncio.wait_for(all_done.wait(), timeout=60)\n        except asyncio.TimeoutError:\n            print(\"Timeout reached, continuing with data collected so far\")\n\n        # Process results\n        print(f\"Total products collected: {len(all_results)}\")\n\n        return all_results\n</code></pre>"},{"location":"deep-dive/event-system/#key-advantages-of-multi-tab-automation","title":"Key Advantages of Multi-Tab Automation","text":"<p>Using multiple tabs in a single browser instance offers several significant advantages:</p> <ol> <li>Resource Efficiency: A single browser instance uses fewer system resources than multiple browsers</li> <li>Shared Session: All tabs share the same session, cookies, and cache</li> <li>Reduced Startup Time: Opening new tabs is much faster than starting new browser instances</li> <li>Dynamic Workflows: Create tabs in response to discoveries on other tabs</li> <li>Memory Efficiency: Better memory utilization compared to multiple browser instances</li> </ol> <p>Tab Management Best Practices</p> <ul> <li>Keep track of all tab references to avoid orphaned tabs</li> <li>Consider implementing a tab pool pattern for large-scale operations</li> <li>Close tabs when they're no longer needed to free up resources</li> <li>Use tab IDs to identify and organize tabs</li> <li>Consider adding timeouts to prevent hanging tabs</li> </ul> <p>This multi-tab approach is ideal for scenarios like: - Category-based scraping where each category needs its own context - Processing search results where each result needs detailed exploration - Following multiple user journeys simultaneously - Load balancing requests across multiple tabs to avoid rate limiting - Maintaining different user sessions in different tabs</p>"},{"location":"deep-dive/event-system/#coordinating-with-event-driven-actions","title":"Coordinating with Event-Driven Actions","text":"<p>Events can be used to coordinate actions in response to browser behavior:</p> <pre><code>async def wait_for_network_idle():\n    network_idle = asyncio.Event()\n    in_flight_requests = 0\n\n    async def track_request(event):\n        nonlocal in_flight_requests\n        in_flight_requests += 1\n\n    async def track_response(event):\n        nonlocal in_flight_requests\n        in_flight_requests -= 1\n        if in_flight_requests == 0:\n            network_idle.set()\n\n    await tab.enable_network_events()\n    await tab.on(NetworkEvent.REQUEST_WILL_BE_SENT, track_request)\n    await tab.on(NetworkEvent.LOADING_FINISHED, track_response)\n    await tab.on(NetworkEvent.LOADING_FAILED, track_response)\n\n    await network_idle.wait()\n\n    # Clean up\n    await tab.disable_network_events()\n</code></pre>"},{"location":"deep-dive/event-system/#using-async-context-managers","title":"Using Async Context Managers","text":"<p>Pydoll implements context managers for some common event patterns, like file uploads:</p> <pre><code>async with tab.expect_file_chooser(files=\"path/to/file.pdf\"):\n    # Trigger the file chooser dialog\n    upload_button = await tab.find(id=\"upload-button\")\n    await upload_button.click()\n    # Context manager handles waiting for and responding to the file chooser event\n</code></pre> <p>Creating Custom Context Managers</p> <p>You can create custom context managers for common event patterns in your own code:</p> <pre><code>@asynccontextmanager\nasync def wait_for_navigation():\n    navigation_complete = asyncio.Event()\n\n    async def on_navigation(event):\n        navigation_complete.set()\n\n    # Enable events if not already enabled\n    was_enabled = tab.page_events_enabled\n    if not was_enabled:\n        await tab.enable_page_events()\n\n    # Register temporary callback\n    await tab.on(PageEvent.FRAME_NAVIGATED, on_navigation, temporary=True)\n\n    try:\n        yield\n        # Wait for navigation to complete\n        await navigation_complete.wait()\n    finally:\n        # Clean up if we enabled events\n        if not was_enabled:\n            await tab.disable_page_events()\n</code></pre>"},{"location":"deep-dive/event-system/#domain-specific-event-features","title":"Domain-Specific Event Features","text":""},{"location":"deep-dive/event-system/#page-domain-events","title":"Page Domain Events","text":"<p>The Page domain provides events for page lifecycle and JavaScript dialogs:</p> <pre><code>from functools import partial\n\n# Enable page events\nawait tab.enable_page_events()\n\n# Handle page load\nasync def handle_page_load(tab, event):\n    print(f\"Page loaded: {await tab.current_url}\")\n    # Perform actions after page load\n    await tab.find(id=\"search\").type_text(\"pydoll\")\n\nawait tab.on(PageEvent.LOAD_EVENT_FIRED, partial(handle_page_load, tab))\n\n# Handle JavaScript dialogs\nasync def handle_dialog(tab, event):\n    if await tab.has_dialog():\n        message = await tab.get_dialog_message()\n        print(f\"Dialog message: {message}\")\n        await tab.handle_dialog(accept=True)\n\nawait tab.on(PageEvent.JAVASCRIPT_DIALOG_OPENING, partial(handle_dialog, tab))\n</code></pre>"},{"location":"deep-dive/event-system/#network-domain-events-and-logging","title":"Network Domain Events and Logging","text":"<p>The Network domain provides comprehensive request monitoring and logging:</p> <pre><code>from functools import partial\n\n# Enable network events\nawait tab.enable_network_events()\n\n# Monitor request activity\nasync def log_request(tab, event):\n    url = event['params']['request']['url']\n    method = event['params']['request']['method']\n    print(f\"{method} request to: {url}\")\n\n    # You can trigger actions based on specific requests\n    if 'api/login' in url and method == 'POST':\n        print(\"Login request detected, waiting for response...\")\n\nawait tab.on(NetworkEvent.REQUEST_WILL_BE_SENT, partial(log_request, tab))\n\n# After performing actions, retrieve logs\napi_logs = await tab.get_network_logs(filter=\"api\")\n\n# Get response bodies for specific requests by filtering logs first\napi_logs = await tab.get_network_logs(filter=\"api/data\")\nfor log in api_logs:\n    request_id = log['params']['requestId']\n    body = await tab.get_network_response_body(request_id)\n</code></pre>"},{"location":"deep-dive/event-system/#dom-events-for-structure-monitoring","title":"DOM Events for Structure Monitoring","text":"<p>The DOM domain provides events for monitoring document structure changes:</p> <pre><code>from functools import partial\n\n# Enable DOM events\nawait tab.enable_dom_events()\n\n# Track attribute changes\nasync def track_attribute_change(tab, event):\n    node_id = event['params']['nodeId']\n    name = event['params']['name']\n    value = event['params']['value']\n    print(f\"Attribute changed on node {node_id}: {name}={value}\")\n\n    # You can react to specific attribute changes\n    if name == 'data-status' and value == 'loaded':\n        element = await tab.find(css_selector=f\"[data-id='{node_id}']\")\n        await element.click()\n\nawait tab.on(DomEvent.ATTRIBUTE_MODIFIED, partial(track_attribute_change, tab))\n</code></pre>"},{"location":"deep-dive/event-system/#browser-level-vs-tab-level-events","title":"Browser-Level vs. Tab-Level Events","text":"<p>Pydoll's event system operates at both the browser and tab levels, with important distinctions:</p> <pre><code>graph TD\n    Browser[Browser Instance] --&gt;|\"Global Events (e.g., Target events)\"| BrowserCallbacks[Browser-Level Callbacks]\n    Browser --&gt;|\"Creates\"| Tab1[Tab Instance 1]\n    Browser --&gt;|\"Creates\"| Tab2[Tab Instance 2]\n    Tab1 --&gt;|\"Tab-Specific Events\"| Tab1Callbacks[Tab 1 Callbacks]\n    Tab2 --&gt;|\"Tab-Specific Events\"| Tab2Callbacks[Tab 2 Callbacks]</code></pre>"},{"location":"deep-dive/event-system/#browser-level-events","title":"Browser-Level Events","text":"<p>Browser-level events operate globally across all tabs:</p> <pre><code># Register a browser-level event\nawait browser.on('Target.targetCreated', handle_new_target)\n</code></pre> <p>Browser-level event domains are limited, and trying to use tab-specific events will raise an exception:</p> <pre><code># This would raise an EventNotSupported exception\nawait browser.on(PageEvent.LOAD_EVENT_FIRED, handle_page_load)  # Error!\n</code></pre>"},{"location":"deep-dive/event-system/#tab-level-events","title":"Tab-Level Events","text":"<p>Tab-level events are specific to an individual tab:</p> <pre><code># Get a specific tab\ntab = await browser.start()\n\n# Register a tab-level event\nawait tab.enable_page_events()\nawait tab.on(PageEvent.LOAD_EVENT_FIRED, handle_page_load)\n\n# Each tab has its own event context\ntab2 = await browser.new_tab()\nawait tab2.enable_page_events()\nawait tab2.on(PageEvent.LOAD_EVENT_FIRED, handle_different_page_load)\n</code></pre> <p>Domain-Specific Scope</p> <p>Not all event domains are available at both levels. For example:</p> <ul> <li>Fetch Events: Available at both browser and tab levels</li> <li>Page Events: Available only at the tab level</li> <li>Target Events: Available only at the browser level</li> </ul>"},{"location":"deep-dive/event-system/#performance-considerations","title":"Performance Considerations","text":""},{"location":"deep-dive/event-system/#event-system-overhead","title":"Event System Overhead","text":"<p>The event system adds overhead to browser automation, especially for high-frequency events:</p> Event Domain Typical Event Volume Performance Impact Page Low Minimal Network High Moderate to High DOM Very High High Fetch Moderate Moderate (higher if intercepting) <p>To minimize performance impact:</p> <ol> <li>Enable Only What You Need: Only enable event domains you're actively using</li> <li>Scope Appropriately: Use browser-level events only for truly browser-wide concerns</li> <li>Disable When Done: Always disable event domains when you're finished with them</li> <li>Filter Early: In callbacks, filter out irrelevant events as early as possible</li> <li>Use Temporary Callbacks: For one-time events, use the <code>temporary=True</code> flag</li> </ol>"},{"location":"deep-dive/event-system/#efficient-callback-patterns","title":"Efficient Callback Patterns","text":"<p>Write efficient callbacks to minimize overhead:</p> <pre><code># LESS EFFICIENT: Processes every request\nasync def log_all_requests(event):\n    print(f\"Request: {event['params']['request']['url']}\")\n\n# MORE EFFICIENT: Early filtering\nasync def log_api_requests(event):\n    url = event['params']['request']['url']\n    if '/api/' not in url:\n        return  # Early exit for non-API requests\n    print(f\"API Request: {url}\")\n</code></pre>"},{"location":"deep-dive/event-system/#conclusion","title":"Conclusion","text":"<p>Pydoll's event system provides a powerful mechanism for creating dynamic, responsive browser automation. By understanding the event flow, domain organization, and callback patterns, you can build sophisticated automation that reacts intelligently to browser state changes.</p> <p>The event system is particularly valuable for: - Building reactive scrapers that capture data as soon as it's available - Creating parallel automation tasks that maximize efficiency - Coordinating complex interactions that depend on browser state changes - Implementing robust error handling and retry mechanisms</p> <p>With techniques like using <code>partial</code> to bind tab instances to callbacks and combining events with <code>asyncio.gather</code> for concurrent operations, you can create highly efficient and scalable automation solutions.</p>"},{"location":"deep-dive/find-elements-mixin/","title":"FindElements Mixin","text":"<p>The FindElementsMixin is a fundamental component in Pydoll's architecture that implements element location strategies using various selector types. This mixin provides the core capabilities for finding and interacting with elements in the DOM, serving as a bridge between high-level automation code and the browser's rendering engine.</p> <pre><code>graph TB\n    User[\"User Code\"] --&gt; Tab[\"Tab Class\"]\n    Tab --&gt; Mixin[\"FindElementsMixin\"]\n    Mixin --&gt; Methods[\"Core Methods\"]\n    Mixin --&gt; Wait[\"Wait Mechanisms\"]\n\n    Methods --&gt; Find[\"find()\"]\n    Methods --&gt; Query[\"query()\"]\n    Methods --&gt; Internal[\"Internal Methods\"]\n\n    Mixin --&gt; DOM[\"Browser DOM\"]\n    DOM --&gt; Elements[\"WebElements\"]</code></pre>"},{"location":"deep-dive/find-elements-mixin/#understanding-mixins-in-python","title":"Understanding Mixins in Python","text":"<p>In object-oriented programming, a mixin is a class that provides methods to other classes without being considered a base class. Unlike traditional inheritance where a subclass inherits from a parent class representing an \"is-a\" relationship, mixins implement a \"has-a\" capability relationship.</p> <pre><code># Example of a mixin in Python\nclass LoggerMixin:\n    def log(self, message):\n        print(f\"LOG: {message}\")\n\n    def log_error(self, error):\n        print(f\"ERROR: {error}\")\n\nclass DataProcessor(LoggerMixin):\n    def process_data(self, data):\n        self.log(\"Processing data...\")\n        # Process the data\n        self.log(\"Data processing complete\")\n</code></pre> <p>Mixins offer several advantages in complex software architecture:</p> <ol> <li>Code Reuse: The same functionality can be used by multiple unrelated classes</li> <li>Separation of Concerns: Each mixin handles a specific aspect of functionality</li> <li>Composition Over Inheritance: Avoids deep inheritance hierarchies</li> <li>Modularity: Features can be added or removed independently</li> </ol> <p>Mixin vs. Multiple Inheritance</p> <p>While Python supports multiple inheritance, mixins are a specific design pattern within that capability. A mixin is not meant to be instantiated on its own and typically doesn't maintain state. It provides methods that can be used by other classes without establishing an \"is-a\" relationship.</p>"},{"location":"deep-dive/find-elements-mixin/#the-document-object-model-dom","title":"The Document Object Model (DOM)","text":"<p>Before diving into element selection strategies, it's important to understand the DOM, which represents the structure of an HTML document as a tree of objects.</p> <pre><code>graph TD\n    A[Document] --&gt; B[html]\n    B --&gt; C[head]\n    B --&gt; D[body]\n    C --&gt; E[title]\n    D --&gt; F[div id='content']\n    F --&gt; G[h1]\n    F --&gt; H[p]\n    F --&gt; I[ul]\n    I --&gt; J[li]\n    I --&gt; K[li]\n    I --&gt; L[li]</code></pre> <p>The DOM is:</p> <ol> <li>Hierarchical: Elements nest within other elements, forming parent-child relationships</li> <li>Manipulable: JavaScript can modify the structure, content, and styling</li> <li>Queryable: Elements can be located using various selection strategies</li> <li>Event-driven: Elements can respond to user interactions and other events</li> </ol>"},{"location":"deep-dive/find-elements-mixin/#chrome-devtools-protocol-and-dom-access","title":"Chrome DevTools Protocol and DOM Access","text":"<p>Pydoll interacts with the DOM through the Chrome DevTools Protocol (CDP), which provides methods for querying and manipulating the document:</p> CDP Domain Purpose Example Commands DOM Access to document structure <code>querySelector</code>, <code>getDocument</code> Runtime JavaScript execution in page context <code>evaluate</code>, <code>callFunctionOn</code> Page Page-level operations <code>navigate</code>, <code>captureScreenshot</code> <p>The CDP allows both direct DOM manipulation through the DOM domain and JavaScript-based interaction through the Runtime domain. FindElementsMixin leverages both approaches for robust element selection.</p>"},{"location":"deep-dive/find-elements-mixin/#core-api-methods","title":"Core API Methods","text":"<p>Pydoll introduces two primary methods for element finding that provide a more intuitive and flexible approach:</p>"},{"location":"deep-dive/find-elements-mixin/#the-find-method","title":"The find() Method","text":"<p>The <code>find()</code> method provides an intuitive way to locate elements using common HTML attributes:</p> <pre><code># Find by ID\nelement = await tab.find(id=\"username\")\n\n# Find by class name\nelement = await tab.find(class_name=\"submit-button\")\n\n# Find by tag name\nelement = await tab.find(tag_name=\"button\")\n\n# Find by text content\nelement = await tab.find(text=\"Click here\")\n\n# Find by name attribute\nelement = await tab.find(name=\"email\")\n\n# Combine multiple attributes\nelement = await tab.find(tag_name=\"input\", name=\"password\", type=\"password\")\n\n# Find all matching elements\nelements = await tab.find(class_name=\"item\", find_all=True)\n\n# Find with timeout\nelement = await tab.find(id=\"dynamic-content\", timeout=10)\n</code></pre>"},{"location":"deep-dive/find-elements-mixin/#method-signature","title":"Method Signature","text":"<pre><code>async def find(\n    self,\n    id: Optional[str] = None,\n    class_name: Optional[str] = None,\n    name: Optional[str] = None,\n    tag_name: Optional[str] = None,\n    text: Optional[str] = None,\n    timeout: int = 0,\n    find_all: bool = False,\n    raise_exc: bool = True,\n    **attributes,\n) -&gt; Union[WebElement, list[WebElement], None]:\n</code></pre>"},{"location":"deep-dive/find-elements-mixin/#parameters","title":"Parameters","text":"Parameter Type Description <code>id</code> <code>Optional[str]</code> Element ID attribute value <code>class_name</code> <code>Optional[str]</code> CSS class name to match <code>name</code> <code>Optional[str]</code> Element name attribute value <code>tag_name</code> <code>Optional[str]</code> HTML tag name (e.g., \"div\", \"input\") <code>text</code> <code>Optional[str]</code> Text content to match within element <code>timeout</code> <code>int</code> Maximum seconds to wait for elements to appear <code>find_all</code> <code>bool</code> If True, returns all matches; if False, first match only <code>raise_exc</code> <code>bool</code> Whether to raise exception if no elements found <code>**attributes</code> <code>dict</code> Additional HTML attributes to match"},{"location":"deep-dive/find-elements-mixin/#the-query-method","title":"The query() Method","text":"<p>The <code>query()</code> method provides direct access using CSS selectors or XPath expressions:</p> <pre><code># CSS selectors\nelement = await tab.query(\"div.content &gt; p.intro\")\nelement = await tab.query(\"#login-form input[type='password']\")\n\n# XPath expressions\nelement = await tab.query(\"//div[@id='content']/p[contains(text(), 'Welcome')]\")\nelement = await tab.query(\"//button[text()='Submit']\")\n\n# ID shorthand (automatically detected)\nelement = await tab.query(\"#username\")\n\n# Class shorthand (automatically detected)\nelement = await tab.query(\".submit-button\")\n\n# Find all matching elements\nelements = await tab.query(\"div.item\", find_all=True)\n\n# Query with timeout\nelement = await tab.query(\"#dynamic-content\", timeout=10)\n</code></pre>"},{"location":"deep-dive/find-elements-mixin/#method-signature_1","title":"Method Signature","text":"<pre><code>async def query(\n    self, \n    expression: str, \n    timeout: int = 0, \n    find_all: bool = False, \n    raise_exc: bool = True\n) -&gt; Union[WebElement, list[WebElement], None]:\n</code></pre>"},{"location":"deep-dive/find-elements-mixin/#parameters_1","title":"Parameters","text":"Parameter Type Description <code>expression</code> <code>str</code> Selector expression (CSS, XPath, ID with #, class with .) <code>timeout</code> <code>int</code> Maximum seconds to wait for elements to appear <code>find_all</code> <code>bool</code> If True, returns all matches; if False, first match only <code>raise_exc</code> <code>bool</code> Whether to raise exception if no elements found"},{"location":"deep-dive/find-elements-mixin/#practical-usage-examples","title":"Practical Usage Examples","text":""},{"location":"deep-dive/find-elements-mixin/#basic-element-finding","title":"Basic Element Finding","text":"<pre><code>import asyncio\nfrom pydoll.browser.chromium import Chrome\n\nasync def basic_element_finding():\n    browser = Chrome()\n    tab = await browser.start()\n\n    try:\n        await tab.go_to(\"https://example.com/login\")\n\n        # Find login form elements\n        username_field = await tab.find(id=\"username\")\n        password_field = await tab.find(name=\"password\")\n        submit_button = await tab.find(tag_name=\"button\", type=\"submit\")\n\n        # Interact with elements\n        await username_field.type_text(\"user@example.com\")\n        await password_field.type_text(\"password123\")\n        await submit_button.click()\n\n    finally:\n        await browser.stop()\n\nasyncio.run(basic_element_finding())\n</code></pre>"},{"location":"deep-dive/find-elements-mixin/#advanced-selector-combinations","title":"Advanced Selector Combinations","text":"<pre><code>async def advanced_selectors():\n    browser = Chrome()\n    tab = await browser.start()\n\n    try:\n        await tab.go_to(\"https://example.com/products\")\n\n        # Find specific product by combining attributes\n        product = await tab.find(\n            tag_name=\"div\",\n            class_name=\"product\",\n            data_category=\"electronics\",\n            data_price_range=\"500-1000\"\n        )\n\n        # Find all products in a category\n        electronics = await tab.find(\n            class_name=\"product\",\n            data_category=\"electronics\",\n            find_all=True\n        )\n\n        # Find element by text content\n        add_to_cart = await tab.find(text=\"Add to Cart\")\n\n        print(f\"Found {len(electronics)} electronics products\")\n\n    finally:\n        await browser.stop()\n</code></pre>"},{"location":"deep-dive/find-elements-mixin/#using-css-selectors-and-xpath","title":"Using CSS Selectors and XPath","text":"<pre><code>async def css_and_xpath_examples():\n    browser = Chrome()\n    tab = await browser.start()\n\n    try:\n        await tab.go_to(\"https://example.com/table\")\n\n        # CSS selectors\n        header_cells = await tab.query(\"table thead th\", find_all=True)\n        first_row = await tab.query(\"table tbody tr:first-child\")\n\n        # XPath for complex selections\n        # Find table cell containing specific text\n        price_cell = await tab.query(\"//td[contains(text(), '$')]\")\n\n        # Find button in the same row as specific text\n        edit_button = await tab.query(\n            \"//tr[td[contains(text(), 'John Doe')]]//button[text()='Edit']\"\n        )\n\n        # Find all rows with price &gt; $100 (using XPath functions)\n        expensive_items = await tab.query(\n            \"//tr[number(translate(td[3], '$,', '')) &gt; 100]\",\n            find_all=True\n        )\n\n        print(f\"Found {len(expensive_items)} expensive items\")\n\n    finally:\n        await browser.stop()\n</code></pre>"},{"location":"deep-dive/find-elements-mixin/#waiting-mechanisms","title":"Waiting Mechanisms","text":"<p>The FindElementsMixin implements sophisticated waiting mechanisms for handling dynamic content:</p>"},{"location":"deep-dive/find-elements-mixin/#timeout-based-waiting","title":"Timeout-Based Waiting","text":"<pre><code>async def waiting_examples():\n    browser = Chrome()\n    tab = await browser.start()\n\n    try:\n        await tab.go_to(\"https://example.com/dynamic\")\n\n        # Wait up to 10 seconds for element to appear\n        dynamic_content = await tab.find(id=\"dynamic-content\", timeout=10)\n\n        # Wait for multiple elements\n        items = await tab.find(class_name=\"item\", timeout=5, find_all=True)\n\n        # Handle cases where element might not appear\n        optional_element = await tab.find(\n            id=\"optional-banner\", \n            timeout=3, \n            raise_exc=False\n        )\n\n        if optional_element:\n            await optional_element.click()\n        else:\n            print(\"Optional banner not found, continuing...\")\n\n    finally:\n        await browser.stop()\n</code></pre>"},{"location":"deep-dive/find-elements-mixin/#error-handling-strategies","title":"Error Handling Strategies","text":"<pre><code>async def robust_element_finding():\n    browser = Chrome()\n    tab = await browser.start()\n\n    try:\n        await tab.go_to(\"https://example.com\")\n\n        # Strategy 1: Try multiple selectors\n        submit_button = None\n        selectors = [\n            {\"id\": \"submit\"},\n            {\"class_name\": \"submit-btn\"},\n            {\"tag_name\": \"button\", \"type\": \"submit\"},\n            {\"text\": \"Submit\"}\n        ]\n\n        for selector in selectors:\n            try:\n                submit_button = await tab.find(**selector, timeout=2)\n                break\n            except ElementNotFound:\n                continue\n\n        if not submit_button:\n            raise Exception(\"Submit button not found with any selector\")\n\n        # Strategy 2: Graceful degradation\n        try:\n            premium_feature = await tab.find(class_name=\"premium-only\", timeout=1)\n            await premium_feature.click()\n        except ElementNotFound:\n            # Fall back to basic feature\n            basic_feature = await tab.find(class_name=\"basic-feature\")\n            await basic_feature.click()\n\n    finally:\n        await browser.stop()\n</code></pre>"},{"location":"deep-dive/find-elements-mixin/#selector-strategy-selection","title":"Selector Strategy Selection","text":"<p>The FindElementsMixin automatically chooses the most appropriate selector strategy based on the provided parameters:</p>"},{"location":"deep-dive/find-elements-mixin/#single-attribute-selection","title":"Single Attribute Selection","text":"<p>When only one attribute is provided, the mixin uses the most efficient selector:</p> <pre><code># These use optimized single-attribute selectors\nawait tab.find(id=\"username\")           # Uses By.ID\nawait tab.find(class_name=\"button\")     # Uses By.CLASS_NAME  \nawait tab.find(tag_name=\"input\")        # Uses By.TAG_NAME\nawait tab.find(name=\"email\")            # Uses By.NAME\n</code></pre>"},{"location":"deep-dive/find-elements-mixin/#multiple-attribute-selection","title":"Multiple Attribute Selection","text":"<p>When multiple attributes are provided, the mixin builds an XPath expression:</p> <pre><code># This builds XPath: //input[@type='password' and @name='password']\nawait tab.find(tag_name=\"input\", type=\"password\", name=\"password\")\n\n# This builds XPath: //div[@class='product' and @data-id='123']\nawait tab.find(tag_name=\"div\", class_name=\"product\", data_id=\"123\")\n</code></pre>"},{"location":"deep-dive/find-elements-mixin/#expression-type-detection","title":"Expression Type Detection","text":"<p>The <code>query()</code> method automatically detects the expression type:</p> <pre><code># Detected as XPath (starts with //)\nawait tab.query(\"//div[@id='content']\")\n\n# Detected as ID (starts with #)\nawait tab.query(\"#username\")\n\n# Detected as class (starts with . but not ./)\nawait tab.query(\".submit-button\")\n\n# Detected as CSS selector (default)\nawait tab.query(\"div.content &gt; p\")\n</code></pre>"},{"location":"deep-dive/find-elements-mixin/#internal-architecture","title":"Internal Architecture","text":"<p>The FindElementsMixin implements element location through a sophisticated internal architecture:</p> <pre><code>classDiagram\n    class FindElementsMixin {\n        +find(**kwargs) WebElement|List[WebElement]\n        +query(expression) WebElement|List[WebElement]\n        +find_or_wait_element(by, value, timeout) WebElement|List[WebElement]\n        -_find_element(by, value) WebElement\n        -_find_elements(by, value) List[WebElement]\n        -_get_by_and_value(**kwargs) Tuple[By, str]\n        -_build_xpath(**kwargs) str\n        -_get_expression_type(expression) By\n    }\n\n    class Tab {\n        -_connection_handler\n        +go_to(url)\n        +execute_script(script)\n    }\n\n    class WebElement {\n        -_object_id\n        -_connection_handler\n        +click()\n        +type(text)\n        +text\n    }\n\n    Tab --|&gt; FindElementsMixin : inherits\n    FindElementsMixin ..&gt; WebElement : creates</code></pre>"},{"location":"deep-dive/find-elements-mixin/#core-internal-methods","title":"Core Internal Methods","text":""},{"location":"deep-dive/find-elements-mixin/#find_or_wait_element","title":"find_or_wait_element()","text":"<p>The core method that handles both immediate finding and waiting:</p> <pre><code>async def find_or_wait_element(\n    self,\n    by: By,\n    value: str,\n    timeout: int = 0,\n    find_all: bool = False,\n    raise_exc: bool = True,\n) -&gt; Union[WebElement, list[WebElement], None]:\n    \"\"\"\n    Core element finding method with optional waiting capability.\n\n    Searches for elements with flexible waiting. If timeout specified,\n    repeatedly attempts to find elements with 0.5s delays until success or timeout.\n    \"\"\"\n</code></pre> <p>This method: 1. Determines the appropriate find method (<code>_find_element</code> or <code>_find_elements</code>) 2. Implements polling logic with 0.5-second intervals 3. Handles timeout and exception raising logic 4. Returns appropriate results based on <code>find_all</code> parameter</p>"},{"location":"deep-dive/find-elements-mixin/#_get_by_and_value","title":"_get_by_and_value()","text":"<p>Converts high-level parameters into CDP-compatible selector strategies:</p> <pre><code>def _get_by_and_value(\n    self,\n    by_map: dict[str, By],\n    id: Optional[str] = None,\n    class_name: Optional[str] = None,\n    name: Optional[str] = None,\n    tag_name: Optional[str] = None,\n    text: Optional[str] = None,\n    **attributes,\n) -&gt; tuple[By, str]:\n</code></pre> <p>This method: 1. Identifies which attributes were provided 2. For single attributes, returns the appropriate <code>By</code> enum and value 3. For multiple attributes, builds an XPath expression using <code>_build_xpath()</code></p>"},{"location":"deep-dive/find-elements-mixin/#_build_xpath","title":"_build_xpath()","text":"<p>Constructs complex XPath expressions from multiple criteria:</p> <pre><code>@staticmethod\ndef _build_xpath(\n    id: Optional[str] = None,\n    class_name: Optional[str] = None,\n    name: Optional[str] = None,\n    tag_name: Optional[str] = None,\n    text: Optional[str] = None,\n    **attributes,\n) -&gt; str:\n</code></pre> <p>This method: 1. Builds the base XPath (<code>//tag</code> or <code>//*</code>) 2. Adds conditions for each provided attribute 3. Handles special cases like class names and text content 4. Combines conditions with <code>and</code> operators</p>"},{"location":"deep-dive/find-elements-mixin/#cdp-command-generation","title":"CDP Command Generation","text":"<p>The mixin generates appropriate CDP commands based on selector type:</p>"},{"location":"deep-dive/find-elements-mixin/#for-css-selectors","title":"For CSS Selectors","text":"<pre><code>def _get_find_element_command(self, by: By, value: str, object_id: str = ''):\n    # Converts to CSS selector format\n    if by == By.CLASS_NAME:\n        selector = f'.{escaped_value}'\n    elif by == By.ID:\n        selector = f'#{escaped_value}'\n\n    # Uses DOM.querySelector or Runtime.evaluate\n</code></pre>"},{"location":"deep-dive/find-elements-mixin/#for-xpath-expressions","title":"For XPath Expressions","text":"<pre><code>def _get_find_element_by_xpath_command(self, xpath: str, object_id: str):\n    # Uses Runtime.evaluate with document.evaluate()\n    script = Scripts.FIND_XPATH_ELEMENT.replace('{escaped_value}', escaped_value)\n    command = RuntimeCommands.evaluate(expression=script)\n</code></pre>"},{"location":"deep-dive/find-elements-mixin/#performance-considerations","title":"Performance Considerations","text":""},{"location":"deep-dive/find-elements-mixin/#selector-efficiency","title":"Selector Efficiency","text":"<p>Different selector types have varying performance characteristics:</p> Selector Type Performance Use Case ID Fastest Unique elements with ID attributes CSS Class Fast Elements with specific styling Tag Name Fast When you need all elements of a type CSS Selector Good Complex but common patterns XPath Slower Complex relationships and text matching"},{"location":"deep-dive/find-elements-mixin/#optimization-strategies","title":"Optimization Strategies","text":"<pre><code># Good: Use ID when available\nelement = await tab.find(id=\"unique-element\")\n\n# Good: Use simple CSS selectors\nelement = await tab.query(\"#form .submit-button\")\n\n# Avoid: Complex XPath when CSS would work\n# element = await tab.query(\"//div[@id='form']//button[@class='submit-button']\")\n\n# Good: Combine attributes efficiently\nelement = await tab.find(tag_name=\"input\", type=\"email\", required=True)\n\n# Good: Use find_all=False when you only need the first match\nfirst_item = await tab.find(class_name=\"item\", find_all=False)\n</code></pre>"},{"location":"deep-dive/find-elements-mixin/#waiting-best-practices","title":"Waiting Best Practices","text":"<pre><code># Good: Use appropriate timeouts\nquick_element = await tab.find(id=\"static-content\", timeout=2)\nslow_element = await tab.find(id=\"ajax-content\", timeout=10)\n\n# Good: Handle optional elements gracefully\noptional = await tab.find(class_name=\"optional\", timeout=1, raise_exc=False)\n\n# Good: Use specific selectors to reduce false positives\nspecific_button = await tab.find(\n    tag_name=\"button\", \n    class_name=\"submit\", \n    type=\"submit\",\n    timeout=5\n)\n</code></pre>"},{"location":"deep-dive/find-elements-mixin/#error-handling","title":"Error Handling","text":"<p>The FindElementsMixin provides comprehensive error handling:</p>"},{"location":"deep-dive/find-elements-mixin/#exception-types","title":"Exception Types","text":"<pre><code>from pydoll.exceptions import ElementNotFound, WaitElementTimeout\n\ntry:\n    element = await tab.find(id=\"missing-element\")\nexcept ElementNotFound:\n    print(\"Element not found immediately\")\n\ntry:\n    element = await tab.find(id=\"slow-element\", timeout=10)\nexcept WaitElementTimeout:\n    print(\"Element did not appear within timeout\")\n</code></pre>"},{"location":"deep-dive/find-elements-mixin/#graceful-handling","title":"Graceful Handling","text":"<pre><code># Option 1: Use raise_exc=False\nelement = await tab.find(id=\"optional-element\", raise_exc=False)\nif element:\n    await element.click()\n\n# Option 2: Try-except with fallback\ntry:\n    primary_button = await tab.find(id=\"primary-action\")\n    await primary_button.click()\nexcept ElementNotFound:\n    # Fallback to alternative selector\n    fallback_button = await tab.find(class_name=\"action-button\")\n    await fallback_button.click()\n</code></pre>"},{"location":"deep-dive/find-elements-mixin/#integration-with-webelement","title":"Integration with WebElement","text":"<p>Found elements are returned as WebElement instances that provide rich interaction capabilities:</p> <pre><code># Find and interact with form elements\nusername = await tab.find(name=\"username\")\nawait username.type_text(\"user@example.com\")\n\npassword = await tab.find(type=\"password\")\nawait password.type_text(\"secretpassword\")\n\nsubmit = await tab.find(tag_name=\"button\", type=\"submit\")\nawait submit.click()\n\n# Get element properties\ntext_content = await username.text\nis_visible = await username.is_visible()\nattribute_value = await username.get_attribute(\"placeholder\")\n</code></pre>"},{"location":"deep-dive/find-elements-mixin/#conclusion","title":"Conclusion","text":"<p>The FindElementsMixin serves as the foundation for element interaction in Pydoll, providing a powerful and intuitive API for locating DOM elements. The combination of the <code>find()</code> and <code>query()</code> methods offers flexibility for both simple and complex element selection scenarios.</p> <p>Key advantages of the FindElementsMixin design:</p> <ol> <li>Intuitive API: The <code>find()</code> method uses natural HTML attribute names</li> <li>Flexible Selection: Support for CSS selectors, XPath, and attribute combinations</li> <li>Robust Waiting: Built-in timeout and polling mechanisms</li> <li>Performance Optimization: Automatic selection of the most efficient selector strategy</li> <li>Error Handling: Comprehensive exception handling with graceful degradation options</li> </ol> <p>By understanding the capabilities and patterns of the FindElementsMixin, you can create robust and maintainable browser automation that handles the complexities of modern web applications.</p>"},{"location":"deep-dive/network-capabilities/","title":"Network Capabilities","text":"<p>Pydoll provides powerful capabilities for monitoring, intercepting, and manipulating network traffic during browser automation. These features give you fine-grained control over how your browser communicates with the web, enabling advanced use cases like request modification, response analysis, and network optimization.</p>"},{"location":"deep-dive/network-capabilities/#network-architecture-overview","title":"Network Architecture Overview","text":"<p>Pydoll's network capabilities are built on top of the Chrome DevTools Protocol (CDP), which provides a direct interface to the browser's internal networking stack. This architecture eliminates the limitations of traditional proxy-based approaches and enables real-time monitoring and modification of requests and responses.</p> <pre><code>flowchart TB\n    subgraph Browser[\"Chrome/Edge Browser\"]\n        Net[\"Network Stack\"] --&gt; CDP[\"Chrome DevTools Protocol\"]\n    end\n\n    subgraph Pydoll[\"Pydoll Library\"]\n        CDP --&gt; NetMon[\"Network Monitoring\"]\n        CDP --&gt; Interception[\"Request Interception\"]\n        CDP --&gt; Headers[\"Headers Manipulation\"]\n        CDP --&gt; Body[\"Body Modification\"]\n        CDP --&gt; Emulation[\"Network Condition Emulation\"]\n    end\n\n    subgraph UserCode[\"User Automation Code\"]\n        NetMon --&gt; Analysis[\"Traffic Analysis\"]\n        Interception --&gt; Auth[\"Authentication Handling\"]\n        Headers --&gt; CustomHeaders[\"Custom Headers Injection\"]\n        Body --&gt; DataModification[\"Request/Response Data Modification\"] \n        Emulation --&gt; Testing[\"Network Condition Testing\"]\n    end\n\n    class Browser,Pydoll,UserCode rounded\n\n\n    class Browser blue\n    class Pydoll green\n    class UserCode orange</code></pre> <p>The network capabilities in Pydoll can be organized into two main categories:</p> <ol> <li>Network Monitoring: Passive observation of network activity</li> <li>Request Interception: Active modification of network requests and responses</li> </ol>"},{"location":"deep-dive/network-capabilities/#network-monitoring","title":"Network Monitoring","text":"<p>Network monitoring allows you to observe and analyze the network activity of your browser session without modifying it. This is useful for understanding how a website loads resources, detecting API endpoints, or troubleshooting performance issues.</p>"},{"location":"deep-dive/network-capabilities/#enabling-network-monitoring","title":"Enabling Network Monitoring","text":"<p>To start monitoring network activity, you need to enable network events:</p> <pre><code>import asyncio\nfrom pydoll.browser.chromium import Chrome\nfrom pydoll.protocol.network.events import NetworkEvent\nfrom functools import partial\n\nasync def main():\n    async with Chrome() as browser:\n        tab = await browser.start()\n\n        # Enable network monitoring\n        await tab.enable_network_events()\n\n        # Navigate to a page\n        await tab.go_to('https://example.com')\n\n        print(\"Network monitoring enabled and page loaded\")\n\nasyncio.run(main())\n</code></pre> <p>When you enable network events, Pydoll automatically captures information about all network requests, including:</p> <ul> <li>URLs</li> <li>HTTP methods</li> <li>Request headers</li> <li>Status codes</li> <li>Response sizes</li> <li>Content types</li> <li>Timing information</li> </ul>"},{"location":"deep-dive/network-capabilities/#network-event-callbacks","title":"Network Event Callbacks","text":"<p>You can register callbacks to be notified about specific network events in real-time:</p> <pre><code>from pydoll.protocol.network.events import NetworkEvent\nfrom functools import partial\n\n# Define a callback to handle request events\nasync def on_request(tab, event):\n    url = event['params']['request']['url']\n    method = event['params']['request']['method']\n\n    print(f\"{method} request to: {url}\")\n\n    # You can access request headers\n    headers = event['params']['request'].get('headers', {})\n    if 'content-type' in headers:\n        print(f\"Content-Type: {headers['content-type']}\")\n\n# Define a callback to handle response events\nasync def on_response(tab, event):\n    url = event['params']['response']['url']\n    status = event['params']['response']['status']\n\n    print(f\"Response from {url}: Status {status}\")\n\n    # Extract response timing information\n    timing = event['params']['response'].get('timing')\n    if timing:\n        total_time = timing['receiveHeadersEnd'] - timing['requestTime']\n        print(f\"Request completed in {total_time:.2f}s\")\n\nasync def main():\n    async with Chrome() as browser:\n        tab = await browser.start()\n\n        # Register the callbacks\n        await tab.enable_network_events()\n        await tab.on(NetworkEvent.REQUEST_WILL_BE_SENT, partial(on_request, tab))\n        await tab.on(NetworkEvent.RESPONSE_RECEIVED, partial(on_response, tab))\n\n        # Navigate to trigger network activity\n        await tab.go_to('https://example.com')\n\n        # Wait to see network activity\n        await asyncio.sleep(5)\n\nasyncio.run(main())\n</code></pre>"},{"location":"deep-dive/network-capabilities/#key-network-events","title":"Key Network Events","text":"<p>Pydoll provides access to a wide range of network-related events:</p> Event Constant Description Useful Information Available <code>NetworkEvent.REQUEST_WILL_BE_SENT</code> Fired when a request is about to be sent URL, method, headers, POST data <code>NetworkEvent.RESPONSE_RECEIVED</code> Fired when HTTP response is available Status code, headers, MIME type, timing <code>NetworkEvent.LOADING_FAILED</code> Fired when a request fails Error information, canceled status <code>NetworkEvent.LOADING_FINISHED</code> Fired when a request completes Encoding, compressed data size <code>NetworkEvent.RESOURCE_CHANGED_PRIORITY</code> Fired when resource loading priority changes New priority level <code>NetworkEvent.WEBSOCKET_CREATED</code> Fired when a WebSocket is created URL, initiator <code>NetworkEvent.WEBSOCKET_FRAME_SENT</code> Fired when a WebSocket frame is sent Payload data <code>NetworkEvent.WEBSOCKET_FRAME_RECEIVED</code> Fired when a WebSocket frame is received Response data"},{"location":"deep-dive/network-capabilities/#advanced-network-monitoring-example","title":"Advanced Network Monitoring Example","text":"<p>Here's a more comprehensive example that tracks various network metrics:</p> <pre><code>import asyncio\nimport time\nfrom pydoll.browser.chromium import Chrome\nfrom pydoll.protocol.network.events import NetworkEvent\nfrom functools import partial\n\nasync def main():\n    # Statistics counters\n    stats = {\n        'total_requests': 0,\n        'completed_requests': 0,\n        'failed_requests': 0,\n        'bytes_received': 0,\n        'request_types': {},\n        'status_codes': {},\n        'domains': {},\n        'start_time': time.time()\n    }\n\n    async def update_dashboard():\n        while True:\n            # Calculate elapsed time\n            elapsed = time.time() - stats['start_time']\n\n            # Clear console and print stats\n            print(\"\\033c\", end=\"\")  # Clear console\n            print(f\"Network Activity Dashboard - Running for {elapsed:.1f}s\")\n            print(f\"Total Requests: {stats['total_requests']}\")\n            print(f\"Completed: {stats['completed_requests']} | Failed: {stats['failed_requests']}\")\n            print(f\"Data Received: {stats['bytes_received'] / 1024:.1f} KB\")\n\n            print(\"\\nRequest Types:\")\n            for rtype, count in sorted(stats['request_types'].items(), key=lambda x: x[1], reverse=True):\n                print(f\"  {rtype}: {count}\")\n\n            print(\"\\nStatus Codes:\")\n            for code, count in sorted(stats['status_codes'].items()):\n                print(f\"  {code}: {count}\")\n\n            print(\"\\nTop Domains:\")\n            top_domains = sorted(stats['domains'].items(), key=lambda x: x[1], reverse=True)[:5]\n            for domain, count in top_domains:\n                print(f\"  {domain}: {count}\")\n\n            await asyncio.sleep(1)\n\n    # Start the dashboard updater task\n    dashboard_task = asyncio.create_task(update_dashboard())\n\n    async with Chrome() as browser:\n        tab = await browser.start()\n\n        # Track request starts\n        async def on_request_sent(tab, event):\n            stats['total_requests'] += 1\n\n            # Track request type\n            resource_type = event['params'].get('type', 'Other')\n            stats['request_types'][resource_type] = stats['request_types'].get(resource_type, 0) + 1\n\n            # Track domain\n            url = event['params']['request']['url']\n            try:\n                from urllib.parse import urlparse\n                domain = urlparse(url).netloc\n                stats['domains'][domain] = stats['domains'].get(domain, 0) + 1\n            except:\n                pass\n\n        # Track responses\n        async def on_response(tab, event):\n            status = event['params']['response']['status']\n            stats['status_codes'][status] = stats['status_codes'].get(status, 0) + 1\n\n        # Track request completions\n        async def on_loading_finished(tab, event):\n            stats['completed_requests'] += 1\n            if 'encodedDataLength' in event['params']:\n                stats['bytes_received'] += event['params']['encodedDataLength']\n\n        # Track failures\n        async def on_loading_failed(tab, event):\n            stats['failed_requests'] += 1\n\n        # Register callbacks\n        await tab.enable_network_events()\n        await tab.on(NetworkEvent.REQUEST_WILL_BE_SENT, partial(on_request_sent, tab))\n        await tab.on(NetworkEvent.RESPONSE_RECEIVED, partial(on_response, tab))\n        await tab.on(NetworkEvent.LOADING_FINISHED, partial(on_loading_finished, tab))\n        await tab.on(NetworkEvent.LOADING_FAILED, partial(on_loading_failed, tab))\n\n        # Navigate to a page with lots of requests\n        await tab.go_to('https://news.ycombinator.com')\n\n        # Wait for user to press Enter to exit\n        await asyncio.sleep(60)\n\n    # Clean up\n    dashboard_task.cancel()\n\nasyncio.run(main())\n</code></pre>"},{"location":"deep-dive/network-capabilities/#request-interception-and-modification","title":"Request Interception and Modification","text":"<p>Request interception is where Pydoll's network capabilities truly shine. Unlike traditional browser automation tools that can only observe network traffic, Pydoll allows you to intercept and modify network requests before they are sent.</p>"},{"location":"deep-dive/network-capabilities/#the-fetch-domain","title":"The Fetch Domain","text":"<p>The Fetch domain in the Chrome DevTools Protocol provides advanced functionality for intercepting and manipulating network requests. Pydoll exposes this functionality through a clean API that makes it easy to implement complex network manipulation scenarios.</p> <pre><code>sequenceDiagram\n    participant App as Application Code\n    participant Pydoll as Pydoll Library\n    participant Browser as Browser\n    participant Server as Web Server\n\n    App-&gt;&gt;Pydoll: Enable fetch events\n    Pydoll-&gt;&gt;Browser: FetchCommands.enable()\n    Browser--&gt;&gt;Pydoll: Enabled\n\n    App-&gt;&gt;Pydoll: Register callback for REQUEST_PAUSED\n\n    App-&gt;&gt;Pydoll: Navigate to URL\n    Pydoll-&gt;&gt;Browser: Navigate command\n    Browser-&gt;&gt;Browser: Initiates request\n    Browser-&gt;&gt;Pydoll: Fetch.requestPaused event\n    Pydoll-&gt;&gt;App: Execute callback\n\n    App-&gt;&gt;Pydoll: Modify and continue request\n    Pydoll-&gt;&gt;Browser: browser.continue_request() with modifications\n    Browser-&gt;&gt;Server: Modified request\n\n    Server--&gt;&gt;Browser: Response\n    Browser--&gt;&gt;Pydoll: Complete\n    Pydoll--&gt;&gt;App: Continue execution</code></pre>"},{"location":"deep-dive/network-capabilities/#enabling-request-interception","title":"Enabling Request Interception","text":"<p>To intercept requests, you need to enable the Fetch domain:</p> <pre><code>import asyncio\nfrom pydoll.browser.chromium import Chrome\nfrom pydoll.protocol.fetch.events import FetchEvent\nfrom functools import partial\n\nasync def main():\n    async with Chrome() as browser:\n        tab = await browser.start()\n\n        # Define a request interceptor\n        async def intercept_request(tab, event):\n            request_id = event['params']['requestId']\n            request = event['params']['request']\n            url = request['url']\n\n            print(f\"Intercepted request to: {url}\")\n\n            # You must continue the request to proceed\n            await browser.continue_request(request_id)\n\n        # Enable fetch events and register the interceptor\n        await tab.enable_fetch_events()\n        await tab.on(FetchEvent.REQUEST_PAUSED, partial(intercept_request, tab))\n\n        # Navigate to a page\n        await tab.go_to('https://example.com')\n\nasyncio.run(main())\n</code></pre> <p>Always Continue Intercepted Requests</p> <p>When intercepting requests, you must always call <code>browser.continue_request()</code>, <code>browser.fail_request()</code>, or <code>browser.fulfill_request()</code> to resolve the intercepted request. If you don't, the browser will hang, waiting for a resolution of the intercepted request.</p>"},{"location":"deep-dive/network-capabilities/#interception-scope-and-resource-types","title":"Interception Scope and Resource Types","text":"<p>You can limit the scope of request interception to specific resource types:</p> <pre><code>from pydoll.constants import ResourceType\n\n# Intercept all requests (could be resource-intensive)\nawait tab.enable_fetch_events()\n\n# Intercept only document (HTML) requests\nawait tab.enable_fetch_events(resource_type=ResourceType.DOCUMENT)\n\n# Intercept only XHR/fetch API requests\nawait tab.enable_fetch_events(resource_type=ResourceType.XHR)\n\n# Intercept only image requests\nawait tab.enable_fetch_events(resource_type=ResourceType.IMAGE)\n</code></pre> <p>Resource types available for interception:</p> Resource Type Description Common Examples <code>ResourceType.DOCUMENT</code> Main HTML documents HTML pages, iframes <code>ResourceType.STYLESHEET</code> CSS files .css files <code>ResourceType.IMAGE</code> Image resources .jpg, .png, .gif, .webp <code>ResourceType.MEDIA</code> Media files .mp4, .webm, audio files <code>ResourceType.FONT</code> Font files .woff, .woff2, .ttf <code>ResourceType.SCRIPT</code> JavaScript files .js files <code>ResourceType.TEXTTRACK</code> Text track files .vtt, .srt (captions, subtitles) <code>ResourceType.XHR</code> XMLHttpRequest calls API calls, AJAX requests <code>ResourceType.FETCH</code> Fetch API requests Modern API calls <code>ResourceType.EVENTSOURCE</code> Server-sent events Stream connections <code>ResourceType.WEBSOCKET</code> WebSocket connections Real-time communications <code>ResourceType.MANIFEST</code> Web app manifests .webmanifest files <code>ResourceType.OTHER</code> Other resource types Miscellaneous resources"},{"location":"deep-dive/network-capabilities/#request-modification-capabilities","title":"Request Modification Capabilities","text":"<p>When intercepting requests, you can modify various aspects of the request before it's sent to the server:</p>"},{"location":"deep-dive/network-capabilities/#1-modifying-url-and-method","title":"1. Modifying URL and Method","text":"<pre><code>async def redirect_request(tab, event):\n    request_id = event['params']['requestId']\n    request = event['params']['request']\n    url = request['url']\n\n    # Redirect requests for one domain to another\n    if 'old-domain.com' in url:\n        new_url = url.replace('old-domain.com', 'new-domain.com')\n        print(f\"Redirecting {url} to {new_url}\")\n\n        await browser.continue_request(\n            request_id=request_id,\n            url=new_url\n        )\n    # Change GET to POST for specific endpoints\n    elif '/api/data' in url and request['method'] == 'GET':\n        print(f\"Converting GET to POST for {url}\")\n\n        await browser.continue_request(\n            request_id=request_id,\n            method='POST'\n        )\n    else:\n        # Continue normally\n        await browser.continue_request(request_id)\n</code></pre>"},{"location":"deep-dive/network-capabilities/#2-adding-or-modifying-headers","title":"2. Adding or Modifying Headers","text":"<pre><code>async def inject_headers(tab, event):\n    request_id = event['params']['requestId']\n    request = event['params']['request']\n    url = request['url']\n\n    # Get existing headers\n    headers = request.get('headers', {})\n\n    # Add or modify headers\n    custom_headers = [\n        {'name': 'X-Custom-Header', 'value': 'CustomValue'},\n        {'name': 'Authorization', 'value': 'Bearer your-token-here'},\n        {'name': 'User-Agent', 'value': 'Custom User Agent String'},\n    ]\n\n    # Add existing headers to the list\n    for name, value in headers.items():\n        custom_headers.append({'name': name, 'value': value})\n\n    await browser.continue_request(\n        request_id=request_id,\n        headers=custom_headers\n    )\n</code></pre>"},{"location":"deep-dive/network-capabilities/#3-modifying-request-body","title":"3. Modifying Request Body","text":"<pre><code>import json\nimport time\n\nasync def modify_post_data(tab, event):\n    request_id = event['params']['requestId']\n    request = event['params']['request']\n    url = request['url']\n    method = request['method']\n\n    # Only process POST requests to specific endpoints\n    if method == 'POST' and '/api/submit' in url:\n        # Get the original post data, if any\n        original_post_data = request.get('postData', '{}')\n\n        try:\n            # Parse the original data\n            data = json.loads(original_post_data)\n\n            # Modify the data\n            data['additionalField'] = 'injected-value'\n            data['timestamp'] = int(time.time())\n\n            # Convert back to string\n            modified_post_data = json.dumps(data)\n\n            print(f\"Modified POST data for {url}\")\n\n            await browser.continue_request(\n                request_id=request_id,\n                post_data=modified_post_data\n            )\n        except json.JSONDecodeError:\n            # If not JSON, continue normally\n            await browser.continue_request(request_id)\n    else:\n        # Continue normally for non-POST requests\n        await browser.continue_request(request_id)\n</code></pre>"},{"location":"deep-dive/network-capabilities/#failing-and-fulfilling-requests","title":"Failing and Fulfilling Requests","text":"<p>Besides continuing requests with modifications, you can also fail requests or fulfill them with custom responses:</p>"},{"location":"deep-dive/network-capabilities/#failing-requests","title":"Failing Requests","text":"<pre><code>from pydoll.constants import NetworkErrorReason\n\nasync def block_requests(tab, event):\n    request_id = event['params']['requestId']\n    request = event['params']['request']\n    url = request['url']\n\n    # Block requests to tracking domains\n    blocked_domains = ['google-analytics.com', 'facebook.com/tr']\n\n    if any(domain in url for domain in blocked_domains):\n        print(f\"Blocking request to: {url}\")\n        await browser.fail_request(request_id, NetworkErrorReason.BLOCKED_BY_CLIENT)\n    else:\n        await browser.continue_request(request_id)\n</code></pre>"},{"location":"deep-dive/network-capabilities/#fulfilling-requests-with-custom-responses","title":"Fulfilling Requests with Custom Responses","text":"<pre><code>async def mock_api_response(tab, event):\n    request_id = event['params']['requestId']\n    request = event['params']['request']\n    url = request['url']\n\n    # Mock API responses\n    if '/api/user' in url:\n        mock_response = {\n            'id': 123,\n            'name': 'Mock User',\n            'email': 'mock@example.com'\n        }\n\n        response_headers = [\n            {'name': 'Content-Type', 'value': 'application/json'},\n            {'name': 'Access-Control-Allow-Origin', 'value': '*'}\n        ]\n\n        print(f\"Mocking response for: {url}\")\n\n        await browser.fulfill_request(\n            request_id=request_id,\n            response_code=200,\n            response_headers=response_headers,\n            response_body=json.dumps(mock_response)\n        )\n    else:\n        await browser.continue_request(request_id)\n</code></pre>"},{"location":"deep-dive/network-capabilities/#authentication-handling","title":"Authentication Handling","text":"<p>The Fetch domain can also intercept authentication challenges, allowing you to automatically handle HTTP authentication:</p> <pre><code>async def main():\n    async with Chrome() as browser:\n        tab = await browser.start()\n\n        # Define authentication handler\n        async def handle_auth(tab, event):\n            request_id = event['params']['requestId']\n            auth_challenge = event['params']['authChallenge']\n\n            print(f\"Authentication required: {auth_challenge['origin']}\")\n\n            # Provide credentials\n            await browser.continue_request_with_auth(\n                request_id=request_id,\n                auth_challenge_response='ProvideCredentials',\n                username=\"username\",\n                password=\"password\"\n            )\n\n        # Enable fetch events with auth handling\n        await tab.enable_fetch_events(handle_auth=True)\n        await tab.on(FetchEvent.AUTH_REQUIRED, partial(handle_auth, tab))\n\n        # Navigate to a page requiring authentication\n        await tab.go_to('https://protected-site.com')\n</code></pre>"},{"location":"deep-dive/network-capabilities/#advanced-network-patterns","title":"Advanced Network Patterns","text":""},{"location":"deep-dive/network-capabilities/#comprehensive-request-interception-example","title":"Comprehensive Request Interception Example","text":"<p>Here's a complete example that demonstrates various interception techniques:</p> <pre><code>import asyncio\nimport json\nfrom pydoll.browser.chromium import Chrome\nfrom pydoll.protocol.fetch.events import FetchEvent\nfrom pydoll.constants import NetworkErrorReason, ResourceType\nfrom functools import partial\n\nasync def main():\n    async with Chrome() as browser:\n        tab = await browser.start()\n\n        async def comprehensive_interceptor(tab, event):\n            request_id = event['params']['requestId']\n            request = event['params']['request']\n            url = request['url']\n            method = request['method']\n\n            print(f\"Intercepting {method} request to: {url}\")\n\n            # Block tracking scripts\n            if any(tracker in url for tracker in ['google-analytics', 'facebook.com/tr']):\n                print(f\"Blocking tracker: {url}\")\n                await browser.fail_request(request_id, NetworkErrorReason.BLOCKED_BY_CLIENT)\n                return\n\n            # Mock API responses\n            if '/api/config' in url:\n                mock_config = {\n                    'feature_flags': {'new_ui': True, 'beta_features': True},\n                    'api_version': '2.0'\n                }\n\n                await browser.fulfill_request(\n                    request_id=request_id,\n                    response_code=200,\n                    response_headers=[\n                        {'name': 'Content-Type', 'value': 'application/json'},\n                        {'name': 'Cache-Control', 'value': 'no-cache'}\n                    ],\n                    response_body=json.dumps(mock_config)\n                )\n                return\n\n            # Inject custom headers for API requests\n            if '/api/' in url:\n                headers = [\n                    {'name': 'X-Custom-Client', 'value': 'Pydoll-Automation'},\n                    {'name': 'X-Request-ID', 'value': f'req-{request_id}'}\n                ]\n\n                # Preserve existing headers\n                for name, value in request.get('headers', {}).items():\n                    headers.append({'name': name, 'value': value})\n\n                await browser.continue_request(\n                    request_id=request_id,\n                    headers=headers\n                )\n                return\n\n            # Continue all other requests normally\n            await browser.continue_request(request_id)\n\n        # Enable fetch events for XHR and Fetch requests only\n        await tab.enable_fetch_events(resource_type=ResourceType.XHR)\n        await tab.on(FetchEvent.REQUEST_PAUSED, partial(comprehensive_interceptor, tab))\n\n        # Navigate and interact with the page\n        await tab.go_to('https://example.com')\n        await asyncio.sleep(5)  # Wait for network activity\n\nasyncio.run(main())\n</code></pre>"},{"location":"deep-dive/network-capabilities/#performance-considerations","title":"Performance Considerations","text":"<p>While Pydoll's network capabilities are powerful, there are some performance considerations to keep in mind:</p> <ol> <li> <p>Selective Interception: Intercepting all requests can significantly slow down page loading. Be selective about which resource types you intercept.</p> </li> <li> <p>Memory Management: Network event callbacks can consume memory if they store large amounts of data. Be mindful of memory usage in long-running automations.</p> </li> <li> <p>Callback Efficiency: Keep your event callbacks efficient, especially for high-frequency events like network requests. Inefficient callbacks can slow down the entire automation process.</p> </li> <li> <p>Cleanup: Always disable network and fetch events when you're done using them to prevent memory leaks.</p> </li> </ol> <pre><code># Enable events only when needed\nawait tab.enable_network_events()\nawait tab.enable_fetch_events(resource_type=ResourceType.XHR)  # Only intercept XHR requests\n\n# Do your automation work...\n\n# Clean up when done\nawait tab.disable_network_events()\nawait tab.disable_fetch_events()\n</code></pre>"},{"location":"deep-dive/network-capabilities/#best-practices","title":"Best Practices","text":""},{"location":"deep-dive/network-capabilities/#1-use-resource-type-filtering-effectively","title":"1. Use Resource Type Filtering Effectively","text":"<pre><code># Bad: Intercept all requests (performance impact)\nawait tab.enable_fetch_events()\n\n# Good: Only intercept the specific resource types you need\nawait tab.enable_fetch_events(resource_type=ResourceType.XHR)  # For API calls\nawait tab.enable_fetch_events(resource_type=ResourceType.DOCUMENT)  # For main documents\n</code></pre>"},{"location":"deep-dive/network-capabilities/#2-always-resolve-intercepted-requests","title":"2. Always Resolve Intercepted Requests","text":"<pre><code># Always resolve every intercepted request\nasync def intercept_handler(tab, event):\n    request_id = event['params']['requestId']\n\n    try:\n        # Make any modifications needed\n        custom_headers = [{'name': 'X-Custom', 'value': 'Value'}]\n\n        # Continue the request\n        await browser.continue_request(\n            request_id=request_id,\n            headers=custom_headers\n        )\n    except Exception as e:\n        print(f\"Error in request handler: {e}\")\n        # Always try to continue the request even if there was an error\n        try:\n            await browser.continue_request(request_id)\n        except:\n            pass\n</code></pre>"},{"location":"deep-dive/network-capabilities/#3-implement-proper-error-handling","title":"3. Implement Proper Error Handling","text":"<pre><code>async def safe_network_handler(tab, event):\n    request_id = event['params']['requestId']\n\n    try:\n        # Your interception logic here\n        await process_request(event)\n        await browser.continue_request(request_id)\n    except Exception as e:\n        print(f\"Error in request handler: {e}\")\n        # Try to continue the request even if there was an error\n        try:\n            await browser.continue_request(request_id)\n        except:\n            # If we can't continue, try to fail it gracefully\n            try:\n                await browser.fail_request(request_id, NetworkErrorReason.FAILED)\n            except:\n                pass\n</code></pre>"},{"location":"deep-dive/network-capabilities/#4-use-partial-for-clean-callback-management","title":"4. Use Partial for Clean Callback Management","text":"<pre><code>from functools import partial\n\n# Define your handler with tab object as first parameter\nasync def handle_request(tab, config, event):\n    # Now you have access to both tab and custom config\n    request_id = event['params']['requestId']\n\n    if config['block_trackers'] and is_tracker(event['params']['request']['url']):\n        await browser.fail_request(request_id, NetworkErrorReason.BLOCKED_BY_CLIENT)\n    else:\n        await browser.continue_request(request_id)\n\n# Register with partial to pre-bind parameters\nconfig = {\"block_trackers\": True}\nawait tab.on(\n    FetchEvent.REQUEST_PAUSED, \n    partial(handle_request, tab, config)\n)\n</code></pre>"},{"location":"deep-dive/network-capabilities/#conclusion","title":"Conclusion","text":"<p>Pydoll's network capabilities provide unprecedented control over browser network traffic, enabling advanced use cases that go beyond traditional browser automation. Whether you're monitoring API calls, injecting custom headers, or modifying request data, these features can greatly enhance your automation workflows.</p> <p>By leveraging the power of the Chrome DevTools Protocol, Pydoll makes it easy to implement sophisticated network monitoring and interception patterns while maintaining high performance and reliability.</p> <p>Remember to use these capabilities responsibly and consider the performance implications of extensive network monitoring and interception in your automation scripts.</p>"},{"location":"deep-dive/tab-domain/","title":"Tab Domain","text":"<p>The Tab domain forms the core of Pydoll's architecture, providing a comprehensive interface for controlling browser tabs and their content. This domain bridges your high-level automation code with the browser's capabilities, enabling everything from basic navigation to complex interaction patterns.</p> <pre><code>graph TB\n    User[\"User Code\"] --&gt; Tab[\"Tab Domain\"]\n\n    subgraph \"Core Capabilities\"\n        Tab --&gt; Nav[\"Navigation\"]\n        Tab --&gt; Elements[\"Element Operations\"]\n        Tab --&gt; JS[\"JavaScript Execution\"]\n        Tab --&gt; Events[\"Event System\"]\n        Tab --&gt; State[\"Session Management\"]\n    end\n\n    Nav &amp; Elements &amp; JS --&gt; Website[\"Website\"]\n    Events &lt;--&gt; Website</code></pre>"},{"location":"deep-dive/tab-domain/#technical-architecture","title":"Technical Architecture","text":"<p>The Tab domain in Pydoll acts as an integration layer between your automation code and multiple Chrome DevTools Protocol (CDP) domains. It's implemented as a concrete class that integrates multiple functional capabilities through composition and inheritance.</p> <pre><code>classDiagram\n    class Tab {\n        -_browser: Browser\n        -_connection_handler: ConnectionHandler\n        -_target_id: str\n        -_browser_context_id: Optional[str]\n        -_page_events_enabled: bool\n        -_network_events_enabled: bool\n        -_fetch_events_enabled: bool\n        -_dom_events_enabled: bool\n        -_runtime_events_enabled: bool\n        -_intercept_file_chooser_dialog_enabled: bool\n        -_cloudflare_captcha_callback_id: Optional[int]\n        +go_to(url: str, timeout: int)\n        +refresh()\n        +execute_script(script: str, element: WebElement)\n        +find(**kwargs) WebElement|List[WebElement]\n        +query(expression: str) WebElement|List[WebElement]\n        +take_screenshot(path: str)\n        +print_to_pdf(path: str)\n        +enable_page_events()\n        +enable_network_events()\n        +on(event_name: str, callback: callable)\n        +close()\n    }\n\n    class FindElementsMixin {\n        +find(**kwargs) WebElement|List[WebElement]\n        +query(expression: str) WebElement|List[WebElement]\n        +find_or_wait_element(by: By, value: str, timeout: int) WebElement|List[WebElement]\n    }\n\n    class ConnectionHandler {\n        +execute_command(command: dict)\n        +register_callback(event_name: str, callback: callable)\n    }\n\n    class WebElement {\n        -_connection_handler: ConnectionHandler\n        -_object_id: str\n        +click()\n        +type(text: str)\n        +get_attribute(name: str)\n        +text\n        +is_visible()\n    }\n\n    Tab --|&gt; FindElementsMixin : inherits\n    Tab *-- ConnectionHandler : uses\n    Tab ..&gt; WebElement : creates\n    WebElement *-- ConnectionHandler : uses</code></pre> <p>The design leverages several key patterns:</p> <ol> <li>Inheritance - The Tab class inherits from FindElementsMixin to gain element location capabilities</li> <li>Composition - It uses a ConnectionHandler to manage CDP communication</li> <li>Factory Method - It creates WebElement instances when finding elements in the tab</li> <li>Command - It translates high-level methods into CDP commands</li> <li>Observer - It implements an event system for reacting to browser events</li> </ol>"},{"location":"deep-dive/tab-domain/#cdp-integration","title":"CDP Integration","text":"<p>The Tab domain integrates with multiple CDP domains to provide its functionality:</p> CDP Domain Purpose Page Core page lifecycle and navigation Runtime JavaScript execution in page context DOM Document structure and element access Network Network operations and cookie management Fetch Request interception and modification Storage Cookie and storage management <p>This integration creates a powerful abstraction that simplifies browser automation while providing access to the full capabilities of the underlying protocol.</p> <pre><code>sequenceDiagram\n    participant Client as User Code\n    participant Tab as Tab Domain\n    participant CDP as Chrome DevTools Protocol\n    participant Browser as Browser\n\n    Client-&gt;&gt;Tab: await tab.go_to(\"https://example.com\")\n    Tab-&gt;&gt;CDP: Page.navigate\n    CDP-&gt;&gt;Browser: Execute navigation\n\n    Browser--&gt;&gt;CDP: Page.loadEventFired\n    CDP--&gt;&gt;Tab: Event notification\n    Tab--&gt;&gt;Client: Navigation completed\n\n    Client-&gt;&gt;Tab: await tab.find(id=\"login\")\n    Tab-&gt;&gt;CDP: Runtime.evaluate / DOM.querySelector\n    CDP-&gt;&gt;Browser: Execute DOM query\n    Browser--&gt;&gt;CDP: Return element\n    CDP--&gt;&gt;Tab: Element response\n    Tab-&gt;&gt;Tab: Create WebElement\n    Tab--&gt;&gt;Client: Return WebElement</code></pre>"},{"location":"deep-dive/tab-domain/#initialization-and-state-management","title":"Initialization and State Management","text":"<p>The Tab class is initialized with parameters from the browser instance:</p> <pre><code>def __init__(\n    self,\n    browser: 'Browser',\n    connection_port: int,\n    target_id: str,\n    browser_context_id: Optional[str] = None,\n):\n    \"\"\"\n    Initialize tab controller for existing browser tab.\n\n    Args:\n        browser: Browser instance that created this tab.\n        connection_port: CDP WebSocket port.\n        target_id: CDP target identifier for this tab.\n        browser_context_id: Optional browser context ID.\n    \"\"\"\n    self._browser = browser\n    self._connection_port = connection_port\n    self._target_id = target_id\n    self._connection_handler = ConnectionHandler(connection_port, target_id)\n    self._page_events_enabled = False\n    self._network_events_enabled = False\n    self._fetch_events_enabled = False\n    self._dom_events_enabled = False\n    self._runtime_events_enabled = False\n    self._intercept_file_chooser_dialog_enabled = False\n    self._cloudflare_captcha_callback_id = None\n    self._browser_context_id = browser_context_id\n</code></pre> <p>The Tab class maintains several state flags to track which event domains are currently enabled. This state management is crucial for:</p> <ol> <li>Preventing duplicate event registrations</li> <li>Accurately reflecting the current capabilities of the tab</li> <li>Enabling proper cleanup when the tab is closed</li> </ol>"},{"location":"deep-dive/tab-domain/#core-patterns-and-usage","title":"Core Patterns and Usage","text":"<p>The Tab domain follows a consistent pattern for interaction in Pydoll v2.0+:</p> <pre><code>import asyncio\nfrom pydoll.browser.chromium import Chrome\n\nasync def pydoll_example():\n    # Create a browser instance and get initial tab\n    browser = Chrome()\n    tab = await browser.start()  # Returns Tab directly\n\n    try:\n        # Work with the tab...\n        await tab.go_to(\"https://example.com\")\n\n        # Find and interact with elements\n        button = await tab.find(id=\"submit\")\n        await button.click()\n\n    finally:\n        # Clean up when done\n        await browser.stop()\n\n# Run your example with asyncio\nasyncio.run(pydoll_example())\n</code></pre> <p>Most examples in this documentation assume a browser and tab have already been created and will be properly cleaned up.</p>"},{"location":"deep-dive/tab-domain/#navigation-system","title":"Navigation System","text":"<p>The Tab domain provides a fluid navigation experience through a combination of methods that abstract the complexities of browser navigation:</p> <pre><code># Navigate to a page with custom timeout\nawait tab.go_to(\"https://example.com\", timeout=60)\n\n# Get the current URL\ncurrent_url = await tab.current_url\nprint(f\"Current URL: {current_url}\")\n\n# Get the page source\nsource = await tab.page_source\nprint(f\"Page source length: {len(source)}\")\n\n# Refresh the page\nawait tab.refresh()\n</code></pre> <p>Advanced Navigation</p> <p>For specialized navigation scenarios, you can combine navigation with event listeners:</p> <pre><code># Listen for network requests during navigation\nawait tab.enable_network_events()\nawait tab.on('Network.responseReceived', handle_response)\n\n# Navigate to the page\nawait tab.go_to('https://example.com')\n</code></pre> <p>Under the hood, the navigation system performs several operations:</p> <ol> <li>Sends the navigation command through the connection handler</li> <li>Monitors page load status through periodic JavaScript evaluation</li> <li>Manages timeouts to prevent infinite waits</li> <li>Handles refresh optimization if navigating to the current URL</li> </ol>"},{"location":"deep-dive/tab-domain/#javascript-execution","title":"JavaScript Execution","text":"<p>The JavaScript execution system in the Tab domain provides two distinct execution modes:</p> <ol> <li>Global Execution: Evaluates JavaScript in the global page context</li> <li>Element Context Execution: Executes JavaScript with an element as the context</li> </ol> <pre><code># Execute JavaScript in page context\ndimensions = await tab.execute_script(\"\"\"\n    return {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        devicePixelRatio: window.devicePixelRatio\n    }\n\"\"\")\nprint(f\"Window dimensions: {dimensions}\")\n\n# Find an element and manipulate it with JavaScript\nheading = await tab.find(tag_name=\"h1\")\n\n# Execute JavaScript with the element as context\nawait tab.execute_script(\"\"\"\n    // 'argument' refers to the element\n    argument.style.color = 'red';\n    argument.style.fontSize = '32px';\n    argument.textContent = 'Modified by JavaScript';\n\"\"\", heading)\n</code></pre> <p>Script Execution Security</p> <p>When executing scripts, be aware of security implications:</p> <ul> <li>Scripts run with the full permissions of the page</li> <li>Input validation is crucial if script content includes user data</li> <li>Consider using element methods instead of scripts for standard operations</li> </ul> <p>The implementation transforms the provided JavaScript code and parameters to match the CDP requirements:</p> <ol> <li>For global execution: </li> <li>The script is sent directly to Runtime.evaluate</li> <li>For element context execution:</li> <li>The script is wrapped in a function</li> <li>'argument' references are replaced with 'this'</li> <li>The function is called with the element's objectId as context</li> </ol>"},{"location":"deep-dive/tab-domain/#session-state-management","title":"Session State Management","text":"<p>The Tab domain implements sophisticated session state management that works with browser contexts:</p> <pre><code># Set cookies for this tab\ncookies_to_set = [\n    {\n        \"name\": \"session_id\",\n        \"value\": \"test_session_123\",\n        \"domain\": \"example.com\",\n        \"path\": \"/\",\n        \"secure\": True,\n        \"httpOnly\": True\n    }\n]\nawait tab.set_cookies(cookies_to_set)\n\n# Get all cookies accessible from this tab\nall_cookies = await tab.get_cookies()\nprint(f\"Number of cookies: {len(all_cookies)}\")\n\n# Delete all cookies from this tab's context\nawait tab.delete_all_cookies()\n</code></pre> <p>Tab-Specific Cookie Management</p> <p>A powerful feature of Pydoll is the ability to control cookies at the individual Tab level within browser contexts:</p> <pre><code># Create different contexts for isolation\ncontext1 = await browser.create_browser_context()\ncontext2 = await browser.create_browser_context()\n\n# Tabs in different contexts have isolated cookies\ntab1 = await browser.new_tab(\"https://example.com\", browser_context_id=context1)\ntab2 = await browser.new_tab(\"https://example.com\", browser_context_id=context2)\n\n# Set different cookies for each tab\nawait tab1.set_cookies([{\"name\": \"user\", \"value\": \"user_a\", \"domain\": \"example.com\"}])\nawait tab2.set_cookies([{\"name\": \"user\", \"value\": \"user_b\", \"domain\": \"example.com\"}])\n</code></pre> <p>This capability enables: - Testing user interactions between different account types - Comparing different user permission levels side-by-side - Maintaining multiple authenticated sessions simultaneously</p>"},{"location":"deep-dive/tab-domain/#content-capture","title":"Content Capture","text":"<p>The Tab domain provides flexible methods for capturing visual content:</p> <pre><code># Take a screenshot and save it to a file\nawait tab.take_screenshot(\"homepage.png\")\n\n# Get a screenshot as base64 (useful for embedding in reports)\nscreenshot_base64 = await tab.take_screenshot(as_base64=True)\n\n# Take a high-quality screenshot\nawait tab.take_screenshot(\"high_quality.jpg\", quality=95)\n\n# Export page as PDF\nawait tab.print_to_pdf(\"homepage.pdf\")\n\n# Export PDF with custom settings\nawait tab.print_to_pdf(\n    \"custom.pdf\",\n    landscape=True,\n    print_background=True,\n    scale=0.8\n)\n</code></pre> <p>Supported Screenshot Formats</p> <p>Pydoll supports saving screenshots in several formats: - PNG (.png): Lossless compression, best for UI testing - JPEG (.jpg/.jpeg): Lossy compression, smaller file size</p> <p>If you attempt to use an unsupported format, Pydoll will raise an <code>InvalidFileExtension</code> exception.</p> <p>These visual capture capabilities are invaluable for: - Visual regression testing - Creating documentation - Debugging automation scripts - Archiving page content</p>"},{"location":"deep-dive/tab-domain/#event-system-overview","title":"Event System Overview","text":"<p>The Tab domain provides a comprehensive event system for monitoring and reacting to browser events:</p> <pre><code># Enable different event domains\nawait tab.enable_page_events()\nawait tab.enable_network_events()\nawait tab.enable_fetch_events()\nawait tab.enable_dom_events()\nawait tab.enable_runtime_events()\n\n# Register event handlers\nasync def handle_load_event(event):\n    print(\"Page loaded!\")\n\nasync def handle_network_response(event):\n    url = event['params']['response']['url']\n    print(f\"Response received from: {url}\")\n\nawait tab.on('Page.loadEventFired', handle_load_event)\nawait tab.on('Network.responseReceived', handle_network_response)\n</code></pre>"},{"location":"deep-dive/tab-domain/#event-properties","title":"Event Properties","text":"<p>The Tab class provides convenient properties to check event states:</p> <pre><code># Check which events are enabled\nprint(f\"Page events enabled: {tab.page_events_enabled}\")\nprint(f\"Network events enabled: {tab.network_events_enabled}\")\nprint(f\"Fetch events enabled: {tab.fetch_events_enabled}\")\nprint(f\"DOM events enabled: {tab.dom_events_enabled}\")\nprint(f\"Runtime events enabled: {tab.runtime_events_enabled}\")\n</code></pre> <p>Event Categories</p> <p>Pydoll supports several event categories, each requiring explicit enabling:</p> <ul> <li>Page Events: Navigation, loading, errors, dialog handling</li> <li>Network Events: Requests, responses, WebSockets</li> <li>DOM Events: Document updates, attribute changes</li> <li>Fetch Events: Request interception and modification</li> <li>Runtime Events: JavaScript execution and console messages</li> </ul>"},{"location":"deep-dive/tab-domain/#advanced-capabilities","title":"Advanced Capabilities","text":""},{"location":"deep-dive/tab-domain/#cloudflare-captcha-handling","title":"Cloudflare Captcha Handling","text":"<p>The Tab domain provides intelligent Cloudflare captcha handling through two distinct approaches:</p> <pre><code># Context manager approach (blocks until captcha is solved)\nasync with tab.expect_and_bypass_cloudflare_captcha():\n    await tab.go_to(\"https://site-with-cloudflare.com\")\n    # Continue only after captcha is solved\n\n# Background processing approach\nawait tab.enable_auto_solve_cloudflare_captcha()\nawait tab.go_to(\"https://another-protected-site.com\")\n# Code continues immediately, captcha solved in background\n\n# When finished with auto-solving\nawait tab.disable_auto_solve_cloudflare_captcha()\n</code></pre>"},{"location":"deep-dive/tab-domain/#dialog-management","title":"Dialog Management","text":"<p>Pydoll implements dialog handling through event monitoring and state tracking:</p> <pre><code># Set up a dialog handler\nasync def handle_dialog(event):\n    if await tab.has_dialog():\n        message = await tab.get_dialog_message()\n        print(f\"Dialog detected: {message}\")\n        await tab.handle_dialog(accept=True)\n\n# Enable page events to detect dialogs\nawait tab.enable_page_events()\nawait tab.on('Page.javascriptDialogOpening', handle_dialog)\n\n# Trigger an alert dialog\nawait tab.execute_script(\"alert('This is a test alert')\")\n</code></pre>"},{"location":"deep-dive/tab-domain/#network-analysis-methods","title":"Network Analysis Methods","text":"<p>The Tab domain provides specialized methods for analyzing network traffic and extracting response data. These methods require network events to be enabled first.</p>"},{"location":"deep-dive/tab-domain/#network-logs-retrieval","title":"Network Logs Retrieval","text":"<p>The <code>get_network_logs()</code> method provides access to all captured network requests:</p> <pre><code># Enable network monitoring\nawait tab.enable_network_events()\n\n# Navigate to trigger network requests\nawait tab.go_to('https://example.com/api-heavy-page')\n\n# Get all network logs\nall_logs = await tab.get_network_logs()\nprint(f\"Captured {len(all_logs)} network requests\")\n\n# Filter logs by URL content\napi_logs = await tab.get_network_logs(filter='api')\nstatic_logs = await tab.get_network_logs(filter='.js')\ndomain_logs = await tab.get_network_logs(filter='example.com')\n\nprint(f\"API requests: {len(api_logs)}\")\nprint(f\"JavaScript files: {len(static_logs)}\")\nprint(f\"Domain requests: {len(domain_logs)}\")\n</code></pre>"},{"location":"deep-dive/tab-domain/#response-body-extraction","title":"Response Body Extraction","text":"<p>The <code>get_network_response_body()</code> method allows extraction of actual response content:</p> <pre><code>from functools import partial\nfrom pydoll.protocol.network.events import NetworkEvent\n\n# Storage for captured responses\ncaptured_responses = {}\n\nasync def capture_api_responses(tab, event):\n    \"\"\"Capture response bodies from API calls\"\"\"\n    request_id = event['params']['requestId']\n    response = event['params']['response']\n    url = response['url']\n\n    # Only capture API responses\n    if '/api/' in url and response['status'] == 200:\n        try:\n            # Extract the response body\n            body = await tab.get_network_response_body(request_id)\n            captured_responses[url] = body\n            print(f\"Captured response from: {url}\")\n        except Exception as e:\n            print(f\"Failed to capture response: {e}\")\n\n# Enable network monitoring and register callback\nawait tab.enable_network_events()\nawait tab.on(NetworkEvent.RESPONSE_RECEIVED, partial(capture_api_responses, tab))\n\n# Navigate to trigger API calls\nawait tab.go_to('https://example.com/dashboard')\nawait asyncio.sleep(3)  # Wait for API calls\n\nprint(f\"Captured {len(captured_responses)} API responses\")\n</code></pre>"},{"location":"deep-dive/tab-domain/#practical-network-analysis-example","title":"Practical Network Analysis Example","text":"<p>Here's a comprehensive example combining both methods for thorough network analysis:</p> <pre><code>import asyncio\nimport json\nfrom functools import partial\nfrom pydoll.browser.chromium import Chrome\nfrom pydoll.protocol.network.events import NetworkEvent\n\nasync def comprehensive_network_analysis():\n    async with Chrome() as browser:\n        tab = await browser.start()\n\n        # Storage for analysis results\n        analysis_results = {\n            'api_responses': {},\n            'failed_requests': [],\n            'request_summary': {}\n        }\n\n        async def analyze_responses(tab, event):\n            \"\"\"Analyze network responses\"\"\"\n            request_id = event['params']['requestId']\n            response = event['params']['response']\n            url = response['url']\n            status = response['status']\n\n            # Track failed requests\n            if status &gt;= 400:\n                analysis_results['failed_requests'].append({\n                    'url': url,\n                    'status': status,\n                    'request_id': request_id\n                })\n                return\n\n            # Capture successful API responses\n            if '/api/' in url and status == 200:\n                try:\n                    body = await tab.get_network_response_body(request_id)\n\n                    # Try to parse JSON responses\n                    try:\n                        data = json.loads(body)\n                        analysis_results['api_responses'][url] = {\n                            'data': data,\n                            'size': len(body),\n                            'type': 'json'\n                        }\n                    except json.JSONDecodeError:\n                        analysis_results['api_responses'][url] = {\n                            'data': body,\n                            'size': len(body),\n                            'type': 'text'\n                        }\n\n                except Exception as e:\n                    print(f\"Failed to capture response from {url}: {e}\")\n\n        # Enable monitoring and register callback\n        await tab.enable_network_events()\n        await tab.on(NetworkEvent.RESPONSE_RECEIVED, partial(analyze_responses, tab))\n\n        # Navigate and perform actions\n        await tab.go_to('https://example.com/complex-app')\n        await asyncio.sleep(5)  # Wait for network activity\n\n        # Get comprehensive logs\n        all_logs = await tab.get_network_logs()\n        api_logs = await tab.get_network_logs(filter='api')\n\n        # Generate summary\n        analysis_results['request_summary'] = {\n            'total_requests': len(all_logs),\n            'api_requests': len(api_logs),\n            'failed_requests': len(analysis_results['failed_requests']),\n            'captured_responses': len(analysis_results['api_responses'])\n        }\n\n        # Display results\n        print(\"\ud83d\udd0d Network Analysis Results:\")\n        print(f\"   Total requests: {analysis_results['request_summary']['total_requests']}\")\n        print(f\"   API requests: {analysis_results['request_summary']['api_requests']}\")\n        print(f\"   Failed requests: {analysis_results['request_summary']['failed_requests']}\")\n        print(f\"   Captured responses: {analysis_results['request_summary']['captured_responses']}\")\n\n        # Show failed requests\n        if analysis_results['failed_requests']:\n            print(\"\\n\u274c Failed Requests:\")\n            for failed in analysis_results['failed_requests']:\n                print(f\"   {failed['status']} - {failed['url']}\")\n\n        # Show captured API data\n        if analysis_results['api_responses']:\n            print(\"\\n\u2705 Captured API Responses:\")\n            for url, info in analysis_results['api_responses'].items():\n                print(f\"   {url} ({info['type']}, {info['size']} bytes)\")\n\n        return analysis_results\n\n# Run the analysis\nasyncio.run(comprehensive_network_analysis())\n</code></pre>"},{"location":"deep-dive/tab-domain/#use-cases-for-network-analysis","title":"Use Cases for Network Analysis","text":"<p>These network analysis methods enable powerful automation scenarios:</p> <p>API Testing and Validation: <pre><code># Validate API responses during automated testing\napi_logs = await tab.get_network_logs(filter='/api/users')\nfor log in api_logs:\n    request_id = log['params']['requestId']\n    response_body = await tab.get_network_response_body(request_id)\n    data = json.loads(response_body)\n\n    # Validate response structure\n    assert 'users' in data\n    assert len(data['users']) &gt; 0\n</code></pre></p> <p>Performance Monitoring: <pre><code># Monitor request timing and sizes\nall_logs = await tab.get_network_logs()\nlarge_responses = []\n\nfor log in all_logs:\n    if 'response' in log['params']:\n        response = log['params']['response']\n        if response.get('encodedDataLength', 0) &gt; 1000000:  # &gt; 1MB\n            large_responses.append({\n                'url': response['url'],\n                'size': response['encodedDataLength']\n            })\n\nprint(f\"Found {len(large_responses)} large responses\")\n</code></pre></p> <p>Data Extraction: <pre><code># Extract dynamic content loaded via AJAX\nawait tab.go_to('https://spa-application.com')\nawait asyncio.sleep(3)  # Wait for AJAX calls\n\ndata_logs = await tab.get_network_logs(filter='/data/')\nextracted_data = []\n\nfor log in data_logs:\n    request_id = log['params']['requestId']\n    try:\n        body = await tab.get_network_response_body(request_id)\n        data = json.loads(body)\n        extracted_data.extend(data.get('items', []))\n    except:\n        continue\n\nprint(f\"Extracted {len(extracted_data)} data items\")\n</code></pre></p>"},{"location":"deep-dive/tab-domain/#file-upload-handling","title":"File Upload Handling","text":"<p>The Tab domain provides a context manager for handling file uploads:</p> <pre><code># Path to a file to upload\nfile_path = \"document.pdf\"\n\n# Use the context manager to handle file chooser dialog\nasync with tab.expect_file_chooser(files=file_path):\n    # Find and click the upload button\n    upload_button = await tab.find(id=\"upload-button\")\n    await upload_button.click()\n</code></pre>"},{"location":"deep-dive/tab-domain/#iframe-interaction","title":"IFrame Interaction","text":"<p>Work with iframes through the Tab domain:</p> <pre><code># Find an iframe element\niframe_element = await tab.find(tag_name=\"iframe\")\n\n# Get a Tab instance for the iframe\niframe_tab = await tab.get_frame(iframe_element)\n\n# Interact with content inside the iframe\niframe_button = await iframe_tab.find(id=\"iframe-button\")\nawait iframe_button.click()\n</code></pre>"},{"location":"deep-dive/tab-domain/#tab-lifecycle-management","title":"Tab Lifecycle Management","text":""},{"location":"deep-dive/tab-domain/#closing-tabs","title":"Closing Tabs","text":"<pre><code># Close a specific tab\nawait tab.close()\n\n# Note: Tab instance becomes invalid after closing\n</code></pre>"},{"location":"deep-dive/tab-domain/#multiple-tab-management","title":"Multiple Tab Management","text":"<pre><code># Create multiple tabs\ntab1 = await browser.start()  # Initial tab\ntab2 = await browser.new_tab(\"https://example.com\")\ntab3 = await browser.new_tab(\"https://github.com\")\n\n# Work with different tabs\nawait tab1.go_to(\"https://google.com\")\nawait tab2.find(id=\"search\").type_text(\"Pydoll\")\nawait tab3.find(class_name=\"header-search-input\").type_text(\"automation\")\n\n# Close specific tabs when done\nawait tab2.close()\nawait tab3.close()\n</code></pre>"},{"location":"deep-dive/tab-domain/#performance-optimization","title":"Performance Optimization","text":""},{"location":"deep-dive/tab-domain/#event-optimization","title":"Event Optimization","text":"<p>Enable only the specific event domains necessary for your current task:</p> <pre><code># GOOD: Enable only what you need\nawait tab.enable_network_events()  # Only enable network events\n\n# BAD: Enabling unnecessary events creates overhead\nawait tab.enable_page_events()\nawait tab.enable_network_events()\nawait tab.enable_dom_events()\nawait tab.enable_fetch_events()\nawait tab.enable_runtime_events()\n</code></pre>"},{"location":"deep-dive/tab-domain/#resource-management","title":"Resource Management","text":"<pre><code># Use context managers for automatic cleanup\nasync with Chrome() as browser:\n    tab = await browser.start()\n\n    # Enable events only when needed\n    await tab.enable_page_events()\n\n    try:\n        # Your automation code\n        await tab.go_to(\"https://example.com\")\n    finally:\n        # Events are automatically cleaned up when browser closes\n        pass\n</code></pre>"},{"location":"deep-dive/tab-domain/#domain-relationships","title":"Domain Relationships","text":"<p>Understanding Pydoll's domain architecture helps clarify how the Tab Domain fits into the library's broader ecosystem:</p> <pre><code>graph LR\n    Browser[\"Browser Domain&lt;br/&gt;(Browser management)\"]\n    Tab[\"Tab Domain&lt;br/&gt;(Tab interaction)\"]\n    Element[\"WebElement Domain&lt;br/&gt;(Element interaction)\"]\n\n    Browser --&gt;|\"creates and manages\"| Tab\n    Tab --&gt;|\"locates and creates\"| Element</code></pre> <p>The Browser Domain sits at the top of the hierarchy, responsible for browser lifecycle, connection management, and global configuration. It creates and manages tab instances through methods like <code>start()</code> and <code>new_tab()</code>.</p> <p>The Tab Domain acts as the crucial intermediary, operating within the context of a specific browser tab. It exposes methods for navigation, content interaction, JavaScript execution, and event handling. A fundamental aspect is its ability to locate elements within the tab and create WebElement instances.</p> <p>The WebElement Domain represents specific DOM elements. Each WebElement belongs to a tab and provides specialized methods for interactions such as clicking, typing, or retrieving properties.</p> <p>This layered architecture provides several benefits:</p> <ul> <li>Separation of Concerns: Each domain has a clear, well-defined purpose</li> <li>Reusability: Components can be used independently when needed</li> <li>Ease of Use: The API follows a natural flow from browser \u2192 tab \u2192 element</li> <li>Flexibility: Multiple tabs can operate within a single browser with independent states</li> </ul>"},{"location":"deep-dive/tab-domain/#conclusion","title":"Conclusion","text":"<p>The Tab domain is the central workspace for most Pydoll automation tasks. Its sophisticated architecture integrates multiple CDP domains into a unified API that simplifies complex automation scenarios while maintaining the full power of the Chrome DevTools Protocol.</p> <p>The domain's design leverages several architectural patterns: - Inheritance and composition for code organization - Command pattern for CDP communication - Observer pattern for event handling  - Factory pattern for element creation - Context managers for resource management</p> <p>Key advantages of the Tab domain in Pydoll v2.0+:</p> <ol> <li>Intuitive Element Finding: Modern <code>find()</code> and <code>query()</code> methods</li> <li>Browser Context Integration: Seamless work with isolated browser contexts</li> <li>Comprehensive Event System: Full CDP event support with easy enabling/disabling</li> <li>Advanced Automation: Built-in captcha handling, dialog management, and file uploads</li> <li>Performance Optimization: Selective event enabling and proper resource management</li> </ol> <p>By understanding the Tab domain's architecture, capabilities, and patterns, you can create sophisticated browser automation scripts that effectively handle navigation, interaction, events, and state management in modern web applications. </p>"},{"location":"deep-dive/webelement-domain/","title":"WebElement Domain","text":"<p>The WebElement domain is a cornerstone of Pydoll's architecture, providing a rich representation of DOM elements that allows for intuitive and powerful interactions with web page components. This domain bridges the gap between high-level automation code and the underlying DOM elements rendered by the browser.</p> <pre><code>graph TB\n    Client[\"User Code\"] --&gt; Tab[\"Tab Domain\"]\n    Tab --&gt; FindElement[\"FindElementsMixin\"]\n    FindElement --&gt; WebElement[\"WebElement Domain\"]\n    WebElement --&gt; DOM[\"Browser DOM\"]\n\n    WebElement --&gt; Properties[\"Properties &amp; Attributes\"]\n    WebElement --&gt; Interactions[\"User Interactions\"]\n    WebElement --&gt; State[\"Element State\"]\n    WebElement --&gt; TextOperations[\"Text Operations\"]\n\n    class WebElement stroke:#4CAF50,stroke-width:3px</code></pre>"},{"location":"deep-dive/webelement-domain/#understanding-webelement","title":"Understanding WebElement","text":"<p>At its core, a WebElement represents a snapshot of a DOM element within a tab. Unlike traditional DOM references in JavaScript, a WebElement in Pydoll is:</p> <ol> <li>Asynchronous - All interactions follow Python's async/await pattern</li> <li>Persistent - Maintains a reference to the element across page changes</li> <li>Self-contained - Encapsulates all operations possible on a DOM element</li> <li>Intelligent - Implements specialized handling for different element types</li> </ol> <p>Each WebElement instance maintains several crucial pieces of information:</p> <pre><code>class WebElement(FindElementsMixin):\n    def __init__(\n        self,\n        object_id: str,\n        connection_handler: ConnectionHandler,\n        method: Optional[str] = None,\n        selector: Optional[str] = None,\n        attributes_list: list[str] = [],\n    ):\n        self._object_id = object_id\n        self._search_method = method\n        self._selector = selector\n        self._connection_handler = connection_handler\n        self._attributes: dict[str, str] = {}\n        self._def_attributes(attributes_list)\n</code></pre> <p>The core components include: - The <code>object_id</code> provides a remote JavaScript reference to the element - The <code>connection_handler</code> enables communication with the browser - The <code>_search_method</code> and <code>_selector</code> track how the element was found - The <code>_attributes</code> dictionary stores element attributes</p> <p>By inheriting from <code>FindElementsMixin</code>, each WebElement can also function as a starting point for finding child elements.</p>"},{"location":"deep-dive/webelement-domain/#technical-architecture","title":"Technical Architecture","text":"<p>The WebElement domain combines several key design patterns to provide a robust and flexible API:</p> <pre><code>classDiagram\n    class WebElement {\n        -_object_id: str\n        -_search_method: Optional[str]\n        -_selector: Optional[str]\n        -_connection_handler: ConnectionHandler\n        -_attributes: dict[str, str]\n        +click()\n        +click_using_js()\n        +type_text(text: str)\n        +insert_text(text: str)\n        +get_attribute(name: str)\n        +set_input_files(files: list[str])\n        +scroll_into_view()\n        +take_screenshot(path: str)\n        +text\n        +inner_html\n        +bounds\n        +value\n        +id\n        +class_name\n        +tag_name\n        +is_enabled\n    }\n\n    class FindElementsMixin {\n        +find(**kwargs) WebElement|List[WebElement]\n        +query(expression: str) WebElement|List[WebElement]\n        +find_or_wait_element(by: By, value: str, timeout: int) WebElement|List[WebElement]\n    }\n\n    class ConnectionHandler {\n        +execute_command(command: dict)\n    }\n\n    WebElement --|&gt; FindElementsMixin : inherits\n    WebElement *-- ConnectionHandler : uses</code></pre> <p>The architectural design follows several key principles:</p> <ol> <li>Command Pattern - Element interactions are translated into CDP commands</li> <li>Property System - Combines synchronous attribute access with asynchronous DOM property retrieval</li> <li>Mixin Inheritance - Inherits element finding capabilities through the FindElementsMixin</li> <li>Bridge Pattern - Abstracts the CDP protocol details from the user-facing API</li> </ol>"},{"location":"deep-dive/webelement-domain/#attribute-management","title":"Attribute Management","text":"<p>A unique aspect of WebElement's design is how it handles HTML attributes:</p> <pre><code>def _def_attributes(self, attributes_list: list):\n    \"\"\"\n    Defines element attributes from a flat list of key-value pairs.\n    \"\"\"\n    for i in range(0, len(attributes_list), 2):\n        key = attributes_list[i]\n        key = key if key != 'class' else 'class_name'\n        value = attributes_list[i + 1]\n        self._attributes[key] = value\n</code></pre> <p>This approach: 1. Processes attributes during element creation 2. Provides fast, synchronous access to common attributes 3. Handles Python reserved keywords (like <code>class</code> \u2192 <code>class_name</code>) 4. Forms the basis for the element's string representation</p> <p>Attribute vs. Property Access</p> <p>WebElement provides two complementary ways to access element data:</p> <ul> <li>Attribute Dictionary: Fast, synchronous access to HTML attributes available at element creation</li> <li>Asynchronous Properties: Dynamic access to current DOM state through CDP commands</li> </ul> <pre><code># Synchronous attribute access (from initial HTML)\nelement_id = element.id\nelement_class = element.class_name\n\n# Asynchronous property access (current state from DOM)\nelement_text = await element.text\nelement_bounds = await element.bounds\n</code></pre>"},{"location":"deep-dive/webelement-domain/#core-interaction-patterns","title":"Core Interaction Patterns","text":"<p>The WebElement domain provides several categories of interactions:</p>"},{"location":"deep-dive/webelement-domain/#element-properties","title":"Element Properties","text":"<p>WebElement offers both synchronous and asynchronous property access:</p> <pre><code># Synchronous properties (from attributes present at element creation)\nelement_id = element.id\nelement_class = element.class_name\nis_element_enabled = element.is_enabled\nelement_value = element.value\n\n# Asynchronous properties (retrieved from live DOM)\nelement_text = await element.text\nelement_html = await element.inner_html\nelement_bounds = await element.bounds\n</code></pre> <p>The implementation balances performance and freshness by determining which properties should be synchronous (static HTML attributes) and which should be asynchronous (dynamic DOM state):</p> <pre><code>@property\nasync def text(self) -&gt; str:\n    \"\"\"\n    Retrieves the text of the element.\n    \"\"\"\n    outer_html = await self.inner_html\n    soup = BeautifulSoup(outer_html, 'html.parser')\n    return soup.get_text(strip=True)\n\n@property\ndef id(self) -&gt; str:\n    \"\"\"\n    Retrieves the id of the element.\n    \"\"\"\n    return self._attributes.get('id')\n</code></pre>"},{"location":"deep-dive/webelement-domain/#mouse-interactions","title":"Mouse Interactions","text":"<p>WebElement provides multiple ways to interact with elements through mouse events:</p> <pre><code># Standard click at element center\nawait element.click()\n\n# Click with offset from center\nawait element.click(x_offset=10, y_offset=5)\n\n# Click with longer hold time (like for long press)\nawait element.click(hold_time=1.0)\n\n# JavaScript-based click (useful for elements that are difficult to click)\nawait element.click_using_js()\n</code></pre> <p>The implementation intelligently handles different element types and visibility states:</p> <pre><code>async def click(\n    self,\n    x_offset: int = 0,\n    y_offset: int = 0,\n    hold_time: float = 0.1,\n):\n    \"\"\"\n    Clicks on the element using mouse events.\n    \"\"\"\n    if self._is_option_tag():\n        return await self.click_option_tag()\n\n    if not await self._is_element_visible():\n        raise exceptions.ElementNotVisible(\n            'Element is not visible on the page.'\n        )\n\n    await self.scroll_into_view()\n\n    # Get element position and calculate click point\n    # ... (position calculation code)\n\n    # Send mouse press and release events\n    press_command = InputCommands.mouse_press(*position_to_click)\n    release_command = InputCommands.mouse_release(*position_to_click)\n    await self._connection_handler.execute_command(press_command)\n    await asyncio.sleep(hold_time)\n    await self._connection_handler.execute_command(release_command)\n</code></pre> <p>Special Element Handling</p> <p>The WebElement implementation includes specialized handling for different element types:</p> <pre><code># Option elements in dropdowns need special click handling\nif self._is_option_tag():\n    return await self.click_option_tag()\n\n# File inputs need special file selection handling\nawait input_element.set_input_files(\"path/to/file.pdf\")\n</code></pre>"},{"location":"deep-dive/webelement-domain/#keyboard-interactions","title":"Keyboard Interactions","text":"<p>WebElement provides multiple ways to input text into form elements:</p> <pre><code># Quick text insertion (faster but less realistic)\nawait element.insert_text(\"Hello, world!\")\n\n# Realistic typing with configurable speed\nawait element.type_text(\"Hello, world!\", interval=0.1)\n\n# Individual key events\nawait element.key_down(Key.CONTROL)\nawait element.key_down(Key.A)\nawait element.key_up(Key.A)\nawait element.key_up(Key.CONTROL)\n\n# Press and release key combination\nawait element.press_keyboard_key(Key.ENTER, interval=0.1)\n</code></pre> <p>File Upload Handling</p> <p>For file input elements, WebElement provides a specialized method:</p> <pre><code># Upload a single file\nawait file_input.set_input_files([\"path/to/file.pdf\"])\n\n# Upload multiple files\nawait file_input.set_input_files([\"file1.jpg\", \"file2.jpg\"])\n</code></pre>"},{"location":"deep-dive/webelement-domain/#visual-capabilities","title":"Visual Capabilities","text":""},{"location":"deep-dive/webelement-domain/#element-screenshots","title":"Element Screenshots","text":"<p>WebElement can capture screenshots of specific elements:</p> <pre><code># Take a screenshot of just this element\nawait element.take_screenshot(\"element.png\")\n\n# Take a high-quality screenshot\nawait element.take_screenshot(\"element.jpg\", quality=95)\n</code></pre> <p>This implementation involves: 1. Getting the element's bounds using JavaScript 2. Creating a clip region for the screenshot 3. Taking a screenshot of just that region 4. Saving the image to the specified path</p> <pre><code>async def take_screenshot(self, path: str, quality: int = 100):\n    \"\"\"\n    Capture screenshot of this element only.\n\n    Automatically scrolls element into view before capturing.\n    \"\"\"\n    bounds = await self.get_bounds_using_js()\n    clip = Viewport(\n        x=bounds['x'],\n        y=bounds['y'],\n        width=bounds['width'],\n        height=bounds['height'],\n        scale=1,\n    )\n    screenshot = await self._connection_handler.execute_command(\n        PageCommands.capture_screenshot(\n            format=ScreenshotFormat.JPEG, clip=clip, quality=quality\n        )\n    )\n    async with aiofiles.open(path, 'wb') as file:\n        image_bytes = decode_base64_to_bytes(screenshot['result']['data'])\n        await file.write(image_bytes)\n</code></pre> <p>Multiple Bounds Methods</p> <p>WebElement provides two ways to get element bounds:</p> <pre><code># Using the DOM domain (primary method)\nbounds = await element.bounds\n\n# Fallback using JavaScript (more reliable in some cases)\nbounds = await element.get_bounds_using_js()\n</code></pre>"},{"location":"deep-dive/webelement-domain/#javascript-integration","title":"JavaScript Integration","text":"<p>WebElement provides seamless integration with JavaScript for operations that require direct DOM interaction:</p> <pre><code># Execute JavaScript in the context of this element\nawait element._execute_script(\"this.style.border = '2px solid red';\")\n\n# Get result from JavaScript execution\nvisibility = await element._is_element_visible()\n</code></pre> <p>The implementation uses the CDP Runtime domain to execute JavaScript with the element as the context:</p> <pre><code>async def _execute_script(\n    self, script: str, return_by_value: bool = False\n):\n    \"\"\"\n    Executes a JavaScript script in the context of this element.\n    \"\"\"\n    return await self._execute_command(\n        RuntimeCommands.call_function_on(\n            self._object_id, script, return_by_value\n        )\n    )\n</code></pre>"},{"location":"deep-dive/webelement-domain/#element-state-verification","title":"Element State Verification","text":"<p>WebElement provides methods to check the element's visibility and interactability:</p> <pre><code># Check if element is visible\nis_visible = await element._is_element_visible()\n\n# Check if element is the topmost at its position\nis_on_top = await element._is_element_on_top()\n</code></pre> <p>These verifications are crucial for reliable automation, ensuring that elements can be interacted with before attempting operations.</p>"},{"location":"deep-dive/webelement-domain/#position-and-scrolling","title":"Position and Scrolling","text":"<p>The WebElement domain includes methods for positioning and scrolling:</p> <pre><code># Scroll element into view\nawait element.scroll_into_view()\n\n# Get element bounds\nbounds = await element.bounds\n</code></pre> <p>These capabilities ensure that elements are visible in the viewport before interaction, mimicking how a real user would interact with a page.</p>"},{"location":"deep-dive/webelement-domain/#performance-and-reliability-considerations","title":"Performance and Reliability Considerations","text":"<p>The WebElement domain balances performance and reliability through several key strategies:</p>"},{"location":"deep-dive/webelement-domain/#smart-fallbacks","title":"Smart Fallbacks","text":"<p>Many methods implement multiple approaches to ensure operations succeed even in challenging scenarios:</p> <pre><code>async def click(self, ...):\n    # Try using CDP mouse events first\n    # If that fails, fallback to JavaScript click\n    # If that fails, provide a clear error message\n</code></pre>"},{"location":"deep-dive/webelement-domain/#appropriate-context-selection","title":"Appropriate Context Selection","text":"<p>The implementation chooses the most appropriate context for each operation:</p> Operation Approach Rationale Get Text Parse HTML with BeautifulSoup More accurate text extraction Click Mouse events via CDP Most realistic user simulation Select Option Specialized JavaScript Required for dropdown elements Check Visibility JavaScript Most reliable across browser variations"},{"location":"deep-dive/webelement-domain/#command-batching","title":"Command Batching","text":"<p>Where possible, operations are combined to reduce round-trips to the browser:</p> <pre><code># Get element bounds in a single operation\nbounds = await element.get_bounds_using_js()\n\n# Calculate position in local code without additional browser calls\nposition_to_click = (\n    bounds['x'] + bounds['width'] / 2,\n    bounds['y'] + bounds['height'] / 2,\n)\n</code></pre>"},{"location":"deep-dive/webelement-domain/#conclusion","title":"Conclusion","text":"<p>The WebElement domain provides a comprehensive and intuitive interface for interacting with elements in a web page. By encapsulating the complexities of DOM interaction, event handling, and state management, it allows automation code to focus on high-level tasks rather than low-level details.</p> <p>The domain demonstrates several key design principles:</p> <ol> <li>Abstraction - Hides the complexity of CDP commands behind a clean API</li> <li>Specialization - Provides unique handling for different element types</li> <li>Hybrid Access - Balances synchronous and asynchronous operations for optimal performance</li> <li>Resilience - Implements fallback strategies for common operations</li> </ol> <p>When used in conjunction with the Tab domain and Browser domain, WebElement creates a powerful toolset for web automation that handles the complexities of modern web applications while providing a straightforward and reliable API for developers. </p>"}]}