__# æ ¸å¿ƒç‰¹æ€§

Pydollä¸ºæµè§ˆå™¨è‡ªåŠ¨åŒ–å¸¦æ¥äº†çªç ´æ€§çš„åŠŸèƒ½ï¼Œæ¯”ä¼ ç»Ÿæµè§ˆå™¨è‡ªåŠ¨åŒ–å·¥å…·æ›´åŠ å¼ºå¤§æ›´æ˜“äºä½¿ç”¨ã€‚

## æ ¸å¿ƒåŠŸèƒ½

### æ— WebDriverä¾èµ–

ä¸ä¼ ç»Ÿæµè§ˆå™¨è‡ªåŠ¨åŒ–æ¡†æ¶ï¼ˆä¾‹å¦‚Seleniumï¼‰ä¸åŒçš„æ˜¯ï¼ŒPydollå®Œå…¨æ¶ˆé™¤äº†å¯¹WebDriverçš„ä¾èµ–ã€‚é€šè¿‡ Chrome DevTools åè®®ç›´æ¥è¿æ¥åˆ°æµè§ˆå™¨ï¼ŒPydoll å¯ä»¥ï¼š

- æ¶ˆé™¤æµè§ˆå™¨å’Œé©±åŠ¨ç¨‹åºä¹‹é—´çš„ç‰ˆæœ¬å…¼å®¹æ€§é—®é¢˜
- é™ä½è®¾ç½®å¤æ‚æ€§å’Œç»´æŠ¤å¼€é”€
- æä¾›æ›´å¯é çš„è¿æ¥ï¼Œé¿å…é©±åŠ¨ç¨‹åºç›¸å…³é—®é¢˜
- å…è®¸ä½¿ç”¨ç»Ÿä¸€çš„ API å®ç°æ‰€æœ‰åŸºäº Chromium çš„æµè§ˆå™¨çš„è‡ªåŠ¨åŒ–

ä¸å†å‡ºç°â€œchromedriver ç‰ˆæœ¬ä¸ Chrome ç‰ˆæœ¬ä¸åŒ¹é…â€çš„é”™è¯¯æˆ–ç¥ç§˜çš„ webdriver å´©æºƒã€‚

### å¼‚æ­¥ä¼˜å…ˆæ¶æ„

Pydoll åŸºäº Python çš„ asyncio å…¨æ–°æ„å»ºï¼Œæä¾›ä»¥ä¸‹åŠŸèƒ½ï¼š

- **çœŸæ­£çš„å¹¶å‘**ï¼šå¹¶è¡Œè¿è¡Œå¤šä¸ªæ“ä½œï¼Œæ— é˜»å¡
- **é«˜æ•ˆçš„èµ„æºåˆ©ç”¨**ï¼šä»¥æœ€å°çš„å¼€é”€ç®¡ç†å¤šä¸ªæµè§ˆå™¨å®ä¾‹
- **ç°ä»£ Python æ¨¡å¼**ï¼šä¸Šä¸‹æ–‡ç®¡ç†å™¨ã€å¼‚æ­¥è¿­ä»£å™¨å’Œå…¶ä»–å¼‚æ­¥å‹å¥½æ¥å£
- **æ€§èƒ½ä¼˜åŒ–**ï¼šé™ä½è‡ªåŠ¨åŒ–ä»»åŠ¡çš„å»¶è¿Ÿå¹¶æé«˜ååé‡

### æ¨¡æ‹ŸçœŸäººäº¤äº’

é€šè¿‡æ¨¡ä»¿çœŸå®ç”¨æˆ·è¡Œä¸ºæ¥ç»•è¿‡åçˆ¬è¡Œä¸ºæ£€æµ‹ï¼š

- **è‡ªç„¶è¾“å…¥**ï¼šä»¥éšæœºçš„æŒ‰é”®æ—¶é—´è¾“å…¥æ–‡æœ¬
- **ä»¿çœŸç‚¹å‡»**ï¼šä»¥æ¨¡æ‹ŸçœŸäººçš„ç‚¹å‡»æ—¶é—´å’Œç§»åŠ¨æ–¹å¼è¿›è¡Œç‚¹å‡»ï¼ŒåŒ…æ‹¬åæ ‡åç§»

### äº‹ä»¶é©±åŠ¨åŠŸèƒ½

å®æ—¶å“åº”æµè§ˆå™¨äº‹ä»¶ï¼š

- **Network Monitoring**: Track requests, responses, and failed loads
- **DOM ç»“æ„è§‚æµ‹**: å“åº”é¡µé¢ç»“æ„çš„å˜åŒ–
- **é¡µé¢ç”Ÿå‘½å‘¨æœŸäº‹ä»¶**: æ•è·å¯¼èˆªã€åŠ è½½å’Œæ¸²æŸ“äº‹ä»¶
- **è‡ªå®šä¹‰äº‹ä»¶å¤„ç†ç¨‹åº**: ä¸ºæ„Ÿå…´è¶£çš„ç‰¹å®šäº‹ä»¶æ³¨å†Œå›è°ƒ


### å¤šæµè§ˆå™¨æ”¯æŒ

Pydollæ”¯æŒæ“ä½œä»»ä½•Chromiumæ ¸å¿ƒçš„æµè§ˆå™¨:

- **Google Chrome**ï¼šä¸»è¦æ”¯æŒæ‰€æœ‰å¯ç”¨åŠŸèƒ½
- **Microsoft Edge**ï¼šå…¨é¢æ”¯æŒ Edge ç‰¹å®šåŠŸèƒ½
- **Chromium**ï¼šæ”¯æŒå…¶ä»–åŸºäº Chromium çš„æµè§ˆå™¨


### å¯¼å‡ºç½‘é¡µæˆªå›¾å’ŒPDF

ä»ç½‘é¡µæˆªå›¾ï¼š

- **å…¨é¡µæˆªå›¾**ï¼šæˆªå–æ•´ä¸ªé¡µé¢å†…å®¹åŒ…æ‹¬è¶…å‡ºè§†å£èŒƒå›´çš„
- **å…ƒç´ æˆªå›¾**ï¼šæˆªå–ç‰¹å®šå…ƒç´ 
- **é«˜è´¨é‡ PDF å¯¼å‡º**ï¼šä»ç½‘é¡µç”Ÿæˆ PDF æ–‡æ¡£
- **è‡ªå®šä¹‰æ ¼å¼**ï¼šå³å°†æ¨å‡ºï¼

## ç›´è§‚çš„å…ƒç´ æŸ¥æ‰¾

Pydoll v2.0+ å¼•å…¥äº†ä¸€ç§é©å‘½æ€§çš„å…ƒç´ æŸ¥æ‰¾æ–¹æ³•ï¼Œæ¯”ä¼ ç»Ÿçš„åŸºäºé€‰æ‹©å™¨çš„æ–¹æ³•æ›´ç›´è§‚ã€æ›´å¼ºå¤§ã€‚

### ç°ä»£åŒ–çš„ find() æ–¹æ³•

å…¨æ–°çš„ `find()` æ–¹æ³•å…è®¸æ‚¨ä½¿ç”¨è‡ªç„¶å±æ€§æœç´¢å…ƒç´ ï¼š


```python
import asyncio
from pydoll.browser.chromium import Chrome

async def element_finding_examples():
    async with Chrome() as browser:
        tab = await browser.start()
        await tab.go_to('https://example.com')
        
        # Find by tag name and class
        submit_button = await tab.find(tag_name='button', class_name='btn-primary')
        
        # Find by ID (most common)
        username_field = await tab.find(id='username')
        
        # Find by text content
        login_link = await tab.find(tag_name='a', text='Login')
        
        # Find by multiple attributes
        search_input = await tab.find(
            tag_name='input',
            type='text',
            placeholder='Search...'
        )
        
        # Find with custom data attributes
        custom_element = await tab.find(
            data_testid='submit-button',
            aria_label='Submit form'
        )
        
        # Find multiple elements
        all_links = await tab.find(tag_name='a', find_all=True)
        
        # With timeout and error handling
        delayed_element = await tab.find(
            class_name='dynamic-content',
            timeout=10,
            raise_exc=False  # Returns None if not found
        )

asyncio.run(element_finding_examples())
```

### ä½¿ç”¨ query() å®ç° CSS é€‰æ‹©å™¨å’Œ XPath

å¯¹äºå–œæ¬¢ä¼ ç»Ÿé€‰æ‹©å™¨çš„å¼€å‘è€…ï¼Œ`query()` æ–¹æ³•æä¾›äº†ç›´æ¥çš„ CSS é€‰æ‹©å™¨å’Œ XPath æ”¯æŒï¼š

```python
import asyncio
from pydoll.browser.chromium import Chrome

async def query_examples():
    async with Chrome() as browser:
        tab = await browser.start()
        await tab.go_to('https://example.com')
        
        # CSS selectors
        nav_menu = await tab.query('nav.main-menu')
        first_article = await tab.query('article:first-child')
        submit_button = await tab.query('button[type="submit"]')
        
        # XPath expressions
        specific_item = await tab.query('//div[@data-testid="item-123"]')
        text_content = await tab.query('//span[contains(text(), "Welcome")]')
        
        # Complex selectors
        nested_element = await tab.query('div.container > .content .item:nth-child(2)')

asyncio.run(query_examples())
```

## åŸç”Ÿ Cloudflare éªŒè¯ç ç»•è¿‡

!!! è­¦å‘Šâ€œå…³äºéªŒè¯ç ç»•è¿‡çš„é‡è¦ä¿¡æ¯â€
Cloudflare Turnstile ç»•è¿‡çš„æœ‰æ•ˆæ€§å–å†³äºä»¥ä¸‹å‡ ä¸ªå› ç´ ï¼š

- **IPå¯ä¿¡åº¦**ï¼šCloudflare ä¸ºæ¯ä¸ª IP åœ°å€åˆ†é…ä¸€ä¸ªâ€œå¯ä¿¡åº¦â€ã€‚å¹²å‡€çš„ä½å®… IP é€šå¸¸ä¼šè·å¾—æ›´é«˜çš„åˆ†æ•°ã€‚
- **è¿‡å¾€å†å²è®°å½•**ï¼šæœ‰å¯ç–‘æ´»åŠ¨å†å²è®°å½•çš„ IP å¯èƒ½ä¼šè¢«æ°¸ä¹…æ ‡è®°ã€‚

Pydoll å¯ä»¥è·å¾—ä¸å¸¸è§„æµè§ˆå™¨ä¼šè¯ç›¸å½“çš„åˆ†æ•°ï¼Œä½†æ— æ³•è§£å†³IPè´¨é‡å¯¼è‡´çš„é£æ§ã€‚ä¸ºäº†è·å¾—æœ€ä½³æ•ˆæœï¼Œè¯·ä½¿ç”¨è´¨é‡è‰¯å¥½çš„ä½å®… IPã€‚

è¯·è®°ä½ï¼ŒéªŒè¯ç ç»•è¿‡æŠ€æœ¯å¤„äºç°è‰²åœ°å¸¦ï¼Œåº”è°¨æ…ä½¿ç”¨ã€‚

Pydoll æœ€å¼ºå¤§çš„åŠŸèƒ½ä¹‹ä¸€æ˜¯å®ƒèƒ½å¤Ÿè‡ªåŠ¨ç»•è¿‡é˜»æ­¢å¤§å¤šæ•°è‡ªåŠ¨åŒ–å·¥å…·çš„ Cloudflare Turnstile éªŒè¯ç ï¼š

### ä¸Šä¸‹æ–‡ç®¡ç†å™¨æ–¹æ³•ï¼ˆåŒæ­¥ï¼‰

```python
import asyncio
from pydoll.browser.chromium import Chrome

async def bypass_cloudflare_example():
    async with Chrome() as browser:
        tab = await browser.start()
    
    # The context manager will wait for the captcha to be processed
    # before continuing execution
        async with tab.expect_and_bypass_cloudflare_captcha():
            await tab.go_to('https://site-with-cloudflare.com')
        print("Waiting for captcha to be handled...")
    
    # This code runs only after the captcha is successfully bypassed
    print("Captcha bypassed! Continuing with automation...")
        protected_content = await tab.find(id='protected-content')
        content_text = await protected_content.text
        print(f"Protected content: {content_text}")

asyncio.run(bypass_cloudflare_example())
```

### åå°è‡ªåŠ¨å¤„ç†éªŒè¯ç 

```python
import asyncio
from pydoll.browser.chromium import Chrome

async def background_bypass_example():
    async with Chrome() as browser:
        tab = await browser.start()
    
    # Enable automatic captcha solving before navigating
        await tab.enable_auto_solve_cloudflare_captcha()
    
    # Navigate to the protected site - captcha handled automatically in background
        await tab.go_to('https://site-with-cloudflare.com')
    print("Page loaded, captcha will be handled in the background...")
    
    # Add a small delay to allow captcha solving to complete
    await asyncio.sleep(3)
    
    # Continue with automation
        protected_content = await tab.find(id='protected-content')
        content_text = await protected_content.text
        print(f"Protected content: {content_text}")
    
    # Disable auto-solving when no longer needed
        await tab.disable_auto_solve_cloudflare_captcha()

asyncio.run(background_bypass_example())
```

æ— éœ€ä½¿ç”¨ç¬¬ä¸‰æ–¹éªŒè¯ç æœåŠ¡ï¼Œå³å¯è®¿é—®å±è”½è‡ªåŠ¨åŒ–å·¥å…·çš„ç½‘ç«™ã€‚

## å¯é çš„ä¸‹è½½å¤„ç†ï¼šexpect_download

`tab.expect_download()` æä¾›ç¨³å¥çš„ã€åŸºäºäº‹ä»¶çš„æ–‡ä»¶ä¸‹è½½æ•è·æ–¹å¼ã€‚

- è‡ªåŠ¨ä¸ºæ‚¨é…ç½®æµè§ˆå™¨ä¸‹è½½è¡Œä¸º
- æ”¯æŒæŒä¹…åŒ–ç›®å½•ï¼ˆ`keep_file_at`ï¼‰ï¼Œæˆ–ä½¿ç”¨ä¸´æ—¶ç›®å½•å¹¶åœ¨é€€å‡ºä¸Šä¸‹æ–‡åè‡ªåŠ¨æ¸…ç†
- æä¾› `_DownloadHandle` ä¾¿æ·æ¥å£
- å†…ç½®è¶…æ—¶ä¿æŠ¤ï¼Œé¿å…æ— é™ç­‰å¾…

### API æ¦‚è§ˆ

```python
async with tab.expect_download(
    keep_file_at: Optional[str | Path] = None,
    timeout: Optional[float] = None,
) as handle:
    ... # åœ¨é¡µé¢ä¸­è§¦å‘ä¸‹è½½
```

- `keep_file_at`ï¼šæŒ‡å®šæŒä¹…åŒ–ç›®å½•ã€‚è‹¥ä¸º `None`ï¼Œåˆ™ä½¿ç”¨ä¸´æ—¶ç›®å½•å¹¶åœ¨é€€å‡ºä¸Šä¸‹æ–‡åè‡ªåŠ¨æ¸…ç†ã€‚
- `timeout`ï¼šå®Œæˆç­‰å¾…çš„æœ€å¤§ç§’æ•°ï¼ˆæœªæä¾›æ—¶é»˜è®¤ 60ï¼‰ã€‚

`handle` æä¾›ï¼š

- `handle.file_path: Optional[str]` â€” å®Œæˆåè§£æå‡ºçš„æœ€ç»ˆæ–‡ä»¶è·¯å¾„
- `await handle.read_bytes() -> bytes`
- `await handle.read_base64() -> str`
- `await handle.wait_started(timeout: Optional[float] = None) -> None`
- `await handle.wait_finished(timeout: Optional[float] = None) -> None`

### ä½¿ç”¨ç¤ºä¾‹

åœ¨æŒ‡å®šç›®å½•ä¸­æŒä¹…åŒ–ä¸‹è½½æ–‡ä»¶ï¼š

```python
async with tab.expect_download(keep_file_at='/tmp/dl', timeout=15) as dl:
    await (await tab.find(text='Export CSV')).click()
    data = await dl.read_bytes()
    print('Saved at:', dl.file_path)
```

ç”¨äºæµ‹è¯•çš„ä¸´æ—¶ç›®å½•ï¼ˆè‡ªåŠ¨æ¸…ç†ï¼‰ï¼š

```python
async with tab.expect_download() as dl:
    await (await tab.find(text='Download PDF')).click()
    pdf_b64 = await dl.read_base64()
    # é€€å‡ºä¸Šä¸‹æ–‡åä¸´æ—¶ç›®å½•ä¼šè¢«è‡ªåŠ¨æ¸…ç†
```

æ³¨æ„ï¼š

- å¦‚æœåœ¨é…ç½®çš„ `timeout` å†…é¡µé¢æœªå‘å‡ºå®Œæˆäº‹ä»¶ï¼Œå°†æŠ›å‡º `DownloadTimeout` å¼‚å¸¸ã€‚
- å¦‚æœæµè§ˆå™¨æœªæä¾› `filePath`ï¼Œç®¡ç†å™¨å°†å›é€€åˆ°ä½¿ç”¨å»ºè®®æ–‡ä»¶åå¹¶å†™å…¥é€‰å®šç›®å½•ã€‚

## å¤šæ ‡ç­¾é¡µç®¡ç†

Pydoll é‡‡ç”¨å•ä¾‹æ¨¡å¼æä¾›å®Œå–„çš„æ ‡ç­¾é¡µç®¡ç†åŠŸèƒ½ï¼Œç¡®ä¿èµ„æºé«˜æ•ˆåˆ©ç”¨ï¼Œå¹¶é˜²æ­¢åŒä¸€æµè§ˆå™¨æ ‡ç­¾é¡µå‡ºç°é‡å¤çš„æ ‡ç­¾é¡µå®ä¾‹ã€‚

### æ ‡ç­¾é¡µå•ä¾‹æ¨¡å¼

Pydoll æ ¹æ®æµè§ˆå™¨çš„ç›®æ ‡ ID ä¸ºæ ‡ç­¾é¡µå®ä¾‹å®ç°å•ä¾‹æ¨¡å¼ã€‚è¿™æ„å‘³ç€ï¼š

- **æ ‡ç­¾é¡µå¯¹è±¡å”¯ä¸€æ€§**ï¼šå¯¹åŒä¸€æµè§ˆå™¨æ ‡ç­¾é¡µçš„å¤šæ¬¡å¼•ç”¨å°†è¿”å›ç›¸åŒçš„æ ‡ç­¾é¡µå¯¹è±¡
- **è‡ªåŠ¨åŒ–èµ„æºæ²»ç†**ï¼šåŒä¸€æ ‡ç­¾é¡µä¸ä¼šå‡ºç°é‡å¤çš„è¿æ¥æˆ–å¤„ç†ç¨‹åº
- **å…¨å±€çŠ¶æ€ä¸€è‡´æ€§**ï¼šå¯¹åŒä¸€æ ‡ç­¾é¡µçš„æ‰€æœ‰å¼•ç”¨å…±äº«ç›¸åŒçš„çŠ¶æ€å’Œäº‹ä»¶å¤„ç†ç¨‹åº

```python
import asyncio
from pydoll.browser.chromium import Chrome
from pydoll.browser.tab import Tab

async def singleton_demonstration():
    async with Chrome() as browser:
        tab = await browser.start()
        
        # Get the same tab through different methods - they're identical objects
        same_tab = Tab(browser, browser._connection_port, tab._target_id)
        opened_tabs = await browser.get_opened_tabs()
        
        # All references point to the same singleton instance
        print(f"Same object? {tab is same_tab}")  # May be True if same target_id
        print(f"Tab instances are managed as singletons")

asyncio.run(singleton_demonstration())
```


### ç¨‹åºåŒ–åˆ›å»ºæ–°æ ‡ç­¾é¡µ

ä½¿ç”¨ `new_tab()` ç¨‹åºåŒ–åˆ›å»ºæ‹¥æœ‰å®Œå…¨æ§åˆ¶æƒçš„æ–°æ ‡ç­¾é¡µ: 

```python
import asyncio
from pydoll.browser.chromium import Chrome

async def programmatic_tab_creation():
    async with Chrome() as browser:
        # Start with the initial tab
        main_tab = await browser.start()
        
        # Create additional tabs with specific URLs
        search_tab = await browser.new_tab('https://google.com')
        news_tab = await browser.new_tab('https://news.ycombinator.com')
        docs_tab = await browser.new_tab('https://docs.python.org')
        
        # Work with multiple tabs simultaneously
        await search_tab.find(name='q').type_text('Python automation')
        await news_tab.find(class_name='storylink', find_all=True)
        await docs_tab.find(id='search-field').type_text('asyncio')
        
        # Get all opened tabs
        all_tabs = await browser.get_opened_tabs()
        print(f"Total tabs open: {len(all_tabs)}")
        
        # Close specific tabs when done
        await search_tab.close()
        await news_tab.close()

asyncio.run(programmatic_tab_creation())
```

### å¤„ç†ç”¨æˆ·æ‰“å¼€çš„æ ‡ç­¾é¡µ

å½“ç”¨æˆ·ç‚¹å‡»æ‰“å¼€æ–°æ ‡ç­¾é¡µ (target="_blank") çš„é“¾æ¥æ—¶ï¼Œä½¿ç”¨ `get_opened_tabs()` æ¥æ£€æµ‹å’Œç®¡ç†å®ƒä»¬ï¼š

```python
import asyncio
from pydoll.browser.chromium import Chrome

async def handle_user_opened_tabs():
    async with Chrome() as browser:
        main_tab = await browser.start()
        await main_tab.go_to('https://example.com')
        
        # Get initial tab count
        initial_tabs = await browser.get_opened_tabs()
        initial_count = len(initial_tabs)
        print(f"Initial tabs: {initial_count}")
        
        # Click a link that opens a new tab (target="_blank")
        external_link = await main_tab.find(text='Open in New Tab')
        await external_link.click()
        
        # Wait for new tab to open
        await asyncio.sleep(2)
        
        # Detect new tabs
        current_tabs = await browser.get_opened_tabs()
        new_tab_count = len(current_tabs)
        
        if new_tab_count > initial_count:
            print(f"New tab detected! Total tabs: {new_tab_count}")
            
            # Get the newly opened tab (last in the list)
            new_tab = current_tabs[-1]
            
            # Work with the new tab
            await new_tab.go_to('https://different-site.com')
            title = await new_tab.execute_script('return document.title')
            print(f"New tab title: {title}")
            
            # Close the new tab when done
            await new_tab.close()

asyncio.run(handle_user_opened_tabs())
```

### Pydoll æ ‡ç­¾é¡µç®¡ç†çš„ä¸»è¦ä¼˜åŠ¿

1. **å•ä¾‹æ¨¡å¼**ï¼šé˜²æ­¢èµ„æºé‡å¤å¹¶ç¡®ä¿çŠ¶æ€ä¸€è‡´
2. **è‡ªåŠ¨æ£€æµ‹**ï¼š`get_opened_tabs()` æŸ¥æ‰¾æ‰€æœ‰æ ‡ç­¾é¡µï¼ŒåŒ…æ‹¬ç”¨æˆ·æ‰“å¼€çš„æ ‡ç­¾é¡µ
3. **å¹¶å‘å¤„ç†**ï¼šä½¿ç”¨ asyncio åŒæ—¶å¤„ç†å¤šä¸ªæ ‡ç­¾é¡µ
4. **èµ„æºç®¡ç†**ï¼šé€‚å½“çš„æ¸…ç†å¯é˜²æ­¢å†…å­˜æ³„æ¼
5. **äº‹ä»¶éš”ç¦»**ï¼šæ¯ä¸ªæ ‡ç­¾é¡µéƒ½ç»´æŠ¤è‡ªå·±çš„äº‹ä»¶å¤„ç†ç¨‹åºå’ŒçŠ¶æ€

è¿™ç§å¤æ‚çš„æ ‡ç­¾é¡µç®¡ç†åŠŸèƒ½ä½¿ Pydoll éå¸¸é€‚åˆï¼š
- éœ€è¦æ ‡ç­¾é¡µä¹‹é—´åè°ƒçš„**å¤šé¡µé¢å·¥ä½œæµ**
- ä»å¤šä¸ªæ¥æº**å¹¶è¡Œæå–æ•°æ®**
- ä½¿ç”¨å¼¹å‡ºçª—å£æˆ–æ–°æ ‡ç­¾é¡µçš„**æµ‹è¯•åº”ç”¨ç¨‹åº**
- è·¨å¤šä¸ªæµè§ˆå™¨æ ‡ç­¾é¡µ**ç›‘æ§ç”¨æˆ·è¡Œä¸º**

## å¹¶å‘æŠ“å–

Pydoll çš„å¼‚æ­¥æ¶æ„å…è®¸æ‚¨åŒæ—¶æŠ“å–å¤šä¸ªé¡µé¢æˆ–ç½‘ç«™ï¼Œä»¥å®ç°æœ€é«˜æ•ˆç‡ï¼š

```python
import asyncio
from functools import partial
from pydoll.browser.chromium import Chrome

async def scrape_page(browser, url):
    """Process a single page and extract data using a shared browser"""
    # Create a new tab for this URL
    tab = await browser.new_tab()
    
    try:
        await tab.go_to(url)
        
        # Extract data
        title = await tab.execute_script('return document.title')
        
        # Find elements and extract content
        elements = await tab.find(class_name='article-content', find_all=True)
        content = []
        for element in elements:
            text = await element.text
            content.append(text)
            
        return {
            "url": url,
            "title": title,
            "content": content
        }
    finally:
        # Close the tab when done to free resources
        await tab.close()

async def main():
    # List of URLs to scrape in parallel
    urls = [
        'https://example.com/page1',
        'https://example.com/page2',
        'https://example.com/page3',
        'https://example.com/page4',
        'https://example.com/page5',
    ]
    
    async with Chrome() as browser:
        # Start the browser once
        await browser.start()
        
        # Create partial function with browser parameter
        scrape_with_browser = partial(scrape_page, browser)
        
        # Process all URLs concurrently using the same browser
        results = await asyncio.gather(*(scrape_with_browser(url) for url in urls))
    
    # Print results
    for result in results:
        print(f"Scraped {result['url']}: {result['title']}")
        print(f"Found {len(result['content'])} content blocks")
    
    return results

# Run the concurrent scraping
all_data = asyncio.run(main())
```


ä¸å•çº¿ç¨‹æ§åˆ¶æ ‡ç­¾é¡µæŠ“å–ç›¸æ¯”ï¼Œè¿™ç§æ–¹æ³•æ˜¾è‘—æå‡äº†æ€§èƒ½ï¼Œå°¤å…¶é€‚ç”¨äºåƒç½‘é¡µæŠ“å–è¿™æ · I/O å¯†é›†å‹ä»»åŠ¡ã€‚Pydoll æ— éœ€ç­‰å¾…æ¯ä¸ªé¡µé¢é€ä¸ªåŠ è½½ï¼Œè€Œæ˜¯åŒæ—¶å¤„ç†æ‰€æœ‰é¡µé¢ï¼Œä»è€Œæ˜¾è‘—ç¼©çŸ­äº†æ€»æ‰§è¡Œæ—¶é—´ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæŠ“å– 10 ä¸ªé¡µé¢ï¼Œæ¯ä¸ªé¡µé¢åŠ è½½æ—¶é—´ä¸º 2 ç§’ï¼Œé‚£ä¹ˆæ€»å…±åªéœ€ 2 ç§’å¤šä¸€ç‚¹ï¼Œè€Œå•çº¿ç¨‹å¤„ç†åˆ™éœ€è¦ 20 å¤šç§’ã€‚

## é«˜çº§é”®ç›˜æ§åˆ¶

Pydoll æä¾›ä»¿çœŸçš„é”®ç›˜äº¤äº’ï¼Œå¹¶å¯ç²¾ç¡®æ§åˆ¶è¾“å…¥è¡Œä¸ºï¼š


```python
import asyncio
from pydoll.browser.chromium import Chrome
from pydoll.common.keys import Keys

async def realistic_typing_example():
    async with Chrome() as browser:
        tab = await browser.start()
        await tab.go_to('https://example.com/login')
        
        # Find login form elements
        username = await tab.find(id='username')
        password = await tab.find(id='password')
        
        # Type with realistic timing (interval between keystrokes)
        await username.type_text("user@example.com", interval=0.15)
        
        # Use special key combinations
        await password.click()
        await password.key_down(Keys.SHIFT)
        await password.type_text("PASSWORD")
        await password.key_up(Keys.SHIFT)
        
        # Press Enter to submit
        await password.press_keyboard_key(Keys.ENTER)
        
        # Wait for navigation
        await asyncio.sleep(2)
        print("Logged in successfully!")

asyncio.run(realistic_typing_example())
```

è¿™ç§ä»¿çœŸçš„è¾“å…¥æ–¹å¼æœ‰åŠ©äºé¿å…è¢«é‚£äº›æœ‰ç”¨æˆ·è¡Œä¸ºæ£€æµ‹çš„ç½‘ç«™æ£€æµ‹åˆ°ã€‚æ¨¡æ‹ŸçœŸäººæ“ä½œå’Œä½¿ç”¨ç‰¹æ®Šç»„åˆé”®çš„èƒ½åŠ›ä½¿å¾— Pydoll çš„äº¤äº’å‡ ä¹ä¸äººç±»ç”¨æˆ·éš¾ä»¥åŒºåˆ†ã€‚

## å¼ºå¤§çš„äº‹ä»¶ç³»ç»Ÿ

Pydoll çš„äº‹ä»¶ç³»ç»Ÿå…è®¸æ‚¨å®æ—¶å“åº”æµè§ˆå™¨äº‹ä»¶ï¼š


```python
import asyncio
from pydoll.browser.chromium import Chrome
from pydoll.protocol.page.events import PageEvent

async def event_monitoring_example():
    async with Chrome() as browser:
        tab = await browser.start()
        
        # Monitor page load events
        async def on_page_loaded(event):
            print(f"ğŸŒ Page loaded: {event['params'].get('url')}")
            
        await tab.enable_page_events()
        await tab.on(PageEvent.LOAD_EVENT_FIRED, on_page_loaded)
        
        # Monitor network requests
        async def on_request(event):
            url = event['params']['request']['url']
            print(f"ğŸ”„ Request to: {url}")
            
        await tab.enable_network_events()
        await tab.on('Network.requestWillBeSent', on_request)
        
        # Navigate and see events in action
        await tab.go_to('https://example.com')
        await asyncio.sleep(5)  # Allow time to see events
        
asyncio.run(event_monitoring_example())
```

äº‹ä»¶ç³»ç»Ÿä½¿ Pydoll åœ¨ç›‘æ§ API è¯·æ±‚å’Œå“åº”ã€åˆ›å»ºå“åº”å¼è‡ªåŠ¨åŒ–ã€è°ƒè¯•å¤æ‚çš„ Web åº”ç”¨ç¨‹åºä»¥åŠæ„å»ºå…¨é¢çš„ Web ç›‘æ§å·¥å…·æ–¹é¢æ‹¥æœ‰ç‹¬ç‰¹çš„å¼ºå¤§åŠŸèƒ½ã€‚

## ç½‘ç»œåˆ†æå’Œå“åº”æå–

Pydoll æä¾›äº†å¼ºå¤§çš„æ–¹æ³•æ¥åˆ†æç½‘ç»œæµé‡å¹¶ä» Web åº”ç”¨ç¨‹åºä¸­æå–å“åº”æ•°æ®ã€‚è¿™äº›åŠŸèƒ½é€‚ç”¨äºAPI ç›‘æ§ã€æ•°æ®æå–å’Œè°ƒè¯•ç½‘ç»œç›¸å…³é—®é¢˜ã€‚

### ç½‘ç»œæ—¥å¿—åˆ†æ

`get_network_logs()` æ–¹æ³•å…è®¸æ‚¨æŸ¥æ‰¾å’Œåˆ†æé¡µé¢å‘å‡ºçš„æ‰€æœ‰ç½‘ç»œè¯·æ±‚ï¼š

```python
import asyncio
from pydoll.browser.chromium import Chrome

async def network_analysis_example():
    async with Chrome() as browser:
        tab = await browser.start()
        
        # Enable network monitoring
        await tab.enable_network_events()
        
        # Navigate to a page with API calls
        await tab.go_to('https://example.com/dashboard')
        
        # Wait for page to load and make requests
        await asyncio.sleep(3)
        
        # Get all network logs
        all_logs = await tab.get_network_logs()
        print(f"Total network requests: {len(all_logs)}")
        
        # Filter logs for API requests only
        api_logs = await tab.get_network_logs(filter='api')
        print(f"API requests: {len(api_logs)}")
        
        # Filter logs for specific domain
        domain_logs = await tab.get_network_logs(filter='example.com')
        print(f"Requests to example.com: {len(domain_logs)}")
        
        # Analyze request patterns
        for log in api_logs:
            request = log['params'].get('request', {})
            url = request.get('url', 'Unknown')
            method = request.get('method', 'Unknown')
            print(f"ğŸ“¡ {method} {url}")

asyncio.run(network_analysis_example())
```

### å“åº”ä½“æå–

`get_network_response_body()` æ–¹æ³•å¯è®©æ‚¨ä»ç½‘ç»œè¯·æ±‚ä¸­æå–å®é™…çš„å“åº”å†…å®¹ï¼š

```python
import asyncio
import json
from functools import partial
from pydoll.browser.chromium import Chrome
from pydoll.protocol.network.events import NetworkEvent

async def response_extraction_example():
    async with Chrome() as browser:
        tab = await browser.start()
        
        # Storage for API responses
        api_responses = {}
        
        async def capture_api_responses(tab, event):
            """Capture API response bodies"""
            request_id = event['params']['requestId']
            response = event['params']['response']
            url = response['url']
            
            # Only capture successful API responses
            if '/api/' in url and response['status'] == 200:
                try:
                    # Extract the response body
                    body = await tab.get_network_response_body(request_id)
                    
                    # Try to parse as JSON
                    try:
                        data = json.loads(body)
                        api_responses[url] = data
                        print(f"âœ… Captured API response from: {url}")
                        print(f"Data keys: {list(data.keys()) if isinstance(data, dict) else 'Non-dict response'}")
                    except json.JSONDecodeError:
                        # Handle non-JSON responses
                        api_responses[url] = body
                        print(f"ğŸ“„ Captured text response from: {url} ({len(body)} chars)")
                        
                except Exception as e:
                    print(f"âŒ Failed to get response body for {url}: {e}")
        
        # Enable network monitoring and register callback
        await tab.enable_network_events()
        await tab.on(NetworkEvent.RESPONSE_RECEIVED, partial(capture_api_responses, tab))
        
        # Navigate to a page with API calls
        await tab.go_to('https://jsonplaceholder.typicode.com')
        
        # Trigger some API calls by interacting with the page
        await asyncio.sleep(5)
        
        # Display captured responses
        print(f"\nğŸ“Š Analysis Results:")
        print(f"Captured {len(api_responses)} API responses")
        
        for url, data in api_responses.items():
            if isinstance(data, dict):
                print(f"ğŸ”— {url}: {len(data)} fields")
            else:
                print(f"ğŸ”— {url}: {len(str(data))} characters")
        
        return api_responses

asyncio.run(response_extraction_example())
```

### é«˜çº§ç½‘ç»œç›‘æ§

ç»“åˆä¸¤ç§æ–¹æ³•è¿›è¡Œå…¨é¢çš„ç½‘ç»œåˆ†æï¼š

```python
import asyncio
from pydoll.browser.chromium import Chrome

async def comprehensive_network_monitoring():
    async with Chrome() as browser:
        tab = await browser.start()
        
        # Enable network monitoring
        await tab.enable_network_events()
        
        # Navigate to a complex web application
        await tab.go_to('https://example.com/app')
        
        # Wait for initial page load and API calls
        await asyncio.sleep(5)
        
        # Get comprehensive network analysis
        all_logs = await tab.get_network_logs()
        api_logs = await tab.get_network_logs(filter='api')
        static_logs = await tab.get_network_logs(filter='.js')
        
        print(f"ğŸ“ˆ Network Traffic Summary:")
        print(f"   Total requests: {len(all_logs)}")
        print(f"   API calls: {len(api_logs)}")
        print(f"   JavaScript files: {len(static_logs)}")
        
        # Analyze request types
        request_types = {}
        for log in all_logs:
            request = log['params'].get('request', {})
            url = request.get('url', '')
            
            if '/api/' in url:
                request_types['API'] = request_types.get('API', 0) + 1
            elif any(ext in url for ext in ['.js', '.css', '.png', '.jpg']):
                request_types['Static'] = request_types.get('Static', 0) + 1
            else:
                request_types['Other'] = request_types.get('Other', 0) + 1
        
        print(f"ğŸ“Š Request breakdown: {request_types}")
        
        # Show API endpoints
        print(f"\nğŸ”— API Endpoints Called:")
        for log in api_logs[:10]:  # Show first 10
            request = log['params'].get('request', {})
            method = request.get('method', 'GET')
            url = request.get('url', 'Unknown')
            print(f"   {method} {url}")

asyncio.run(comprehensive_network_monitoring())
```

ç½‘ç»œåˆ†æåŠŸèƒ½éå¸¸é€‚åˆä»¥ä¸‹æƒ…å†µï¼š

- **API æµ‹è¯•**ï¼šç›‘æ§å’ŒéªŒè¯ API å“åº”
- **æ€§èƒ½åˆ†æ**ï¼šè·Ÿè¸ªè¯·æ±‚æ—¶é—´å’Œå¤§å°
- **æ•°æ®æå–**ï¼šæå–é€šè¿‡ AJAX åŠ è½½çš„åŠ¨æ€å†…å®¹
- **è°ƒè¯•**ï¼šè¯†åˆ«å¤±è´¥çš„è¯·æ±‚å’Œç½‘ç»œé—®é¢˜
- **å®‰å…¨æµ‹è¯•**ï¼šåˆ†æè¯·æ±‚/å“åº”æ¨¡å¼

## ä¸Šä¼ æ–‡ä»¶æ”¯æŒ

åœ¨æ‚¨çš„è‡ªåŠ¨åŒ–è„šæœ¬ä¸­æ— ç¼ä¸Šä¼ æ–‡ä»¶:

```python
import asyncio
import os
from pydoll.browser.chromium import Chrome

async def file_upload_example():
    async with Chrome() as browser:
        tab = await browser.start()
        await tab.go_to('https://example.com/upload')
        
        # Method 1: Direct file input
        file_input = await tab.find(tag_name='input', type='file')
        await file_input.set_input_files('path/to/document.pdf')
        
        # Method 2: Using file chooser with an upload button
        sample_file = os.path.join(os.getcwd(), 'sample.jpg')
        async with tab.expect_file_chooser(files=sample_file):
            upload_button = await tab.find(id='upload-button')
            await upload_button.click()
            
        # Submit the form
        submit = await tab.find(id='submit-button')
        await submit.click()
        
        print("Files uploaded successfully!")

asyncio.run(file_upload_example())
```

åœ¨å…¶ä»–æ¡†æ¶ä¸­ï¼Œæ–‡ä»¶ä¸Šä¼ çš„è‡ªåŠ¨åŒ–éš¾åº¦éå¸¸é«˜ï¼Œé€šå¸¸éœ€è¦ä¸€äº›å˜é€šæ–¹æ³•ã€‚Pydoll é€šè¿‡ç›´æ¥æ–‡ä»¶è¾“å…¥å’Œæ–‡ä»¶é€‰æ‹©å™¨å¯¹è¯æ¡†æ”¯æŒï¼Œè®©è¿™é¡¹å·¥ä½œå˜å¾—ç®€å•æ˜“è¡Œã€‚

## å¤šæµè§ˆå™¨ç¤ºä¾‹

Pydollé€šè¿‡ä¸€è‡´çš„APIå…¼å®¹ä¸åŒçš„æµè§ˆå™¨ï¼š

```python
import asyncio
from pydoll.browser.chromium import Chrome, Edge

async def multi_browser_example():
    # Run the same automation in Chrome
    async with Chrome() as chrome:
        chrome_tab = await chrome.start()
        await chrome_tab.go_to('https://example.com')
        chrome_title = await chrome_tab.execute_script('return document.title')
        print(f"Chrome title: {chrome_title}")
    
    # Run the same automation in Edge
    async with Edge() as edge:
        edge_tab = await edge.start()
        await edge_tab.go_to('https://example.com')
        edge_title = await edge_tab.execute_script('return document.title')
        print(f"Edge title: {edge_title}")

asyncio.run(multi_browser_example())
```

æ— éœ€æ›´æ”¹ä»£ç å³å¯å®ç°è·¨æµè§ˆå™¨å…¼å®¹æ€§ã€‚è·¨ä¸åŒæµè§ˆå™¨æµ‹è¯•æ‚¨çš„è‡ªåŠ¨åŒ–åŠŸèƒ½ï¼Œç¡®ä¿å…¶åœ¨æ‰€æœ‰æµè§ˆå™¨ä¸­éƒ½èƒ½æ­£å¸¸è¿è¡Œã€‚  

## é›†æˆä»£ç†

ä¸è®¸å¤šè‡ªåŠ¨åŒ–å·¥å…·åœ¨ä»£ç†å®ç°æ–¹é¢é‡åˆ°å›°éš¾ä¸åŒï¼ŒPydoll æä¾›åŸç”Ÿä»£ç†æ”¯æŒå’Œå®Œæ•´çš„èº«ä»½éªŒè¯åŠŸèƒ½ã€‚è¿™ä½¿å…¶æˆä¸ºä»¥ä¸‹åº”ç”¨çš„ç†æƒ³ä¹‹é€‰ï¼š  

- éœ€è¦è½®æ¢ IP åœ°å€çš„ **Web æ•°æ®æŠ“å–** é¡¹ç›®
- è·¨ä¸åŒåŒºåŸŸè¿›è¡Œåº”ç”¨ç¨‹åºçš„ **åœ°ç†å®šä½æµ‹è¯•**
- éœ€è¦åŒ¿åæµé‡çš„ **æ³¨é‡éšç§çš„è‡ªåŠ¨åŒ–**
- é€šè¿‡ä¼ä¸šä»£ç†è¿›è¡Œ **Web åº”ç”¨ç¨‹åºæµ‹è¯•**

åœ¨ Pydollä¸­é…ç½®ä»£ç†éå¸¸ç®€å•ï¼š  

```python
import asyncio
from pydoll.browser.chromium import Chrome
from pydoll.browser.options import ChromiumOptions

async def proxy_example():
    # Create browser options
    options = ChromiumOptions()
    
    # Simple proxy without authentication
    options.add_argument('--proxy-server=192.168.1.100:8080')
    # Or proxy with authentication
    # options.add_argument('--proxy-server=username:password@192.168.1.100:8080')
    
    # Bypass proxy for specific domains
    options.add_argument('--proxy-bypass-list=*.internal.company.com,localhost')

    # Start browser with proxy configuration
    async with Chrome(options=options) as browser:
        tab = await browser.start()
        
        # Test the proxy by visiting an IP echo service
        await tab.go_to('https://api.ipify.org')
        ip_address = await tab.execute_script('return document.body.textContent')
        print(f"Current IP address: {ip_address}")
        
        # Continue with your automation
        await tab.go_to('https://example.com')
        title = await tab.execute_script('return document.title')
        print(f"Page title: {title}")

asyncio.run(proxy_example())
```

## ä½¿ç”¨iFrames

Pydollæä¾›äº†
Pydoll é€šè¿‡ `get_frame()` æ–¹æ³•æä¾›æ— ç¼çš„ iframe äº¤äº’ï¼š

```python
import asyncio
from pydoll.browser.chromium import Chrome

async def iframe_interaction():
    async with Chrome() as browser:
        tab = await browser.start()
        await tab.go_to('https://example.com/page-with-iframe')
        
        # Find the iframe element
        iframe_element = await tab.query('.hcaptcha-iframe', timeout=10)
        
        # Get a Tab instance for the iframe content
        frame = await tab.get_frame(iframe_element)
        
        # Now interact with elements inside the iframe
        submit_button = await frame.find(tag_name='button', class_name='submit')
        await submit_button.click()
        
        # You can use all Tab methods on the frame
        form_input = await frame.find(id='captcha-input')
        await form_input.type_text('verification-code')
        
        # Find elements by various methods
        links = await frame.find(tag_name='a', find_all=True)
        specific_element = await frame.query('#specific-id')

asyncio.run(iframe_interaction())
```

## è¯·æ±‚æ‹¦æˆª

åœ¨ç½‘ç»œè¯·æ±‚å‘é€ä¹‹å‰æ‹¦æˆªå¹¶ä¿®æ”¹å®ƒä»¬ï¼š

### ç®€å•è¯·æ±‚ä¿®æ”¹ä¾‹å­

```python
import asyncio
from pydoll.browser.chromium import Chrome

async def request_interception_example():
    async with Chrome() as browser:
        tab = await browser.start()
        
        # Define the request interceptor
        async def intercept_request(event):
            request_id = event['params']['requestId']
            url = event['params']['request']['url']
            
            if '/api/' in url:
                # Get original headers
                original_headers = event['params']['request'].get('headers', {})
                
                # Add custom headers
                custom_headers = {
                    **original_headers,
                    'Authorization': 'Bearer my-token-123',
                    'X-Custom-Header': 'CustomValue'
                }
                
                print(f"ğŸ”„ Modifying request to: {url}")
                await tab.continue_request(
                        request_id=request_id,
                        headers=custom_headers
                )
            else:
                # Continue normally for non-API requests
                await tab.continue_request(request_id=request_id)
        
        # Enable interception and register handler
        await tab.enable_request_interception()
        await tab.on('Fetch.requestPaused', intercept_request)
        
        # Navigate to trigger requests
        await tab.go_to('https://example.com')
        await asyncio.sleep(5)  # Allow time for requests to process

asyncio.run(request_interception_example())
```

### æ‹¦æˆªæŒ‡å®šè¯·æ±‚

ä½¿ç”¨ `fail_request` å¯ä»¥æ‹¦æˆªæŒ‡å®šè¯·æ±‚ä¾‹å¦‚å¹¿å‘Šã€éšç§è¿½è¸ªå™¨ã€ä¸æƒ³è¦çš„ç½‘é¡µèµ„æº:

```python
import asyncio
from pydoll.browser.chromium import Chrome

async def block_requests_example():
    async with Chrome() as browser:
        tab = await browser.start()
        
        # Define blocked domains and resource types
        blocked_domains = ['doubleclick.net', 'googletagmanager.com', 'facebook.com']
        blocked_resources = ['image', 'stylesheet', 'font']
        
        async def block_unwanted_requests(event):
            request_id = event['params']['requestId']
            url = event['params']['request']['url']
            resource_type = event['params'].get('resourceType', '').lower()
            
            # Block requests from specific domains
            if any(domain in url for domain in blocked_domains):
                print(f"ğŸš« Blocking request to: {url}")
                await tab.fail_request(
                    request_id=request_id,
                    error_reason='BlockedByClient'
                )
                return
            
            # Block specific resource types (images, CSS, fonts)
            if resource_type in blocked_resources:
                print(f"ğŸš« Blocking {resource_type}: {url}")
                await tab.fail_request(
                    request_id=request_id,
                    error_reason='BlockedByClient'
                )
                return
            
            # Continue with allowed requests
            await tab.continue_request(request_id=request_id)
        
        # Enable interception and register handler
        await tab.enable_request_interception()
        await tab.on('Fetch.requestPaused', block_unwanted_requests)
        
        # Navigate to a page with many external resources
        await tab.go_to('https://example.com')
        await asyncio.sleep(10)  # Allow time to see blocked requests

asyncio.run(block_requests_example())
```

### æ‹¦æˆªä¿®æ”¹APIå“åº”

ä½¿ç”¨ `fulfill_request` å¯ä»¥åšåˆ°ä¸è¯·æ±‚åç«¯ç›´æ¥æ¨¡æ‹Ÿè¯·æ±‚è¿”å›:

```python
import asyncio
import json
from pydoll.browser.chromium import Chrome

async def mock_api_responses_example():
    async with Chrome() as browser:
        tab = await browser.start()
        
        async def mock_api_requests(event):
            request_id = event['params']['requestId']
            url = event['params']['request']['url']
            
            # Mock user API endpoint
            if '/api/user' in url:
                mock_user_data = {
                    "id": 123,
                    "name": "John Doe",
                    "email": "john@example.com",
                    "role": "admin"
                }
                
                print(f"ğŸ­ Mocking API response for: {url}")
                await tab.fulfill_request(
                    request_id=request_id,
                    response_code=200,
                    response_headers={
                        'Content-Type': 'application/json',
                        'Access-Control-Allow-Origin': '*'
                    },
                    body=json.dumps(mock_user_data)
                )
                return
            
            # Mock products API endpoint
            elif '/api/products' in url:
                mock_products = [
                    {"id": 1, "name": "Product A", "price": 29.99},
                    {"id": 2, "name": "Product B", "price": 39.99},
                    {"id": 3, "name": "Product C", "price": 19.99}
                ]
                
                print(f"ğŸ­ Mocking products API response for: {url}")
                await tab.fulfill_request(
                    request_id=request_id,
                    response_code=200,
                    response_headers={'Content-Type': 'application/json'},
                    body=json.dumps(mock_products)
                )
                return
            
            # Simulate API error for specific endpoints
            elif '/api/error' in url:
                error_response = {"error": "Internal Server Error", "code": 500}
                
                print(f"ğŸ­ Mocking error response for: {url}")
                await tab.fulfill_request(
                    request_id=request_id,
                    response_code=500,
                    response_headers={'Content-Type': 'application/json'},
                    body=json.dumps(error_response)
                )
                return
            
            # Continue with real requests for everything else
            await tab.continue_request(request_id=request_id)
        
        # Enable interception and register handler
        await tab.enable_request_interception()
        await tab.on('Fetch.requestPaused', mock_api_requests)
        
        # Navigate to a page that makes API calls
        await tab.go_to('https://example.com/dashboard')
        await asyncio.sleep(5)  # Allow time for API calls

asyncio.run(mock_api_responses_example())
```

### é«˜çº§è¯·æ±‚æ“ä½œ

æ•´åˆæ‰€æœ‰æ‹¦æˆªæ–¹æ³•ï¼Œå®ç°å…¨é¢çš„è¯·æ±‚æ§åˆ¶ï¼š

```python
import asyncio
import json
from pydoll.browser.chromium import Chrome

async def advanced_request_control():
    async with Chrome() as browser:
        tab = await browser.start()
        
        async def advanced_interceptor(event):
            request_id = event['params']['requestId']
            url = event['params']['request']['url']
            method = event['params']['request']['method']
            headers = event['params']['request'].get('headers', {})
            
            print(f"ğŸ“¡ Intercepted {method} request to: {url}")
            
            # Block analytics and tracking
            if any(tracker in url for tracker in ['analytics', 'tracking', 'ads']):
                print(f"ğŸš« Blocked tracking request: {url}")
                await tab.fail_request(request_id=request_id, error_reason='BlockedByClient')
                return
            
            # Mock authentication endpoint
            if '/auth/login' in url and method == 'POST':
                mock_auth_response = {
                    "success": True,
                    "token": "mock-jwt-token-12345",
                    "user": {"id": 1, "username": "testuser"}
                }
                print(f"ğŸ­ Mocking login response")
                await tab.fulfill_request(
                    request_id=request_id,
                    response_code=200,
                    response_headers={'Content-Type': 'application/json'},
                    body=json.dumps(mock_auth_response)
                )
                return
            
            # Add authentication to API requests
            if '/api/' in url and 'Authorization' not in headers:
                modified_headers = {
                    **headers,
                    'Authorization': 'Bearer mock-token-12345',
                    'X-Test-Mode': 'true'
                }
                print(f"ğŸ”§ Adding auth headers to: {url}")
                await tab.continue_request(
                    request_id=request_id,
                    headers=modified_headers
                )
                return
            
            # Continue with unmodified request
            await tab.continue_request(request_id=request_id)
        
        # Enable interception
        await tab.enable_request_interception()
        await tab.on('Fetch.requestPaused', advanced_interceptor)
        
        # Test the interception
        await tab.go_to('https://example.com/app')
        await asyncio.sleep(10)

asyncio.run(advanced_request_control())
```

è¿™é¡¹å¼ºå¤§çš„åŠŸèƒ½å…è®¸æ‚¨ï¼š

- ä¸ºAPIè¯·æ±‚**åŠ¨æ€æ·»åŠ èº«ä»½éªŒè¯æ ‡å¤´**
- **å±è”½ä¸éœ€è¦çš„èµ„æº**ï¼Œä¾‹å¦‚å¹¿å‘Šã€è·Ÿè¸ªå™¨å’Œå¤§å›¾ç‰‡ï¼Œä»¥åŠ å¿«åŠ è½½é€Ÿåº¦
- **Mock APIå“åº”**ï¼Œä»¥ä¾¿åœ¨æ²¡æœ‰åç«¯ä¾èµ–çš„æƒ…å†µä¸‹è¿›è¡Œæµ‹è¯•
- **æ¨¡æ‹Ÿç½‘ç»œé”™è¯¯**ï¼Œä»¥æµ‹è¯•é”™è¯¯å¤„ç†
- **ä¿®æ”¹è¯·æ±‚å†…å®¹**
- **å®æ—¶åˆ†æå’Œè°ƒè¯•ç½‘ç»œæµé‡**

è¿™äº›åŠŸèƒ½å……åˆ†å±•ç°äº†Pydollä½œä¸ºæ–°ä¸€ä»£æµè§ˆå™¨è‡ªåŠ¨åŒ–å·¥å…·çš„ä¼˜åŠ¿ï¼Œå®ƒèƒ½ç›´æ¥æ§åˆ¶æµè§ˆå™¨ä¸ç›´è§‚çš„å¼‚æ­¥åŸç”ŸAPIã€‚